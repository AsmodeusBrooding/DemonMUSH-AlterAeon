<?xml version="1.0" encoding="iso-8859-1"?>
<muclient>
<plugin
 name="AlterAeon"
 author="See 'help mushz' in-game."
 id="553a883096da345ce6897740"
 language="Lua"
 purpose="Alter Aeon utilities. Don't import this into other muds"
 save_state="y"
 date_written="2009-05-26 07:21:17"
 requires="4.37"
 version="1000000.0"
 >

</plugin>


<!-- Get our standard constants -->

<include name="constants.lua"/>
<!-- stuff -->
<triggers>
 <trigger
 enabled="y"
 match="You miss * vital areas but manage to hit * anyway!"
 send_to="14"
 sequence="99"
 >
 <send>
 </send>
 </trigger>
  <trigger
   enabled="y"
   match="You cast a quick spell on *, hurl it toward *, and it explodes when it gets close to *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."/giblet/%1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You spit into your hand, cast a quick spell, and hurl a wad of corrosive acid at *"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."/giblet/spit.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   match="Invisible claws rake * body, leaving frost-rimmed gashes in their wake!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."/necromancer/spectral claw1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Frost-rimmed claw marks appear on *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."/necromancer/spectral claw2.ogg")</send>
  </trigger>

</triggers>

<aliases>
  <alias
   match="!mapclear"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>rooms={}
rooms[k_room]={}
Note("unexplored map cleared")</send>
  </alias>
</aliases>

<triggers>
  <trigger
   enabled="y"
   match="^\(((\s*\d+|\d+))\)(.*)$"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   group="room"
   script="HandleGroundstring"
   sequence="100"
  >
  <send>
</send>
  </trigger>
</triggers>
<triggers>
<trigger
   enabled="y"
   match="^practiceTbl:You have (-{0,1}\d+) practices.$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
script="hPracticeTbl"
   sequence="1"
  >
</trigger>
<trigger
   enabled="y"
   match="^practiceTbl:.*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="300"
  >
</trigger>
  <trigger
   enabled="y"
   match="^prac(cost|tnp)\:.*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="300"
  >
</trigger>
  <trigger
   enabled="y"
   match="^prac(cost|tnp)\:You can trade (\d+) experience for a practice and have (\d+) experience\. \((\d+)\%\)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>praccost = tonumber("%2")
if "%1" == "tnp" then
Note("You are %4 percent to your next practice.")
end
if (gs("praccing")==true) or exptnl == nil then exptnl = tonumber("%2") end
expInfo.practices.requirement=tonumber("%2")
</send>
  </trigger>

  <trigger
   enabled="y"
   match="^kxwt\_time (\d+) ([a-zA-Z]+) (\d+)\:(\d+) (am|pm)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
script="hGTimeHandle"
   send_to="14"
   sequence="100"
  >
  <send>
atold1 = at1
at1 = "%3"
at2 = "%4"
at3 = "%5"
atd = "%2"
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_waypoint$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."notifications/waypoint.ogg")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_emote (.*)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="1"
  >
  <send>
Note("%1")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_group\_start$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
kplayers={}
kminions={}
kotherminions={}
kpcount = 0
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_group\_end$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
   script="kxwt_group_end"
  >
  <send>
--
</send>
  </trigger>

  <trigger
   enabled="y"
omit_from_output="y"
   match="* appreciates your sacrifice of *"
script="mgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."misc/sac1.ogg")
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   ignore_case="y"
   match="zclan:You have the rank of ([A-Za-z ]*) in the clan ([A-Za-z0-9-,.?' ]*)\.$"
   name="ClanNameCheck"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>if charlist[gs("me")]==nil then charlist[gs("me")] = {} end -- just checking
charlist[gs("me")].oldclan=charlist[gs("me")].clan
charlist[gs("me")].clan=string.lower("%2")
charlist[gs("me")].oldrank=charlist[gs("me")].rank
charlist[gs("me")].rank=string.lower("%1")</send>
  </trigger>

  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   match="^zclan:\s*(?P&lt;fame&gt;\d+)\s+(?P&lt;active&gt;\d+)\s+(?&lt;size&gt;\d+)\s+(?P&lt;lvl&gt;\d+)\s+((?P&lt;pk&gt;\d+)?)\s+((?P&lt;trofy&gt;[A-Za-z]+)?)\s{2,}(?P&lt;name&gt;[A-Za-z-,.?!' ]+)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>--Clan stats update trig
require "wait"
if charlist[gs("me")].clan==string.lower("%&lt;name&gt;") then -- user is in same clan that's in the charlist file
  if charlist[gs("me")].clanactive==nil or charlist[gs("me")].clanfame==nil or charlist[gs("me")].clansize==nil or charlist[gs("me")].clanpk == nil then -- haven't yet set these values, notify user
    firstclancheck=true
    Sound(sdir.."notifications/clannotify/first.ogg")
    Note("Clan notify values were just set. From now on, you will be notified of changes to the enabled values.")
  end -- first clan notify check
  if charlist[gs("me")].clanfame==nil then charlist[gs("me")].clanfame=0 end
  charlist[gs("me")].oldclanfame=charlist[gs("me")].clanfame
  charlist[gs("me")].clanfame="%&lt;fame&gt;"
  if charlist[gs("me")].clanactive==nil then charlist[gs("me")].clanactive=0 end
  charlist[gs("me")].oldclanactive=charlist[gs("me")].clanactive
  charlist[gs("me")].clanactive="%&lt;active&gt;"
  if charlist[gs("me")].clansize==nil then charlist[gs("me")].clansize=0 end
  charlist[gs("me")].oldclansize=charlist[gs("me")].clansize
  charlist[gs("me")].clansize="%&lt;size&gt;"
  if charlist[gs("me")].clanlvl==nil then charlist[gs("me")].clanlvl=0 end
  charlist[gs("me")].oldclanlvl=charlist[gs("me")].clanlvl
  charlist[gs("me")].clanlvl="%&lt;lvl&gt;"
  if (charlist[gs("me")].clanpk == nil) or (charlist[gs("me")].clanpk == "") then charlist[gs("me")].clanpk=0 end
  charlist[gs("me")].oldclanpk=charlist[gs("me")].clanpk
  charlist[gs("me")].clanpk="%&lt;pk&gt;"
  if (charlist[gs("me")].clanpk == nil) or (charlist[gs("me")].clanpk == "") then charlist[gs("me")].clanpk=0 end
  if charlist[gs("me")].clanpk == "" then
   charlist[gs("me")].clanpk = 0
end
  charlist[gs("me")].oldtrofy=charlist[gs("me")].trofy
  charlist[gs("me")].trofy="%&lt;trofy&gt;"
  if gs("clannotify")==true then -- just checking
    if gs("clanfame")==true then
      if tonumber(charlist[gs("me")].clanfame)&gt;tonumber(charlist[gs("me")].oldclanfame) and firstclancheck~=true then -- the clan fame is higher
        DoAfterSpecial(0.7,'Sound(sdir.."notifications/clannotify/fameup.ogg")',12)
        DoAfterSpecial(0.7,[[Note("Clan "..charlist[gs("me")].clan .."'s fame has risen by " ..tonumber(charlist[gs("me")].clanfame)-tonumber(charlist[gs("me")].oldclanfame).."!")]], 12)
      elseif tonumber(charlist[gs("me")].clanfame)&lt;tonumber(charlist[gs("me")].oldclanfame) and firstclanstat~=true then -- clan's fame has fallen.
        DoAfterSpecial(0.7,'Sound(sdir.."notifications/clannotify/famedown.ogg")',12)
        DoAfterSpecial(0.7,[[Note("Clan " ..charlist[gs("me")].clan .."'s fame has fallen by " ..tonumber(charlist[gs("me")].oldclanfame)-tonumber(charlist[gs("me")].clanfame) ..".")]],12)
      end -- clan fame rise / fall checks
    end -- clan fame
    if gs("clanactive")==true then
      if tonumber(charlist[gs("me")].clanactive)&gt;tonumber(charlist[gs("me")].oldclanactive) and firstclancheck~=true then -- clan activity rank has risen
        DoAfterSpecial(3.3,'Sound(sdir.."notifications/clannotify/activityup.ogg")',12)
        DoAfterSpecial(3.3,[[Note("Clan "..charlist[gs("me")].clan .."'s activity rank has risen by ".. tonumber(charlist[gs("me")].clanactive)-tonumber(charlist[gs("me")].oldclanactive) .."!")]],12)
      elseif tonumber(charlist[gs("me")].clanactive)&lt;tonumber(charlist[gs("me")].oldclanactive) and firstclancheck~=true then -- clan activity has fallen
        DoAfterSpecial(3.3,'Sound(sdir.."notifications/clannotify/activitydown.ogg")',12)
        DoAfterSpecial(3.3,[[Note("Clan " ..charlist[gs("me")].clan .."'s activity rank has fallen by " ..tonumber(charlist[gs("me")].oldclanactive)-tonumber(charlist[gs("me")].clanactive) ..".")]],12)
      end -- clan active rise / fall
    end -- clan active
    if gs("clansize")==true then
      if tonumber(charlist[gs("me")].clansize)&gt;tonumber(charlist[gs("me")].oldclansize) and firstclancheck~=true then -- the clan has gained members
        DoAfterSpecial(5,'Sound(sdir.."notifications/clannotify/sizeup.ogg")',12)
        if (tonumber(charlist[gs("me")].clansize)-tonumber(charlist[gs("me")].oldclansize)==1) then
          DoAfterSpecial(5,[[Note("Clan " ..charlist[gs("me")].clan .." has gained " ..tonumber(charlist[gs("me")].clansize)-tonumber(charlist[gs("me")].oldclansize) .." member!")]],12)
        elseif (tonumber(charlist[gs("me")].clansize)-tonumber(charlist[gs("me")].oldclansize)&gt;1) then
          DoAfterSpecial(5,[[Note("Clan " ..charlist[gs("me")].clan .." has gained " ..tonumber(charlist[gs("me")].clansize)-tonumber(charlist[gs("me")].oldclansize) .." members!")]],12)
        end -- plural test
      elseif tonumber(charlist[gs("me")].clansize)&lt;tonumber(charlist[gs("me")].oldclansize) and firstclancheck~=true then -- the clan has lost members
        DoAfterSpecial(5,'Sound(sdir.."notifications/clannotify/sizedown.ogg")',12)
        if tonumber(charlist[gs("me")].clansize)&lt;tonumber(charlist[gs("me")].oldclansize)==1 then
          DoAfterSpecial(5,[[Note("Clan " ..charlist[gs("me")].clan .." has lost " ..tonumber(charlist[gs("me")].oldclansize)-tonumber(charlist[gs("me")].clansize) .." member.")]],12)
        else
          DoAfterSpecial(5,[[Note("Clan " ..charlist[gs("me")].clan .." has lost " ..tonumber(charlist[gs("me")].oldclansize)-tonumber(charlist[gs("me")].clansize) .." members.")]],12)
        end -- plural test
      end -- clan size rise / fall
    end -- clan size
    if gs("clanpk")==true then
      if tonumber(charlist[gs("me")].clanpk)&gt;tonumber(charlist[gs("me")].oldclanpk) and firstclancheck~=true then -- the clan's PK rank has risen
        DoAfterSpecial(7,'Sound(sdir.."notifications/clannotify/pkup.ogg")',12)
        DoAfterSpecial(7,[[Note("Clan " ..charlist[gs("me")].clan .."'s PK rank has risen by " ..tonumber(charlist[gs("me")].clanpk)-tonumber(charlist[gs("me")].oldclanpk) .."!")]],12)
      elseif tonumber(charlist[gs("me")].clanpk)&lt;tonumber(charlist[gs("me")].oldclanpk) and firstclancheck~=true then -- clan PK rank has fallen
        DoAfterSpecial(7,'Sound(sdir.."notifications/clannotify/pkdown.ogg")',12)
        DoAfterSpecial(7,[[Note("Clan " ..charlist[gs("me")].clan .."'s PK rank has fallen by " ..tonumber(charlist[gs("me")].oldclanpk)-tonumber(charlist[gs("me")].clanpk) ..".")]],12)
      end -- Clan PK rise / fall
    end -- Clan PK

  end -- if clan notify is enabled
end -- if stats are for same clan in charlist (should always be the case)</send>
  </trigger>
</triggers>

<triggers>
<trigger
   enabled="y"
   send_to="14"
   sequence="100"
omit_from_output="y"
match="CLANWAR STARTS IN APPROXIMATELY 10 MINUTES, FYI."
>
<send>
if gs("clanwar")==true then
Note("CLAN WAR STARTS IN APPROXIMATELY 10 MINUTES, FYI.")
Sound(sdir.."combat/arena/clanwar 10 minutes.ogg")
end
</send>
</trigger>
<trigger
   enabled="y"
   send_to="14"
   sequence="100"
omit_from_output="y"
match="CLANWAR STARTS IN APPROXIMATELY 5 MINUTES, FYI."
>
<send>
if gs("clanwar")==true then
Note("CLAN WAR STARTS IN APPROXIMATELY 5 MINUTES!")
Sound(sdir.."combat/arena/clanwar 5 minutes.ogg")
end
</send>
</trigger>
  <trigger
   enabled="y"
   match="You create a dust devil to hurl dust, dirt, and debris at *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."druid/dustdevil.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You discover how to use *"
   send_to="14"
   sequence="100"
  >
  <send>Execute("history_add all=You discover how to use %1")
Sound(sdir.."notifications/battlecombo.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You reach into the earth with your magic, then shape and throw two huge fists of earth into *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."druid/fists/"..math.random(1,4)..".ogg",0,0,ppi.getVolume()+20)</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   group="Starcatcher"
   ignore_case="y"
   match="\*\*\* BOOM\! \*\*\*"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if stscatchers &gt;=1 then
ppi.play(sdir.."druid/starcatcher/explode.ogg",0,0,ppi.getVolume()+25)
stscatchers = stscatchers-1
else
end</send>
  </trigger>
  <trigger
   enabled="y"
   group="Starcatcher"
   ignore_case="y"
   match="^(10\.\.\.|9\.\.\.|8\.\.\.|7\.\.\.|6\.\.\.|5\.\.\.|4\.\.\.|3\.\.\.|2\.\.\.|1\.\.\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if stscatchers == nil then -- Something's wrong, our starcatcher setout trigger didn't fire.
stscatchers = 0
stscatchers = stscatchers+1
end
if stscatcherpitch["%1"] then
stscatchersnd = ppi.play(sdir.."druid/starcatcher/countdown.ogg",0,0,ppi.getVolume())
ppi.setPitch(stscatcherpitch["%1"], stscatchersnd)
end</send>
  </trigger>
  <trigger
   enabled="y"
   group="Starcatcher"
   ignore_case="y"
   match="You carefully set down a.*starcatcher bottle\, then carve the breaker rune in exactly the right spot\.\.\."
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if stscatchers == nil then stscatchers = 0 end
stscatchers = stscatchers+1
</send>  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="You create a dust devil to hurl dust, dirt, and debris at *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."druid/dustdevil.ogg")</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="* credits have been added to your account!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/add credits.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You blast * with a sudden gust of magical wind!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."druid/gustwind.ogg")</send>
  </trigger>
</triggers>

<triggers>
<!-- Cleric Utility Spells -->
  <trigger
 enabled="y"
 match="You feel a little better."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/cure light you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 match="You soothe *'s injuries and pray for them to heal."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure light other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 match="* soothes your injuries and prays for them to heal."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure light other.ogg",0,-50)
</send>
 </trigger>
  <trigger
 enabled="y"
 match="^(You feel better\!|You will your injuries to heal and your soul to take courage\.)$"
 regexp="y"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/cure serious you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 match="You will *'s injuries to heal and * soul to take courage."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure serious other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 match="* wills your injuries to heal and your soul to take courage."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure serious other.ogg",0,-50)
</send>
 </trigger>
  <trigger
 enabled="y"
 match="^(A warm feeling fills your body\!|You ask .* to heal your injuries\.)$"
 regexp="y"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/cure critical you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 match="You ask * to heal *'s injuries."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure critical other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 match="* casts a powerful healing spell on you!"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/cure critical other.ogg",0,-50)
</send>
 </trigger>
  <trigger
 enabled="y"
 match="^(A radiantly warm feeling fills your body\!|You feel .*'s power coursing through you\, healing your injuries\.)$"
 regexp="y"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/heal you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 match="You feel *'s power coursing through you to heal *."
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/heal other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 match="You feel your pain diminish as * lays a mighty healing spell on you!"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/heal other.ogg",0,-50)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You cast the spell and feel \w+ breathe new life into you\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/breath of life you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^You cast the spell\, and \w+ breathes new life into .+\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/breath of life other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^.+ casts a spell\, and you feel \w+ breathe life back into your body\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/breath of life other.ogg",0,-50)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You start healing yourself\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/healing touch/start you.ogg")
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^You begin healing (.+)\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/healing touch/start other.ogg",0,50)
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^(.+) begins healing (.+)\.$"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
if "%2" == "you" then
ppi.play(sdir.."cleric/healing touch/start other.ogg",0,-50)
else
ppi.play(sdir.."cleric/healing touch/start other.ogg",0,50)
end
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^You heal (.+)\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
if "%1" == "yourself" then
htid = ppi.play(sdir.."cleric/healing touch/touch you.ogg",0,0)
ppi.setPitch(math.random(-25, 25), htid)
htid = nil
else
htid = ppi.play(sdir.."cleric/healing touch/touch other.ogg",0,50)
ppi.setPitch(math.random(-25, 25), htid)
htid = nil
end
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^([A-Za-z]+) heals ([^\']+)\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
if "%2" == "you" then
htid = ppi.play(sdir.."cleric/healing touch/touch other.ogg",0,-50)
ppi.setPitch(math.random(-25, 25), htid)
htid = nil
else
htid = ppi.play(sdir.."cleric/healing touch/touch other.ogg",0,50)
ppi.setPitch(math.random(-25, 25), htid)
htid = nil
end
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^You are fully healed\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."cleric/healing touch/full you.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is fully healed\.$"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."cleric/healing touch/full other.ogg",0,50)
</send>
 </trigger>
</triggers>

<triggers>
<!-- Druid Utility Spells -->
  <trigger
 enabled="y"
 regexp="y"
 match="^You reach deep into the earth to find a water reservoir\, and force it upward cracking the rock if necessary\.\.\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^A crack appears and water starts bubbling forth from the ground\.$"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/unnatural spring.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You drop to one knee\, clap your hands together\, and use your magic to force the ground into a protective wall\!$"
 keep_evaluating="n"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="99"
 >
 <send>
has_minion_sound = true
Sound(sdir.."druid/minions/earth wall1.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ drops to one knee and claps \w+ hands together\, and an earth wall rises out of the ground to protect \w+\!$"
 keep_evaluating="n"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="99"
 >
 <send>
Sound(sdir.."druid/minions/earth wall2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You use your magic to pull water from a narrow fissure in the earth to form a water weird\!$|^You use your magic to gather water and form a water weird\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
has_minion_sound = true
Sound(sdir.."druid/minions/water weird1.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ forms a water weird using water from a narrow fissure in the earth\!$|^.+\'s magic gathers up water and forms a water weird\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/minions/water weird2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^There is a flare of yellow light\, and slowly A liveoak pulls its roots out of the ground and stumbles toward you\!$|^A liveoak slowly pulls its roots out of the ground and stumbles toward you\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You quickly carve a deep runeword on a nearby tree\, and fill it with sunlight from a.*suncatcher bottle\.\.\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/minions/liveoak tree.ogg")
has_minion_sound = true
Sound(sdir.."druid/minions/liveoak.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You quickly draw a crude runeword on the ground with a stick\, fill it with sunlight from a.*suncatcher bottle\, and drop an acorn in the middle of it\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/minions/liveoak acorn.ogg")
has_minion_sound = true
Sound(sdir.."druid/minions/liveoak.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ starts carving on a nearby tree\.$|^.+ draws a strange pattern on the ground with a stick\, lights it up\, and drops something in the middle of it\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You drop to one knee\, clap your hands together\, and use your magic to rip up the ground and form a shambling mound\!$"
 omit_from_output="y"
 keep_evaluating="n"
   script="sgag"
 send_to="14"
 sequence="99"
 >
 <send>
has_minion_sound = true
Sound(sdir.."druid/minions/shambling mound1.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ drops to one knee and casts a spell that rips up the ground and forms A shambling mound\!$"
 omit_from_output="y"
 keep_evaluating="n"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/minions/shambling mound2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The air around you shifts and settles as it gradually recognizes your magical dominance\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/still air on.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^Your still air spell expires and the safe zone around you gradually fades\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/still air off.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The air around you suddenly seems more stiff and resistant to fast motion\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/featherfall on.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The air around you suddenly relaxes as your feather fall spell expires\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/featherfall off.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You chant a quiet mantra and dump mana into the air around you\, turning it thick and heavy\.$|^.+ chants a quiet mantra\, and the air turns thick and heavy as \w+ magic flows outward\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/windbreaker on.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The artificial stillness in the air fades and is gone\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/windbreaker off.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You throw your magic to the wind and call (A|a|An|an|The|the) (ape|baboon|black bear|black panther|brown bear|coyote|feral boar|gigantic moose|hyena|massive elk|mountain lion|polar bear|porcupine|swarm of bats|swarm of rats|tall stag|winter wolf|wolf|viper|abominable yeti) to this place\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/call animal.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You throw your magic to the wind and call (A|a|An|an|The|the) (alligator|blue shark|crocodile|dolphin|electric eel|gigantic catfish|kraken|mantis shrimp|stingray) to this place\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/call waterborn.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(A|a|An|an|The|the) (alligator|ape|baboon|black bear|black panther|blue shark|brown bear|coyote|crocodile|dolphin|electric eel|feral boar|gigantic catfish|gigantic moose|hyena|kraken|mantis shrimp|massive elk|mountain lion|polar bear|porcupine|stingray|swarm of bats|swarm of rats|tall stag|winter wolf|wolf|viper|abominable yeti) comes into view\, answering your call\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
has_minion_sound = true
Sound(sdir.."druid/minions/%2.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
</triggers>

<triggers>
<!-- Druid Offensive Spells -->
  <trigger
 enabled="y"
 regexp="y"
 match="^You cast a spell on .+ and throw them at .+ where they explode\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
Sound(sdir.."druid/thunder seeds1.ogg")
DoAfterSpecial(0.4,'theygrunt()',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ casts a spell on .+\, then throws them at .+ where they explode\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/thunder seeds2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You throw your magic to the sky and call down lightning to strike your enemies\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
Sound(sdir.."druid/call lightning/start.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is struck by a lightning bolt from the sky\!$"
 omit_from_output="y"
   script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
Sound(sdir.."druid/call lightning/hit.ogg")
DoAfterSpecial(0.3,'theygrunt()',12)
end
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is knocked back and down by the explosion\!$"
 omit_from_output="y"
   script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
DoAfterSpecial(0.5,'ppi.play(sdir.."druid/call lightning/explosion.ogg",0,50)',12)
end
</send>
 </trigger>
  <trigger
 enabled="n"
 regexp="y"
 match="^You lose control of the lightning bolt\, and aim it away from you\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^A powerful lightning bolt suddenly strikes nearby\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/call lightning/miss.ogg")
</send>
 </trigger>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="Item: '*"
   send_to="12"
   sequence="1"
  >
  <send>idlevel = nil
iidflags = nil
iworn = nil
iquality = nil
toprint = nil
iacapply = nil
</send>
  </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="(^You throw your magic to the sky\, trying to pattern a lightning flash to generate thunder\!$)"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
Sound(sdir.."druid/call thunder start.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^An unnatural\, rolling wall of thunder tears across the sky\!$|^An unnaturally loud cascade of thunder sounds a lot closer than seems safe\!$|^A shockingly loud clap of thunder nearly knocks you over\, seeming to come from everywhere at once\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/call thunder strike.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You force magic into the air around you to build up tempest winds\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/tempest/start.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You force more magic into the air to strengthen the tempest winds\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/tempest/strengthen.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The tempest winds slow a bit\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/tempest/slow.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The tempest winds gradually stop\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/tempest/stop.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is buffeted by tempest winds\!$"
 omit_from_output="y"
   script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
DoAfterSpecial(0.2,'ppi.play(sdir.."druid/tempest/buffet"..math.random(1,3)..".ogg",0,math.random(-50,50))',12)
end
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is blinded by the dirt and wind\!$"
 omit_from_output="y"
   script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
DoAfterSpecial(0.2,'ppi.play(sdir.."druid/tempest/blind.ogg",0,math.random(-50,50))',12)
end
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The wind knocks down (.+) and sends \w+ flying\!$"
 omit_from_output="y"
   script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
DoAfterSpecial(0.2,'ppi.play(sdir.."druid/tempest/knockdown.ogg",0,math.random(-50,50))',12)
end
</send>
 </trigger>
</triggers>

<triggers>
<!-- Druid: moon, star, and suncatcher -->
  <trigger
 enabled="n"
 regexp="y"
 match="^You carve the opening runes\.{3}$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^\(You\'ll have to \'carve (moon|star|sun)catcher bottle\' on it to make it usable\.\)$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/create.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You gently inscribe another layer of runes on a (moon|star|sun)catcher bottle\, strengthening it's magic\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/inscribe"..math.random(1,3)..".ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You make a mistake carving on a (moon|star|sun)catcher bottle\, and are just barely able to recover it\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/fail.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You make a mistake carving on a (moon|star|sun)catcher bottle\, shattering it\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/shatter.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^A (moon|star|sun)catcher bottle cracks as you start draining light from it\!$"
 omit_from_output="n"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/crack.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^A cracked (moon|star|sun)catcher bottle shatters as the last of the light is drained from it\.$"
 omit_from_output="n"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/shatter2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You place a (moon|star|sun)catcher bottle somewhere out of the way where it can do its job unmolested\, and protect it with a short concealing spell\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/hide.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You find and retrieve a (moon|star|sun)catcher bottle\, then utter the short sealing spell to keep it from leaking\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."druid/%1catcher/retrieve.ogg")
</send>
 </trigger>
</triggers>

<triggers>
<!-- Demonfire spell -->
  <trigger
 enabled="y"
 regexp="y"
 match="^You cast a short spell between a (.+) soulstone and (.+)\, and a .+ soulstone disappears\!$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.spells then
Note("%0")
else
Note("A %1 soulstone disappears!")
end
Sound(sdir.."necromancer/demonfire/start.ogg")
</send>
 </trigger>
<trigger
 enabled="y"
 regexp="y"
 match="^A gout of red and black flames explodes beneath (.+)\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/demonfire/gout.ogg")
theygrunt()
</send>
 </trigger>
<trigger
 enabled="y"
 regexp="y"
 match="^Reddish black flames explode beneath .+\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/demonfire/gout.ogg")
theygrunt()
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^The demonic flames engulf and follow (.+)\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."necromancer/demonfire/follow.ogg",0,50)
theygrunt()
</send>
 </trigger>
    <trigger
 enabled="y"
 regexp="y"
 match="^The demonic flames follow .+\!$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^The flames beneath (.+) flicker and die out\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/demonfire/end.ogg")
</send>
 </trigger>
  </triggers>

<triggers>
<!-- Mage Minions -->
  <trigger
 enabled="y"
 regexp="y"
 match="^You cast an ice spell to create an evil looking snowman\, then summon a lesser elemental to inhabit it\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
has_minion_sound = true
Sound(sdir.."mage/minions/snowman 1.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ creates an evil looking snowman and animates it using a complex\, multipart spell\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."mage/minions/snowman 2.ogg")
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^You open a small rift to the ethereal plane of \w+ and (summon|draw) (a|an|the) (.+) elemental.+$"
 keep_evaluating="n"
 omit_from_output="y"
   script="mgag"
 send_to="14"
 sequence="99"
 >
 <send>
if FileExists(sdir.."mage/minions/%3 1.ogg") then
 has_minion_sound = true
 Sound(sdir.."mage/minions/%3 1.ogg")
 DoAfterSpecial(0.2,'has_minion_sound = nil',12)
end
</send>
 </trigger>
  <trigger
 enabled="y"
 regexp="y"
 match="^.+ opens a small rift to the ethereal plane of \w+ and (summons|draws) (a|an|the) (.+) elemental.+$"
 keep_evaluating="n"
 omit_from_output="y"
   script="mgag"
 send_to="14"
 sequence="99"
 >
 <send>
Sound(sdir.."mage/minions/%3 2.ogg")
</send>
 </trigger>
</triggers>

<triggers>
<!-- Mage utilities -->
  <trigger
 enabled="y"
 regexp="y"
 match="^(.+) is currently imbued with spell \'(.+)\'\, level (\d+)\.$"
 omit_from_output="n"
 send_to="14"
 sequence="100"
 >
 <send>if gag.expert then
Execute("tts_interrupt %1: level %3 %2.")
else
Execute("tts_interrupt %0")
end</send>
 </trigger>
</triggers>

<triggers>
<!-- Butchering and skinning -->
 <trigger
 enabled="y"
 regexp="y"
 match="^You .*begin cutting pieces of meat from the .+ of .+\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You cut a .+ (meat|steak) from the .+ of .+\.$|^You cut a few meat cuttings from the .+ of .+\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."skills/butcher/cut meat"..math.random(1,3)..".ogg",0,math.random(-25,25))
</send>
 </trigger>
  <trigger
 enabled="n"
 regexp="y"
 match="^There is no more meat left on the .+ of .+\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You .*begin cutting pieces of (hide|skin) from (a|an|the) .+ of .+\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You cut A .+ (hide|skin) of .+ from (a|an|the) .+ of .+ and get it ready to be tanned\.$"
 omit_from_output="y"
   script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."skills/skinning/cut"..math.random(1,3)..".ogg",0,0)
</send>
 </trigger>
<trigger
 enabled="y"
 regexp="y"
 match="^A .+ is too much for you to carry, so you prepare a spot on the ground for it\.$"
 omit_from_output="y"
   script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>
DoAfterSpecial(0.4,'ppi.play(sdir.."items/drop/" .. math.random(1,drops)..".ogg",0,math.random(-75,75))',12)
</send>
 </trigger>
<trigger
 enabled="n"
 regexp="y"
 match="^You are too exhausted\, better rest for a while\.$"
 omit_from_output="y"
   script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="^kxwt_spellup (.*)"
regexp="y"
 send_to="14"
 sequence="99"
omit_from_output="y"
 >
<send>
if rmt["%1"] ~= nil then
 rct["%1"] = nil
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_spelldown (.*)"
regexp="y"
 send_to="14"
 sequence="99"
omit_from_output="y"
 >
<send>
if rmt["%1"] ~= nil then
 rc("%1")
 rct["%1"] = 2
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^mz\_spelltest \((.*?)\)(.*?)"
regexp="y"
 send_to="14"
 sequence="99"
omit_from_output="y"
 >
<send>
if rct["%1"] == 1 then
 rct["%1"] = 2
end
</send>
 </trigger>
  <trigger
   enabled="y"
   match="Your reflexes trigger and you instantly wake to battle!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/fastwake.ogg")</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="You put * in * shell."
   send_to="14"
   sequence="1"
  >
  <send>Sound(sdir.."bombs/put in shell.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You construct an empty grenade shell."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/shell1.ogg")
DoAfterSpecial(0.2,'Sound(sdir.."bombs/shell2.ogg")',12)</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="* suddenly explodes!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/explode.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A ring of icy fog surges outward!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/ice ring.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Burning liquid sprays through the air, sticking to everything it touches!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/fire liquid.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You carefully construct a bladebomb."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/make bladebomb.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You carefully construct a fire bomb."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/make firebomb.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You carefully construct a frostring."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/make frostring.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You construct a fuse."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."bombs/makefuse.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You are rescued from the brink of death, and suddenly find yourself in your recall!"
   send_to="14"
   sequence="100"
  >
  <send>
prevhp = 0
prevmn = 0
Sound(sdir.."notifications/brinkofdeath.ogg")
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="Your wounds accumulate, and your rage starts to build!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/usebrage.ogg")</send>
  </trigger>
</triggers>
<triggers>
</triggers>




<aliases>
  <alias
   match="ctr"
   enabled="y"
   sequence="100"
  >
  <send>control | grep Total</send>
  </alias>

  <alias
   match="kxwt_area --printareanumber"
send_to="12"
   enabled="y"
   sequence="100"
  >
<send>
Note(areanumber)
</send>
</alias>
  <alias
   match="dbn"
send_to="12"
   enabled="y"
   sequence="100"
  >
  <send>
if debugging==1 then
debugging=0
Note("debugging disabled")
else
Note("debugging enabled")
debugging=1
end
</send>
  </alias>

  <alias
   match="ctra"
   enabled="y"
   sequence="100"
  >
  <send>train | grep can train</send>
  </alias>
  <alias
   match="edn"
   enabled="y"
   sequence="100"
  >
  <send>email delete 1</send>
  </alias>
  <alias
   match="ern"
   enabled="y"
   sequence="100"
  >
  <send>email read 1</send>
  </alias>
  <alias
   match="fik"
   enabled="y"
   sequence="100"
  >
  <send>c fi $k</send>
  </alias>
  <alias
   match="flist *"
   enabled="y"
   sequence="100"
  >
  <send>%1 Mush-Z now has a google groups mailing list! To subscribe, visit http://oriolg.es/mush.php and put your email address in the subscribe box.</send>
  </alias>
  <alias
   match="frl"
   enabled="y"
   sequence="100"
  >
  <send>friend list</send>
  </alias>
  <alias
   match="hac"
   enabled="y"
   sequence="100"
  >
  <send>harv teeth corpse</send>
  </alias>
  <alias
   match="halc"
   enabled="y"
   sequence="100"
  >
  <send>harv all corpse</send>
  </alias>
  <alias
   match="has"
   enabled="y"
   sequence="100"
  >
  <send>harv spellcomp corpse</send>
  </alias>
  <alias
   match="ind *"
   enabled="y"
   sequence="100"
  >
  <send>c id %1
ins %1</send>
  </alias>
  <alias
   match="ls *"
   enabled="y"
   sequence="100"
  >
  <send>l %1 -s</send>
  </alias>
  <alias
   match="lse *"
   enabled="y"
   sequence="100"
  >
  <send>list search %1</send>
  </alias>
  <alias
   match="lss"
   enabled="y"
   sequence="100"
  >
  <send>list search -spellcomp</send>
  </alias>
  <alias
   match="ssf *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
Send("get %1 soulstone "..gs("sscontainer"))
Send("get %1 soulstone "..gs("sscontainer"))
Send("c soulforge 1.%1 2.%1")
  </send>
  </alias>
  <alias
   match="ssf"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
Note("This alias forges two soulstones of the same color.  Soulstones are")
Note("fetched from your defined soulstone container.");
Note("Please specify what color of soulstone you want to forge.")
  </send>
  </alias>
  <alias
   match="qt *"
   enabled="y"
   sequence="100"
  >
  <send>quest %1 | grep TODO</send>
  </alias>
  <alias
   match="sbs *"
   enabled="y"
   sequence="100"
  >
  <send>c burning hands %1
c shocking grasp %1
c sick touch %1</send>
  </alias>
  <alias
   match="sl* -f*"
   enabled="y"
   sequence="100"
  >
  <send>sleep | prefix force</send>
  </alias>
  <alias
   match="spc"
   enabled="y"
   sequence="100"
  >
  <send>stor llist -spellcomp</send>
  </alias>
  <alias
   match="taf *"
   enabled="y"
   sequence="100"
  >
  <send>tar %1
fol %1</send>
  </alias>
  <alias
   match="wce *"
   enabled="y"
   sequence="100"
  >
  <send>wh combat | grep %1
wh explorer | grep %1</send>
  </alias>
</aliases>



<aliases>
  <alias
   match="^fame\s*(l|lo|log)$"
   enabled="y"
   regexp="y"
   ignore_case="y"
   sequence="100"
  >
  <send>fame log</send>
  </alias>

  <alias
   match="ttsmana"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if k_maxmana == nil then 
  Note("No prompt available yet.")
else
  Execute("tts_interrupt "..k_mana.." of "..k_maxmana.." mana.") 
end</send>
  </alias>

  <alias
   match="ttshp"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if k_maxhp == nil then 
  Note("No prompt available yet.")
else
  Execute("tts_interrupt "..k_hp.." of "..k_maxhp.." hitpoints.") 
end</send>
  </alias>

  <alias
   match="ttsmv"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if k_maxmove == nil then 
  Note("No prompt available yet.")
else
  Execute("tts_interrupt "..k_move.." of "..k_maxmove.." movement.") 
end</send>
  </alias>

  <alias
   match="ttsop"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if k_target == nil then
  Note("No current or previous target.")
else
  if nfight == 0 then
    optext = "Previous target: "
  else
    optext = ""
  end
  if k_fp == 999 then
    tarcon = "no condition,"
  else
    tarcon = k_fp.."%"
  end
  Execute("tts_interrupt "..optext..tarcon.." "..k_target)
end</send>
  </alias>
  <alias
   match="ttsexp"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
    <send>
if expInfo.exp == nil or
expInfo.tnl.exp==nil or
expInfo.tnl.class==nil or
expInfo.tnl.class=="none" then 
  Note("You haven't received any experience since loading the client, so no information is available yet.")
return -1
end
--check for practice global option enabled.
if(gs("praccing")==true) then
  if exm.status == true then
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.practices.requirement).." xp to train a practice ("..math.floor((expInfo.exp/expInfo.practices.requirement)*100).."%), marking enabled.") 
  else
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.practices.requirement).." xp to train a practice ("..math.floor((expInfo.exp/expInfo.practices.requirement)*100).."%)") 
  end
else
  if exm.status == true then
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.tnl.exp).." xp to level "..expInfo.tnl.class.." ("..math.floor((expInfo.exp/expInfo.tnl.exp)*100).."%), marking enabled.") 
  else
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.tnl.exp).." xp to level "..expInfo.tnl.class.." ("..math.floor((expInfo.exp/expInfo.tnl.exp)*100).."%)") 
  end
end
</send>
  </alias>
  <alias
   match="ttsgold"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if gold == nil then 
  Note("You haven't transacted any gold since loading the client, so no information is available yet.")
else
 Execute("tts_interrupt "..gold.." gold in hand.") 
end
</send>
  </alias>

  <alias
   match="cg *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>Execute("c %1 group")</send>
  </alias>

  <alias
   match="unv"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
if rooms==nil then
  Note("Can't get room table information.")
elseif rooms[k_room]==nil then
  Note("There is no information for this room.")
else
  unexplored={}
  doors={}
  for k,v in pairs(rooms[k_room]) do
    if v=="unexplored" then
      table.insert(unexplored,walkdirs[k])
    elseif v=="door" then
      table.insert(unexplored,walkdirs[k])
    end --unexplored
  end --for
  if (#unexplored>1) then
    count=#unexplored-1
  end --count
  if #unexplored==1 then
    Note(unexplored[1].."?")
  elseif #unexplored>1 then
    Note(table.concat(unexplored, "? ", 1, count).."? "..unexplored[#unexplored].."?")
  else
    --nearest()
  end --count
end --nil
</send>
  </alias>
</aliases>
<triggers>
  <trigger
   enabled="y"
   match="^kxwt_walkdir (\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
if %1 ~= 99 then
 lastdir=walkdirs["%1"]
 pmap()
end
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_group (?P&lt;hp&gt;-?\d+) (?P&lt;mhp&gt;\d+) (?P&lt;mn&gt;-?\d+) (?P&lt;mmn&gt;\d+) (?P&lt;mv&gt;-?\d+) (?P&lt;mmv&gt;\d+) (?P&lt;tag&gt;\S+) (?P&lt;name&gt;.*)"
   omit_from_output="y"
   regexp="y"
script="grsf"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^kxwt_rvnum (\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
nocastroom=false
k_room="%1"
if rooms==nil then
rooms={}
end
if rooms[k_room]==nil then
rooms[k_room]={}
else
if (gs("unexplored")==true) then Execute("unv") end
end
</send>
  </trigger>
  <trigger
   enabled="y"
   match="kxwt_nocast"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
nocastroom=true
</send>
</trigger>

  <trigger
   enabled="y"
   match="Weapon damage: * to * *, * strength to use."
   omit_from_output="y"
   send_to="14"
   sequence="100"
ignore_case="y"
  >
<send>
if (gs("shortid")==1) then
Note("%0")
--return
end
if (gs("shortid")==3) then
Note("%0")
end
--if iidflags==nil then
iidflags=", damage %1 to %2 %3 needs %4 str. "
--else
--iidflags=iidflags..", damage %1 to %2 %3 needs %4 str. "
--end
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="You are beset upon by bandits, and flee with only your life!"
   send_to="14"
   sequence="100"
  >
  <send>
if swheel &lt; 1 then
 ppi.stop(wheel1)
end
if swheel &lt; 2 then
 ppi.stop(wheel2)
end
if swheel &lt; 3 then
 ppi.stop(wheel3)
end
Sound(sdir.."slots/bandit1.ogg")
DoAfterSpecial(1.3,'Sound(sdir.."slots/bandit2.ogg")',12)
DoAfterSpecial(3.3,'Sound(sdir.."slots/losemerchant.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You are ambushed by thieves and have to abandon your cargo!"
   send_to="14"
   sequence="100"
  >
  <send>
if swheel &lt; 1 then
 ppi.stop(wheel1)
end
if swheel &lt; 2 then
 ppi.stop(wheel2)
end
if swheel &lt; 3 then
 ppi.stop(wheel3)
end
Sound(sdir.."slots/bandit1.ogg")
DoAfterSpecial(1.3,'Sound(sdir.."slots/bandit2.ogg")',12)
DoAfterSpecial(3.3,'Sound(sdir.."slots/losemerchant.ogg")',12)</send>
  </trigger>

  <trigger
   enabled="y"
   match="You must take * to *!"
   send_to="14"
   sequence="100"
  >
  <send>
ppi.stop(wheel1)
ppi.stop(wheel2)
Sound(sdir.."slots/travel.ogg")
Sound(sdir.."slots/wagon.ogg")
</send>
  </trigger>
</triggers>
<triggers>
<trigger
   enabled="y"
   match="You start carving * to make an unfinished druidic totem of *."
   omit_from_output="y"
   send_to="14"
   sequence="100"
>
<send>
if not gag.skills then
print("You start carving %1 to make an unfinished druidic totem of %2.")
end
Sound(sdir.."druid/carveTotemStart.ogg.")
</send>
</trigger>
<trigger
   enabled="y"
   match="You start carving on an unfinished druidic totem of *."
   omit_from_output="y"
   send_to="14"
   sequence="100"
>
<send>
if not gag.skills then
print("You start carving on an unfinished druidic totem of %1.")
end
Sound(sdir.."druid/carveTotem"..math.random(1,6)..".ogg")
</send>
</trigger>
<trigger
   enabled="y"
   match="You stop carving on an unfinished druidic totem of * and start thinking about what steps to take next."
   omit_from_output="y"
   send_to="14"
   sequence="100"
>
<send>
if not gag.skills then
print("You stop carving on an unfinished druidic totem of %1 and start thinking about what steps to take next.")
end
</send>
</trigger>
  <trigger
   enabled="y"
   match="The black aura about your body fades."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/darken off.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   group="compare"
   match="* looks * than *"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
</triggers>
<triggers>
<trigger 
match="Type: * Composition: * Defense: * ac-apply *Requires * strength to use."
 enabled="y"
script="idnote"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
 <send>
if gs("shortid")==1 then return end
if ("%1"~="weapon") then
iacapply="%3 min str %5, %2"
else
iacapply=nil
end
</send>
</trigger>
<trigger 
match="^Type: (.*?)\s*Composition: (.*?)"
 enabled="y"
script="idnote"
regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
 <send>
if gs("shortid")==1 then return end
if "%1"=="LIQUID CONTAINER" then
--Send("lecho liquid_id")
elseif ("%1"=="SPELLCOMP" or "%1"=="HERB" or "%1"=="FOOD") then
Send("lecho spellcomp_id")
elseif ("%1"=="OTHER") then
--Send("lecho affects_done")
else
if "%1"~="weapon" then
else
iacapply="%2"
end
end
</send>
</trigger>
<trigger
match="spellcomp_id"
omit_from_output="y"
enabled="y"
send_to="14"
 sequence="100"
>
<send>
if idlevel~=nil then
print("A "..idlevel.." brew component.")
idlevel = nil
end
</send>
</trigger>
<trigger
match="liquid_id"
omit_from_output="y"
enabled="y"
send_to="14"
 sequence="100"
>
<send>
Note("this is a %2 liquid container")
</send>
</trigger>
<trigger
match="This item is bound to you."
 enabled="y"
script="idnote"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
<send>
if gs("shortid")==1 then return end
if iidflags==nil then
iidflags=" bound"
else
iidflags=iidflags.." bound"
end
</send>
</trigger>
<trigger
match="This item is bound to your account."
script="idnote"
 enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
<send>
if gs("shortid")==1 then return end
if iidflags==nil then
iidflags=" account bound"
else
iidflags=iidflags.." account bound"
end

</send>
</trigger>
 <trigger
 enabled="y"
 match="Object is: *"
 omit_from_output="y"
 send_to="14"
 sequence="90"
 >
 <send>
if settings.shortid.status==1 then
Note("Flags: %1")
return
end
if (gs("shortid")==3) then
Note("Flags: %1")
end
if iidflags==nil then
iidflags="%1"
else
iidflags="%1"..iidflags
end
</send>
 </trigger>

  <trigger
   enabled="y"
   match="movingYou can't just walk away from a fight!"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>EnableTimer("maptimer",true)</send>
  </trigger>
</triggers>
<aliases>
<alias
match="known"
enabled="y"
send_to="14"
sequence="5"
>
<send>
--print(#kspells..", "..kspells)

</send>
</alias>
  <alias
   match="sfc *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>Execute("storage fcapture -wearable %1")</send>
  </alias>
</aliases>
<aliases>
  <alias
   match="sfc *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>Execute("storage fcapture -wearable %1")</send>
  </alias>
  <alias
   match="storage fclear"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>storefilter={}
Note("ok, cleared")</send>
  </alias>
</aliases>
<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^Weight\: (.*?)  Size\: (.*?)  (.*?): (.*?)(  Item quality\: (.*?)){0,1}$"
script="idnote"
regexp="y"
omit_from_output="y"
   sequence="1"
send_to="14"
ignore_case="y"
  >
  <send>
--print("matched %1 %2 %3 %4 %6")
if gs("shortid")==1 then return end
if "%3"=="Level" then
--print("%3")
idlevel="level %4"
elseif "%3"=="Total levels" then
idlevel="total %4"
end
iquality="%6"
if "%6"~="" then
iquality=iquality..","
end
--print("%5")
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="Item has other effects:"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
if gs("shortid")==1 then return end
--Send("lecho affects_done")
iaffects={}
</send>
  </trigger>

</triggers>
<triggers>
  <trigger
   enabled="y"
   match="movingAlas, you cannot go that way."
   send_to="14"
omit_from_output="y"
   sequence="100"
  >
  <send>Note("map interrupted unexpectedly, can't find next exit. use zmap resume or zmr to resume.")

</send>
  </trigger>
</triggers>

<timers>
  <timer name="maptimer" script="procmap" enabled="y" second="1.00" offset_second="0.00" >

  </timer>
</timers>

<aliases>
  <alias
   match="zmg *"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap go %1</send>
  </alias>
  <alias
   match="zmd *"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap door %1</send>
  </alias>

  <alias
   match="zms"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap start</send>
  </alias>
  <alias
   match="zmst"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap stop</send>
  </alias>
  <alias
   match="zmgb"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap goback</send>
  </alias>
  <alias
   match="zmp"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap pause</send>
  </alias>

  <alias
   match="zmr"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap resume</send>
  </alias>

  <alias
   match="zmu"
   enabled="y"
   send_to="10"
   sequence="100"
  >
  <send>zmap undo</send>
  </alias>
</aliases>

<triggers>
  <trigger
   enabled="y"
   match="mapmove*"
   omit_from_output="y"
   send_to="14"
   sequence="99"
  >
  <send>
if "%1"~=curmap[1] then
Note("you are in the wrong room for this map! You should be in "..curmap[1])
else
mvtime=true
adir=0
table.remove(curmap,1)
table.remove(curmap,1)
maxdir=#curmap
Send(curmap[1].." | tail 1 | prefix moving")
table.insert(mapback,1,ldir[curmap[1]])
end
</send>
  </trigger>
  <trigger
   enabled="y"
   match="mapmove"
   omit_from_output="y"
   sequence="98"
  >
  </trigger>
  <trigger
   enabled="y"
   match="mapmoveYou dream a dream..."
   omit_from_output="y"
   sequence="100"
  >
  <send>stand
l | head 1 | prefix mapmove</send>
  </trigger>
  <trigger
   enabled="y"
   match="mapstart*"
   omit_from_output="y"
   send_to="14"
   sequence="99"
  >
  <send>
mtime=true
curmap={}
table.insert(curmap,"%1")
table.insert(curmap,true)
Note("starting new map at "..curmap[1]..". To stop, type zmap stop.")
Note("Please note that you will need to use the movement pad or the one letter  direction aliases so the direction is recorded properly. Refer to the readme for more details.")
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="mapstart"
   omit_from_output="y"
   sequence="98"
  >
  </trigger>
  <trigger
   enabled="y"
   match="mapstartYou dream a dream..."
   omit_from_output="y"
   sequence="100"
  >
  <send>stand
l | head 1 | prefix mapstart</send>
  </trigger>
  <trigger
   enabled="y"
   match="No-one in your group is in need of healing."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
</triggers>
<aliases>
 <alias
 script="zmap"
 match="zmap *"
 enabled="y"
 sequence="100"
 >
 </alias>
  <alias
   match="zmap"
   enabled="y"
   sequence="100"
send_to="2"
  >
  <send>
Zmap commands are:
zmap start or zms - start a map
zmap door or zmd name - add a door to a map.
zmap undo or zmu - remove last direction you went to.
zmap pause - stop logging directions, for example if you're not sure which direction is next then go back to where you were and resume.
zmap stop or zmst - complete a map
zmap list - list all your maps
zmap go or zmg mapname go to a given map
zmap resume or zmr - resume an unexpectedly interrupted map or paused map creation.
zmap goback or zmgb - go the last map backwards
</send>
  </alias>
</aliases>
<triggers>
  <trigger
   enabled="y"
   match="^storeprev.*?\(\s*(\d+)\).*$"
   script="prevadd"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="storeprevNothing matching those arguments found."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="^(\d+) visible players out of (\d+) connected \(max was (\d+)\)\."
   regexp="y"
   send_to="14"
omit_from_output="y"
   sequence="100"
  >
  <send>Note("%1/%2 visible max was %3")</send>
  </trigger>
  <trigger
   enabled="y"
   match="storecapNothing matching those arguments found."
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Note("There are no items to capture.")</send>
  </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="Ok."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
  <trigger
   enabled="y"
   match="Welcome back! Thanks for playing Alter Aeon!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/daygift.ogg")</send>
  </trigger>
</triggers>

<aliases>
  <alias
   match="storage fcapture *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
filtering=true
if gs("container")~=nil then
Note("Now filter capturing %1")
Send("storage llist %1 -insult | prefix storecap")
else
Note("You haven't set your container! Look for the container used for item keeping in config.")
end
</send>
  </alias>
  <alias
   match="storage capture *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
filtering=false
if gs("container")~=nil then
Note("Now capturing %1")
Send("storage llist %1 -insult | prefix storecap")
else
Note("You haven't set your container! Look for the container used for item keeping in config.")
end
</send>
  </alias>

  <alias
   match="storage preview *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>
Note("Testing capture of %1")
previtems=0
prevweight=0
Send("storage llist %1 -w | prefix storeprev")
Send("lecho preview_done")
</send>
  </alias>
</aliases>
<triggers>
  <trigger
   enabled="y"
   match="^storeprev.*?\(\s*(\d+)\).*$"
   script="prevadd"
   sequence="100"
regexp="y"
omit_from_output="y"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="ccNothing."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="preview_done"
   omit_from_output="y"
script="prevdone"
   send_to="14"
   sequence="100"
  >
</trigger>
  <trigger
   enabled="y"
   match="set_worn"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
for i,v in pairs(zapped) do
Send("wear "..v)
end
Sound(sdir.."notifications/setcomplete.ogg")
Execute("eql change "..act[2].." "..eql[act[2]].container)
eql.lastset=act[2]
eql.wearing=false
Note("done!")
dbn("Took "..os.clock()-c1.."seconds")</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="icheckYou are carrying */* items with weight *"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>eql.items=tonumber("%1")
eql.maxitems=8
eql.cancarry=eql.maxitems-eql.items
--wearlight()
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="kxwt_expcap *"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>k_cap=tonumber("%1")</send>
  </trigger>
  <trigger
   enabled="y"
   match="kxwt_obj_zap *"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
table.insert(zapped,"%1")
</send>
  </trigger>

</triggers>

<triggers>
  <trigger
   match="Recent tells:"
enabled="y"
   omit_from_output="y"
send_to="14"
   sequence="100"
  >
  <send>
EnableGroup("telltriggers",0)
DoAfterSpecial(1,'EnableGroup("telltriggers",1)',12)</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="ccYou do not see that here."
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
ecnum=ecnum-1
container=ecnum.."."..eql[act[2]].container
table.remove(containerstocheck,1)
if #containerstocheck>0 then
Send("lecho container_check 1")
else
Send("insult -all | prefix eqlc")
Send("lecho wearing_time")
end
</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="cc(carried) * contains:"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Send("lecho container_check "..ecnum+1)
</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="wearing_time"
   omit_from_output="y"
   script="weartime"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_id_end"
   omit_from_output="y"
   script="idtime"
regexp="y"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="lightning_wear"
   omit_from_output="y"
   script="wearlight"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="moving_time"
   omit_from_output="y"
   script="movetime"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="container_check *"
   omit_from_output="y"
   script="containertime"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^cc.*Item\:\s*(\w+)\s*'.*'"
   omit_from_output="y"
   script="itemfoundtime"
regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^storecap.*Item\:\s*(\w+)\s*'.*'"
   omit_from_output="y"
   script="storecapture"
regexp="y"
   sequence="100"
  >
  </trigger>

</triggers>
<triggers>
  <trigger
   enabled="y"
   match="* lifts gently out of your hands and begins hovering in the air before you."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."reforge/lift.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* flashes bright white for a moment, then returns to you."
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."reforge/return.ogg",0,0,31)</send>
  </trigger>
  <trigger
   enabled="y"
   match="* begins to glow a dim, reddish color!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."reforge/dim red.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear the sound of four invisible cards being dealt."
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."reforge/cards.ogg",0,0,32)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear the sound of coins being tossed."
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."reforge/coins.ogg",0,0,32)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear the clatter of invisible wooden dice."
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."reforge/dice.ogg",0,0,45)</send>
  </trigger>
  <trigger
   enabled="y"
   match="Sending activity for channel *"
   omit_from_output="y"
   script="mgag"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="tnl                   even if it's not your main."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="tnlClass     Level  Micro     Exp Cost  Percent"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^tnl(.*)(\s)*36{1}\s*$"
   omit_from_output="y"
   sequence="100"
regexp="y"
  >
  </trigger>
  <trigger
   enabled="y"
   omit_from_output="y"
   sequence="100"
match="tnlYour effective level based on your top four classes is *."
  >
  </trigger>
  <trigger
   enabled="y"
   match="tnlRemember that it's always a good idea to level your cheapest class,"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="You stab *, then rip the wound open with your weapon!"
omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/bls1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* wound keeps bleeding!"
omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/bls2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A twisted bone shield fractures, splits, and abruptly crumbles to dust! (worn by you)"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/shield off.ogg")
</send>
  </trigger>
  <trigger
   enabled="y"
   lines_to_match="2"
   match="^Bloody bone armor suddenly cracks\, breaks\, and splits\, then falls off in\nlarge chunks\. \(worn by you\)$"
   multi_line="y"
   regexp="y"
send_to="12"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor off.ogg")
checkstats()
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The tooth melts and forms a pinkish mass, which you quickly pull and shape into a bone shield."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."necromancer/bone shield.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You begin to feel a little sick to your stomach."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You collapse to the ground while the spell takes hold!"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor4.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel new bones and flesh forming a protective armor plate over your body."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor6.ogg")
checkstats()
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel new bones forming and bursting through your torso!"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor5.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You prick a finger and dip a tooth in your blood, then utter a quick invocation..."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/shield invoque.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You quickly place a hand on the inside of a bone shield to bind it to you."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Send("wear bone shield")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You suddenly feel stabbing pains in your chest and gut!"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You utter an invocation over some teeth, then quickly swallow them."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/barmor11.ogg")
DoAfterSpecial(0.2,'Sound(sdir.."necromancer/barmor12.ogg")',12)</send>
  </trigger>
</triggers>

<triggers>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="Better luck next time."
   send_to="12"
   sequence="100"
  >
  <send>DoAfterSpecial(0.5,'Sound(sdir.."slots/better luck.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="Looks like you didn't hit the jackpot this time."
   send_to="12"
   sequence="100"
  >
  <send>DoAfterSpecial(0.5,'Sound(sdir.."slots/no jackpot.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear a quiet 'ding' sound in the air."
   send_to="12"
   sequence="100"
  >
  <send>DoAfterSpecial(0.5,'Sound(sdir.."slots/quiet bell.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear a loud 'ding' sound in the air."
   send_to="12"
   sequence="100"
  >
  <send>DoAfterSpecial(0.5,'Sound(sdir.."slots/loud bell.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hear a loud racket of bells and alarms that sound you as a winner!"
   send_to="12"
   sequence="100"
  >
  <send>DoAfterSpecial(0.5,'Sound(sdir.."slots/winner.ogg")',12)</send>
  </trigger>

</triggers>
<triggers>
  <trigger
   enabled="y"
   match="( 5)A large pumpkin sits here, grinning up at you."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/random.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* has given you * gift!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/you get gift.ogg")
  Execute("history_add all=%1 has given you a gift!")
  </send>
  </trigger>
<trigger
enabled="y"
match="^You spend (-{0,1}\d+) experience to give (-{0,1}\w+) (?:a gift of experience\.$|an anonymous gift\.$)"
regexp="y"
send_to="14"
   sequence="100"
  >
<send>
expInfo.gift=%1
if (exm.status==true) then
hExpMarkHandle(nil,true,"pgift")
end
</send>
</trigger>
  <trigger
   enabled="y"
   match="(friend) * has given * gift*"
 ignore_case="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/friend gets gift.ogg")
    </send>
  </trigger>
  
  <trigger
   enabled="y"
   match="a flaming pumpkin tattoo in *."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="a Halloween Pumpkin in * rack check."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="a Halloween Pumpkin in Darken pumpkin spawning chamber."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="a Halloween Pumpkin in Dragontooth rack check room."
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="Happy Holidays from the staff at Alter Aeon!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."notifications/advent.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The final wheel stops at '*'!"
   send_to="14"
omit_from_output="y"
   sequence="100"
  >
  <send>ppi.stop(wheel3)
Note("The final wheel stops at %1!")
wheel3s=ppi.play(sdir.."slots/%1.ogg",0,100)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The first wheel stops at '*'!"
   send_to="14"
omit_from_output="y"
   sequence="100"
  >
  <send>ppi.stop(wheel1)
Note("The first wheel stops at %1!")
wheel1s=ppi.play(sdir.."slots/%1.ogg",0,-100)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The second wheel comes to a stop..."
   send_to="14"
   sequence="100"
  >
  <send>
ppi.stop(wheel2)
swheel=2
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The first wheel comes to a stop..."
   send_to="14"
   sequence="100"
  >
  <send>
ppi.stop(wheel1)
swheel=1
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The final wheel comes to a stop..."
   send_to="14"
   sequence="100"
  >
  <send>
ppi.stop(wheel1)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The third wheel comes to a stop..."
   send_to="14"
   sequence="100"
  >
  <send>
ppi.stop(wheel3)
swheel=3
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The second wheel stops at '*'!"
   send_to="14"
omit_from_output="y"
   sequence="100"
  >
  <send>ppi.stop(wheel2)
Note("The second wheel stops at %1!")
wheel2s=ppi.play(sdir.."slots/%1.ogg",0,0)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="The numbered wheel stops at *!"
   send_to="14"
   sequence="100"
  >
  <send>ppi.stop(wheel4)
Sound(sdir.."slots/wheelstop.ogg")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="A fourth wheel containing numbers appears!"
   send_to="14"
   sequence="100"
  >
  <send>
wheel4=ppi.play(sdir.."slots/jackpotwheel.ogg",0,0)
</send>
  </trigger>

  <trigger
   enabled="y"
   match="Three spinning wheels appear in the air before you!"
   send_to="12"
   sequence="100"
  >
  <send>ppi.play(sdir.."slots/wheels appear.ogg",0,0,90)
wheel1=ppi.play(sdir.."slots/wheelsound.ogg",1,-100)
wheel2=ppi.play(sdir.."slots/wheelsound.ogg",1,0)
wheel3=ppi.play(sdir.."slots/wheelsound.ogg",1,100)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="Three more spinning wheels appear in the air before you!"
   send_to="12"
   sequence="100"
  >
  <send>swheel = 0
ppi.play(sdir.."slots/wheels appear.ogg",0,0,90)
wheel1=ppi.play(sdir.."slots/wheelmore.ogg",1,-100)
wheel2=ppi.play(sdir.."slots/wheelmore.ogg",1,0)
wheel3=ppi.play(sdir.."slots/wheelmore.ogg",1,100)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="A final spinning wheel appears in the air before you!"
   send_to="12"
   sequence="100"
  >
  <send>
ppi.play(sdir.."slots/wheels appear.ogg",0,0,90)
wheel1=ppi.play(sdir.."slots/wheelmore.ogg",1,0)
</send>
  </trigger>


  <trigger
   enabled="y"
   match="Two spinning wheels appear in the air before you!"
   send_to="12"
   sequence="100"
  >
  <send>
wheel1=ppi.play(sdir.."slots/wheelmore.ogg",1,-100)
wheel2=ppi.play(sdir.."slots/wheelmore.ogg",1,100)
ppi.play(sdir.."slots/wheels appear.ogg",0,0,90)
</send>
  </trigger>

  <trigger
   enabled="y"
   match="You offer * gold to the gods..."
   send_to="12"
   sequence="100"
  >
  <send>Sound(sdir.."slots/offergold2.ogg")
DoAfterSpecial(0.2,'Sound(sdir.."slots/offergold1.ogg")',12)</send>
  </trigger>
</triggers>

<aliases>
  <alias
   match="rank *"
   enabled="n"
   send_to="12"
   sequence="99"
  >
  <send>rankname="%1"
Send("who combat | prefix crank")

</send>
  </alias>
</aliases>
<triggers>
  <trigger
   enabled="y"
   match="erank[Lvl Tot  Cl]  Name        Explorer Points"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>epoints={}
DoAfterSpecial(0.2,[[
require "tprint"
ts = {} -- table to hold the keys
table.foreach (epoints, function (k, v) table.insert (ts, v) end )
table.sort(ts,
function (k,v)
if k>v then
return true
end
end
)
name=string.lower(rankname)
points=epoints[name]
if points==nil then
return
end
table.foreach(ts,
function(k,v)
if v==points then
rank=k
end
end
)
Note(name.." has "..points.." explorer points, rank "..rank)
]],12)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="erank\[\s*\d+\s*\d+\s*\w+\]\s*(\w+)\s*(\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>epoints[string.lower("%1")]=tonumber("%2")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="crank[Lvl Tot  Cl]  Name          Combat Points"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
points={}

DoAfterSpecial(0.2,[[
require "tprint"
ts = {} -- table to hold the keys
table.foreach (points, function (k, v) table.insert (ts, v) end )
table.sort(ts,
function (k,v)
if k>v then
return true
end
end
)
name=string.lower(rankname)
points=points[name]
if points==nil then
Note("Something's gone awry! Make sure you entered a full character name.")
return
end
table.foreach(ts,
function(k,v)
if v==points then
rank=k
end
end
)
Note(name.." has "..points.." combat points, rank "..rank)
Send("who explorer | prefix erank")
]],12)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="crank\[\s*\d+\s*\d+\s*\w+\]\s*(\w+)\s*(\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>points[string.lower("%1")]=tonumber("%2")

</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="You can now learn the * '*'!"
   sequence="100"
send_to="14"
  >
  <send>Execute("history_add all=You can now learn %2!")
Execute("history_add learn=You can now learn %2!")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="^kxwt_brew_start"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>brewing=1
recipe={}
ritems=0
DoAfterSpecial(0.2,"process_recipe()",12)
DoAfterSpecial(3,"brewing=0",12)
Sound(sdir.."brewing/start.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_brew_end"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
require "wait"
wait.make(function()
wait.time(3)
brewing=0
Sound(sdir.."brewing/bell.ogg")
if (gs("brewlog")==true) then
AppendToNotepad("brews", "Successful recipe of "..#recipe.." ingredients:\\r\\n")
for i,v in pairs(recipe) do
AppendToNotepad("brews",v.."\\r\\n")
end
end
end)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="Type: ARMOR*Defense: * ac-apply*"
   send_to="12"
   sequence="100"
  >
  <send>ac=" ac %2 "</send>
  </trigger>
  <trigger
   enabled="y"
   match="Type: CONTAINER   Composition: MAGIC   Weight capacity: * of * lbs."
   send_to="2"
omit_from_output="y"
   sequence="100"
  >
  <send>Has %1 of %2 pounds.</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   regexp="y"
   match="^(A|An|The) .+ rips a bone from (a|an|the) .+ of .+ as a replacement\.$"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."necromancer/consume bone"..math.random(1,5)..".ogg",0,math.random(-25, 25))</send>
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^(A|An|The) .+ rips and tears into (a|an|the) .+ of .+\, devouring it\!$|^(A|An|The) .+ claws at and begins eating (a|an|the) .+ of .+\!$"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>ppi.play(sdir.."necromancer/consume corpse"..math.random(1,5)..".ogg",0,math.random(-25, 25))</send>
  </trigger>
  <trigger
   enabled="y"
   match="A flesh beast rips a chunk of flesh from the corpse of * and slowly eats it."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/consume flesh.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A deadly mist begins rising from *'s body..."
   send_to="12"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/deadly mist.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You start the life tap and begin diverting the blood into a prepared bottle."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/blood bottle.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You cut deep into the * of * to find a central artery, then bottle a small amount of the blood."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/blood bottle.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You fill the bottle, staunch the wound, and immediately cast the sealing spell."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You cut deep into the * of *, but are unable to find an untouched artery."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/harvest blood fail1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You cut deep into the * of * to find a central artery, but fumble the bottle and ruin your preparations."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/harvest blood fail2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You start the life tap, but fumble the bottle ruin it."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/harvest blood fail2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You tap your life, and a blood red winged demon flaps quickly toward *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/mist1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="^You cast the spell and shatter a vial of (preserved|monster) blood, sending a red winged demon toward .*\!$"
   omit_from_output="y"
   script="sgag"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/bottle mist1.ogg")</send>
  </trigger>
</triggers>

<triggers>
 <trigger
  enabled="y"
  match="The gods penalize you for botting!"
  send_to="14"
  sequence="100"
  >
  <send>ss("recast",false)
  Note("Bot thwacker thinks you are botting. Disabling all auto recasting to be safe.")</send>
 </trigger>
  <trigger
   enabled="y"
   match="* hits A metal construct and is stabbed by a flailing metal limb!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/mparry1.ogg")
DoAfterSpecial(0.2,'Sound(sdir.."necromancer/mparry2.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="* hits A wood woad and is stabbed by a wooden spike!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/wparry1.ogg")
DoAfterSpecial(0.2,'Sound(sdir.."necromancer/wparry2.ogg")',12)</send>
  </trigger>
  <trigger
   enabled="y"
   match="* lend* you * strength for a moment..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turnf2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* pauses and looks about blankly."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/feeble mind.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* is weakened by your curse."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/weaken.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* pauses and looks about confused."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/forgetfulness.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* starts having trouble moving * feet."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/leadfoot.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* unleashes a powerful psionic blast, turning your brain into jelly!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/psionic.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A circle of roots and vines burst forth from the ground around *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/roots start.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A storm of thousands of * shards whirls about *, dragging the wind with them and slashing anything that gets in the way!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/storm2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A vampire bites *!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/vamp bite.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A vampire shouts a ferocious warcry at *!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/vamp scream.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A vampire's eyes take on an unsettling red glow, and it glares at *!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/vamp int.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="More roots sprout out of the ground to entangle *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/roots more.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="REBOOTING."
   send_to="14"
   sequence="100"
  >
  <send>rct={}</send>
  </trigger>
  <trigger
   enabled="y"
   match="REBOOT IMPENDING, EVERYONE PLEASE RECALL AND SAVE."
   send_to="14"
   sequence="100"
  >
  <send>if gs("rebootsounds")==1 then
Sound(sdir.."notifications/rebootnow.ogg")
elseif gs("rebootsounds")==2 then
Sound(sdir.."notifications/event_reboot_00.ogg")
end
Execute("history_add all=rebooting, everyone please recall and save")</send>
  </trigger>
  <trigger
   enabled="y"
   match="REBOOT IN APPROXIMATELY * MINUTES, FYI."
   send_to="14"
   sequence="100"
  >
  <send>
if gs("rebootsounds")==1 then
Sound(sdir.."notifications/reboot.ogg")
elseif gs("rebootsounds")==2 then
if "%1" == "15" then
Sound(sdir.."notifications/event_reboot_15.ogg")
elseif "%1" == "10" then
Sound(sdir.."notifications/event_reboot_10.ogg")
elseif "%1" == "5" then
Sound(sdir.."notifications/event_reboot_05.ogg")
elseif "%1" == "2" then
Sound(sdir.."notifications/event_reboot_02.ogg")
end
end
Execute("history_add all=reboot in %1 minutes!")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You try to direct the sunstorm spell..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/sunstorm.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You carve a circle and set of old runewords deep in the ground, then fill the lines with glittering starlight from a*starcatcher bottle."
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  <send>
has_minion_sound = true
Sound(sdir.."druid/minions/boneman.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
  </trigger>
  <trigger
   enabled="y"
   match="A blinding column of white light fills the circle, reaching to the heavens!"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="A shambling bone man forms and steps out of your circle, filling the air with the stench of sulfur!"
   omit_from_output="y"
   script="ngag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You direct your solar lance at *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."druid/solar lance.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You utter a quick spell to temporarily open a*suncatcher bottle and spray the liquid into the air!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."druid/release sunlight.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Thousands of * shards whirl around you like a tornado!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/storm1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Thousands of * shards whirl around you like a tornado, slashing everything in their path!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/storm1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Translucent magical flames spring to life around *! *"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/flameblade.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="With considerable effort, you focus your mana and grow a light crystal shield."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/crystal shield.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You gather darkness around yourself."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."shadow/cloak on.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You gather terrifying shadows around yourself."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."shadow/cloak fear on.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The gastly shapes circling around you flow into your shadow and vanish."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."shadow/cloak fear off.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You are surrounded with a thick, black fog."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/darken on.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You call upon * to strike down * with fire."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/flamestrike.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_audio spell/harm$"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/harm.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You raise * at * and smite it with your harm spell!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You gesture at * and let loose your harm spell!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^You cast a powerful spell on the (bleaching skeleton|corpse|gutted carcass) of .+\, slowing its decay\.$"
   omit_from_output="y"
   regexp="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/preserve.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You choke and gag on the water in your lungs, as your spell wears out."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/water off.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You become unable to sense the presence of poison."
   omit_from_output="n"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/dpoison off.ogg")</send>
  </trigger>
    <trigger
   enabled="y"
   match="You come out of your whirling attack ready to face another opponent."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/whirl off.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You cry victory over your fallen enemy!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>
  _vic_state = 0
  Sound(sdir.."skills/victory.ogg")
  </send>
  </trigger>
  <trigger
   enabled="y"
   match="You haven't had a recent victory worth shouting about."
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
if _vic_state == 1 then
 _vic_state = 0
else
 Note("You haven't had a recent victory worth shouting about.")
end
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You drive your weapon into a nearby shadow."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/strike1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel a huge burst of power from the gods!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turnf4.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel a surge of power from the gods..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turnf2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* shrinks away from your faith, but still attacks!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turn shrink.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* struggles against your faith, but still attacks!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turn struggle.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   match="* slowly backs away from you..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turn backaway.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel that * with you..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turnf1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feell a sudden burst of power from the gods!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/turnf3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You hold your hands out in front of you, and will a dark cloud of magic into existence above them.  Staring into it, you see an image..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/farsee.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You make a shallow cut on your arm, and paint yourself with the blood."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/valor1.ogg")
Sound(sdir.."skills/valor2.ogg")
Sound(sdir.."skills/valor3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You make a shallow yet bloody cut and begin tapping your life."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/tap begin.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You quench your thirst for blood and the red haze slowly clears from your vision."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/bquench.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You quickly bind your wound and stop tapping your life."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/tap stop.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You slowly part your hands, and * appears between them."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/holyweapon.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You stand in the center of a raging blizzard created by your own magic."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/blizzard.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You tap your life, and a swarm of blood red demons fly quickly toward *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/mist2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="^You cast the spell and shatter a vial of (preserved|monster) blood, sending a swarm of red winged demons toward .*\!$"
   omit_from_output="y"
   script="sgag"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/bottle mist2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You whirl and fight in a flurry of attacks!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."skills/whirl on.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Your lungs feel funny, kinda dry... water anyone?"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/water on.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Your vision takes on a slightly greenish tinge."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>
Sound(sdir.."spells/dpoison on.ogg")</send>
  </trigger>
      <trigger
   enabled="y"
   match="Your weapon thrusts from a shadow to strike *!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>DoAfterSpecial(0.4,'Sound(sdir.."shadow/strike2.ogg")',12)</send>
  </trigger>
</triggers>
<!-- Ground Strike -->
<triggers>
  <trigger
   enabled="y"
   match="(?:^You try to strike the ground before .*, but your grip slips and the attack fails!$|^You strike the ground before .* but fail to transfer the force of your attack!$)"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  ppi.play(sdir.."skills/ground strike/failswing.ogg",0,0,ppi.getVolume()+15)</send>
  </trigger>

  <trigger
   enabled="y"
   match="^You do a short lunge and swing The .* into the ground before .*\!$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  ppi.play(sdir.."skills/ground strike/swing.ogg",0,0,ppi.getVolume())</send>
  </trigger>
  <trigger
   enabled="y"
   match="^(.*) takes a direct hit as the ground erupts and explodes beneath .*!$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  ppi.play(sdir.."skills/ground strike/direct.ogg",0,rnd_right(),ppi.getVolume()+25)
  theygrunt()
  </send>
  </trigger>
  <trigger
   enabled="y"
   match="^.* takes a glancing blow as the ground erupts and explodes beneath .*!$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  ppi.play(sdir.."skills/ground strike/partial.ogg",0,rnd_right(),ppi.getVolume()+35)
  theygrunt()
  </send>
  </trigger>
  <trigger
   enabled="y"
   match="^The ground erupts and explodes, but .* narrowly avoids the blast!$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  ppi.play(sdir.."skills/ground strike/miss.ogg",0,rnd_right(),ppi.getVolume()+40)
  </send>
  </trigger>
</triggers>

<aliases>
  <alias
   match="eqw* *"
   enabled="y"
   sequence="100"
send_to="12"
  >
  <send>Execute("eql wear %2")</send>
  </alias>
  <alias
   match="eqr* *"
   enabled="y"
   sequence="100"
send_to="12"
  >
  <send>Execute("eql remove %2")</send>
  </alias>
  <alias
   match="eqc* *"
   enabled="y"
   sequence="100"
send_to="12"
  >
  <send>Execute("eql create %2")</send>
  </alias>

</aliases>
<triggers>
  <trigger
   enabled="y"
   match="* hits you squarely with a sneaky roundhouse kick!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* hits you with a stunningly strong mule kick!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* kick at you, but barely makes contact."
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* kicks you while you're down, what a low blow!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick4.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You dodge a poorly placed kick from *."
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kickdodge.ogg")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="A fuzzy cloud of magic numbs your mind, making thinking really difficult."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/feeble you.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A wall of ice quickly grows up around *, trapping him!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/ice prison.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
match="The fog in your mind slowly clears, you can think again!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/feeble off.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You cast the spell to merge * soulstone and * soulstone..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/soulforge.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You gather energy from * and channel it towards *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/tap.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You gather your power and store * spell in *."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/store.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You quickly make some infused ink from *."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You create a scribed scroll of *!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."mage/scribe.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You scribe another spell onto a *!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."mage/scribe.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You suddenly feel like a clumsy oaf."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/clums.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You throw a handful of crushed leaves into the air, and a sudden gust of wind blows them all around you!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/mass conf.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You throw down a handful of teeth to create a tall prison of jagged bone teeth, trapping * inside!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/bone prison.ogg")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="* glows yellow for a moment, then the light fades into nothingness."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/enchantarmor.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* is engulfed in a writhing mass of biting ethereal mouths!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/sphere3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* is made clumsy and uncoordinated by your curse."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/clums.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A brilliant white light suddenly surrounds your hands."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/sacred1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You lightly touch *'s hands, and a brilliant white light surrounds them."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/sacred1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="A shimmering distortion surrounds * for a moment."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/leth.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="As you hit *, a burst of bright light surges from your hands to engulf it!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/sacred2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Everything around you suddenly speeds up, happening in a blur of motion."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/leth off.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The bite marks on * ooze and rot!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/sphere4.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The stake driven through * shadow falls free."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/bindfree.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The world abruptly slows down around you."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/leth.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You attempt to pin * shadow to the ground, but miss!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/bindmiss.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You begin casting Nar's famous spell..."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/sphere1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You call upon * to remove the poison from you and heal you."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/rem poison.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You call upon * to sanctify and make this a place of healing."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/haven2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You complete the spell, and hurl a ghastly looking ball of nether-energy at *!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/sphere2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You concentrate and conjure forth a huge wall of ice!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/wall of ice.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You draw a mass of darkness from a nearby shadow, and shape it into a number of small blades."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/blades.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You drive a stake through * shadow, pinning it in place!"
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/bind.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You step into a shadow and emerge elsewhere."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/walk.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Dark figures step from the shadows and solidify into exact replicas of you."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/decoy.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel slightly sick for a moment as a 'slow poison' spell takes hold."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/slow on.ogg")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel the thin yet potent presence of life flow around you into the room."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/haven3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You feel your magically enhanced charisma fading."
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/presence off.ogg")
checkstats()
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You pull at the shadows and shape a small hole in reality, then step through it."
   omit_from_output="y"
   script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."shadow/asylum.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You raise your arms and begin the rituals required by the spell."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/haven1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You suddenly feel better, but realize that your protection from poison has worn off."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/slow off.ogg")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="You suddenly feel confident and more popular."
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."spells/presence on.ogg")
checkstats()</send>
  </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="* soulstone shatters, and the freed soul howls as it is drawn into *!"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."necromancer/soulbind.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You kick * but barely make contact."
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick2.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You kick * while *'s down!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick4.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You land a solid mule kick on *!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick3.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You sneak a solid roundhouse kick on *!"
   omit_from_output="y"
   script="cgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."kick/kick1.ogg")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="The red mist hovering near you gathers together and solidifies into a vampire."
   omit_from_output="y"
   script="sgag"
   sequence="100"
send_to="14"
  >
  <send>Sound(sdir.."necromancer/vampire form.ogg")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
omit_from_output="y"
script="sgag"
   match="You trace symbols in the air, which briefly spark and crackle..."
send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."channelcast/light.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
omit_from_output="y"
script="sgag"
   match="You trace invisible lines in the air, which begin to hum faintly..."
send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."channelcast/crystal.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
omit_from_output="y"
script="sgag"
   match="You trace symbols of power, momentarily leaving trails of frost hanging in the air..."
send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."channelcast/frost.ogg")</send>
  </trigger>

</triggers>

<triggers>
  <trigger
   enabled="y"
   match="* stomps on you and you hear something crunch!"
   send_to="14"
script="skgag"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/crunch.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You stomp on * and hear something crunch!"
omit_from_output="y"
   send_to="14"
script="skgag"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/crunch.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* stomps on you but nearly misses!"
omit_from_output="y"
   send_to="14"
script="skgag"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/miss1.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You try to stomp on * but only barely make contact."
script="skgag"
omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/miss1.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   match="* stomps on your toes!  OW!"
script="skgag"
omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/toes.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You stomp on * toes!"
script="skgag"
omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/toes.ogg")</send>

  </trigger>

  <trigger
   enabled="y"
   match="* stomps on your toes!  OW!"
script="skgag"
omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/toes.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   match="You narrowly avoid getting an appendage stomped on by *!"
omit_from_output="y"
script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/miss2.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   match="* narrowly avoids getting stomped on by you!"
omit_from_output="y"
script="skgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."stomp/miss2.ogg")</send>
  </trigger>
</triggers>
<triggers>
 <trigger
 keep_evaluating="y"
 match="^kxwt_(.*)"
enabled="y"
send_to="14"
 omit_from_output="y"
 regexp="y"
 sequence="300"
 >
<send>
table.insert(kxwts,"%1")
dbn("%1")
</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
match="zchn:[mushznews] *: *"
   ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="0"
 >
 <send>Execute("history_add all=%2")
Note("Mush-z News! %2")
ppi.play(sdir.."notifications/news.ogg",0,0)</send>
 </trigger>

 <trigger
 enabled="y"
 match="You have become more renowned!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/fame.ogg")</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="( 0)Hundreds of small crystals hang motionless in the air."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You begin casting a complex spell..."
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channelcast/begin.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You complete your spell!"
 omit_from_output="y"
 script="sgag"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You trace fiery glowing symbols in the air before you..."
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channelcast/fire.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You feel queasy as the spell takes root in your blood and bones."
 omit_from_output="y"
 send_to="14"
 sequence="100"
script="sgag"
 >
 <send>
Sound(sdir.."spells/dying breath on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A vampire quietly hisses an unintelligible and foul sounding word..."
 omit_from_output="y"
 send_to="14"
 sequence="100"
script="cgag"
 >
 <send>
Sound(sdir.."necromancer/vampire hiss.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="zknow"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^tnlClass\s*Current\s*Cost to level\s*Percent"
 omit_from_output="y"
regexp="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will now see a *TICK* marker when ticks hit."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

 <trigger
 enabled="y"
 match="^mzscr.*$"
 omit_from_output="y"
 regexp="y"
 sequence="300"
 >
 </trigger>
</triggers>
<timers>
 <timer name="rctimer" script="rectimer" second="2.00" offset_second="0.00" >
 <send></send>

 </timer>
</timers>
<triggers>
 <trigger
 enabled="y"
 match="You will now see a *TICK* marker when ticks hit."
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>

 <trigger
 enabled="y"
 match="zknowCleric"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="zknowMage"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="zknowNecromancer"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="zknowDruid"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

 <trigger
 enabled="y"
 match="zknowThief"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="zknowWarrior"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You use your faith in * as a shield to protect you."
 omit_from_output="y"
 script="sgag"
send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/faith on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your shield of faith dissipates, and you no longer feel as protected by *."
 omit_from_output="y"
 script="sgag"
 sequence="100"
send_to="14"
 >
 <send>Sound(sdir.."spells/faith off.ogg")
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="tnlYou have spent * out of * total fame."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 regexp="y"
 match="^You throw a control weather spell wild and freeze the air around you\!$"
 omit_from_output="y"
script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^A thick layer of bone chilling fog forms around you\.$"
 omit_from_output="y"
script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/icefog.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You begin trying to pick *..."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."pick/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You continue to manipulate the lock..."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You try another go at picking the lock..."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You attempt to pick the lock..."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your thief abilities were insufficient for that attempt."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You weren't quite smart enough to figure it out that time around."
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel the latches slide gently inside the lock..."
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."lock/"..math.random(1,rpick)..".ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="mzstatAttributes*"
 omit_from_output="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
match="You are surrounded by a flickering blue glow.  When it fades, *"
 omit_from_output="y"
 script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/blue glow self.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You scan the surrounding area..."
send_to="14"
 omit_from_output="y"
 sequence="100"
 >
<send>if not gag.misc then Note("You scan the surrounding area...") end
</send>
 </trigger>
</triggers>
<aliases>
 <alias
 match="cacc"
 enabled="y"
 sequence="100"
 >
 <send>control all consume ?corpse</send>
 </alias>
 <alias
 match="set container *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>ss("container","%1")
Note("Container set to %1")</send>
 </alias>
</aliases>
<triggers>
 <trigger
 enabled="y"
 match="You make a small incision and drain some fluid into a vial of bile."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/get_bile.ogg")
if gs("dcomps")==2 then
Send("put yellowish bile in "..gs("container"))
elseif gs("dcomps")==3 then
Send("drop yellowish bile;sacrifice yellowish")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You roughly hack out a small bladder of black fluid and tie off the ends with string."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/get_bladder.ogg")
if gs("dcomps")==2 then
Send("put bladder bile in "..gs("container"))
elseif gs("dcomps")==3 then
Send("drop bladder bile;sacrifice bladder")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You find a small bladder of green fluid, and carefully tie off the ends before removing it."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/get_green.ogg")
if gs("dcomps")==2 then
Send("put strange bladder in "..gs("container"))
elseif gs("dcomps")==3 then
Send("drop strange bladder;sacrifice bladder")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel a lump, so you cut open an organ and retrieve a * stone."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/get_stone.ogg")
if gs("dcomps")==2 then
Send("put jagged yellow stone in "..gs("container"))
elseif gs("dcomps")==3 then
Send("drop jagged yellow stone;sacrifice jagged")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You find an out-of-place dark mass, and carefully cut it from its surroundings."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/get_mass.ogg")
if gs("dcomps")==2 then
Send("put sickly tumor in "..gs("container"))
elseif gs("dcomps")==3 then
Send("drop sickly tumor;sacrifice tumor")
end</send>
 </trigger>
</triggers>
<aliases>
 <alias
 match="(?:^bsc$|^bsc\s+(\w+).*$)"
regexp="y"
 enabled="y"
 sequence="100"
send_to="12"
 >
 <send>
PSend("bloodsacrifice ?corpse %1")
</send>
 </alias>
 <alias
 match="confset *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>settings["%1"].status=true
Note("ok")</send>
 </alias>
</aliases>
<triggers>
 <trigger
 enabled="y"
 ignore_case="y"
 match="(friend) * completed quest *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/friend quest.ogg")
Execute("history_add friends=%1 completed quest %2")
Execute("history_add all=%1 completed quest %2")
</send>
 </trigger>
 <trigger
 enabled="y"
 ignore_case="y"
 match="(friend) * completed custom job *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/friend quest.ogg")
Execute("history_add friends=%1 completed custom job %2")
Execute("history_add all=%1 completed custom job %2")
</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="tnlClass Current Cost to level Percent"
omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="tnltnlYou have spent * out of * total fame."
omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<aliases>

 <alias
 match="config"
 enabled="y"
 send_to="12"
 sequence="1"
 >
 <send>
config_options()
</send>
 </alias>

 <alias
 match="config *"
 enabled="y"
 sequence="2"
send_to="12"
 >
 <send>
config_option_parse("%1")
</send>
 </alias>
 <alias
 match="lin *"
 enabled="y"
 sequence="100"
 >
 <send>look in %1 | prefix contcheck</send>
 </alias>
 <alias
 match="lin * *"
 enabled="y"
 sequence="100"
send_to="12"
 >
 <send>
Send("look in %1 | prefix contcheck | grep %2")
checkfor="%2"
</send>
 </alias>

</aliases>
<triggers>
 <trigger
 enabled="y"
 match="contcheck*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if container["%1"]~=nil then
container["%1"]=container["%1"]+1
else
container["%1"]=1
end 
</send>
</trigger>
 <trigger
 enabled="y"
 match="contcheckYou do not see that here."
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
Note("There is no container with such name.")
</send>
</trigger>
 <trigger
 enabled="y"
 match="contcheck(*) * contains:"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
require "wait"
wait.make(function()
container={}
wait.time(1)
Note("%2 has in it:")
for i,v in pairs(container) do
if not (checkfor=="") then
 if string.match (i,checkfor) then
if v>1 then
Note(v.."("..i..")") end
if v==1 then Note(i) end
end
else
if v>1 then
Note(v.."("..i..")") end
if v==1 then Note(i) end
end
end
container={}
checkfor=""
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="kxwt_sky *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_time (-{0,1}\d+) (\w+) (\w+)"
 regexp="y"
script="k_time"
 sequence="100"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="kxwt_fighting -1"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
 <send>
if gs("areamusic")==true then
  if ppi.isPlaying(areamusic_playout_device_id)==1 then
    ppi.slideVol(tonumber(gs("vol_areaid")),areamusic_playout_device_id)
  else
    set_areamusic()
  end
end
if (gs("battlemusic") == true) then
  ppi.fadeout(battleid)
  battleplaying=0
end
fight = 0
nfight=0
fnames={}
fc=0
EnableGroup("combat",0)
prevfc=0
mvalarm=0
dmg=0
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^kxwt_prompt (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+)"
 script="k_prompt"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_area (-{0,1}\d+) (.*)"
 script="k_area"
sequence="2"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
script="k_killarea"
 match="^kxwt_area -1\s*"
sequence="1"
regexp="y"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
<trigger
 enabled="y"
 match="(?:^lvltbl:(\w+)\s+(-{0,1}\d+)(?:\s+|\s+(-{0,1}\d+)/\s*(-{0,1}\d+)\s+)(-{0,1}\d+)(?:\s*$|\s+\(\s*(-{0,1}\d+)%)(?:\)$|\)\s+<- You can level!$|\)\s+\(\s*(-{0,1}\d+)\s*(hours|minutes) remaining\)$)|^lvltbl:Your experience cap is (-{0,1}\d+) exp.$|^lvltbl:.*$)"
 script="hLvltbl"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
</trigger>

 <trigger
 enabled="y"
 match="^kxwt_exp (-{0,1}\d+)"
 script="k_exp"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_terrain (-{0,1}\d+)"
 script="k_terrain"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_gold (-{0,1}\d+)"
sequence="1"
regexp="y"
omit_from_output="y"
omit_from_log="y"
send_to="14"
 >
<send>
gold=tonumber("%1")
if prevgold>gold then
if goldlog==1 then
Note("Your gold decreased from "..prevgold.." to "..gold)
end
end
prevgold=gold
</send>
 </trigger>
 <trigger
 enabled="y"
 match="kxwt_position *"
sequence="1"
omit_from_output="y"
omit_from_log="y"
send_to="14"
 >
<send>
if "%1" == "sitting" then
 pose = "rest"
 if gs("regen") == 3 then
  Execute("show regen | prefix mzscr:")
 end
elseif "%1" == "sleeping" then
 pose = "sleep"
 if gs("regen") >= 2 then
  Execute("show regen | prefix mzscr:")
 end
elseif "%1" == "standing" then
 pose = "stand"
else
 Note("%1")
end
</send>
</trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="tnlYour experience cap is * exp."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="tnpYour experience cap is * exp."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="tnlYou have * experience and * total levels in your top four classes."
omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
keep_evaluating="y"
 match="You don't learn much from this battle, but still receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
Note("You don't learn much from this battle, but still receive "..ntrunk("%1").." experience.")
death_exp(%1)
</send>
 </trigger>
 <trigger
 enabled="y"
keep_evaluating="y"
match="You are too high level, but still receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."notifications/exp too high level.ogg")
Note("You are too high level, but still receive "..ntrunk("%1").." experience.")
DoAfterSpecial(0.2, 'death_exp(%1)', 12)
</send>
 </trigger>
</triggers>
<aliases>
 <alias
 match="volup"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>volup()</send>
 </alias>
 <alias
 match="voldown"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>voldown()</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="voltoggle"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>voltoggle()</send>
 </alias>
</aliases>
<aliases>

 <alias
 match="automaticmove"
 enabled="y"
 sequence="100"
send_to="12"
 >
 <send>
if autogo==1 then
autogo=0
Note("auto move off.")
end
autogo=1
Send("look")
</send>
 </alias>
</aliases>
<triggers>
 <trigger
 enabled="y"
 match="Alter Aeon has support for the blind and visually impaired."
 omit_from_output="n"
 send_to="14"
 sequence="100"
 >
 <send>newchar=1
ss("me","new")
Note("Creating a new character. Please say yes when the game asks you if you want to enable screen reader mode.")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="\s*You receive an explorer point!"
 send_to="14"
regexp="y"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/ep.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
   regexp="y"
 match="^You mutter an incantation over a (pair of teeth as they dissolve|dragon tooth as it dissolves)\, then push the magic to your skeletal minions\.\.\.$"
 omit_from_output="y"
send_to="14"
 script="sgag"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* cracks and pops as the magic reinforces its bones."
 omit_from_output="y"
send_to="14"
 script="sgag"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/mend bones.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You pull out a dragon tooth, cast a spell, and quickly drop it."
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 <send>
has_minion_sound = true
Sound(sdir.."necromancer/skeleton form.ogg")
DoAfterSpecial(0.2,'has_minion_sound = nil',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The tooth splits, unfolds, and grows into A *."
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* pulls out a large tooth, casts a spell, and quickly drops it."
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You bind * to the skeleton, strengthening it and turning it into A * wielding skeletal knight!"
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/knight form %2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You bind * to the skeleton, strengthening it and turning it into A lightning wielding skeletal lich!"
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/lich zap form.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You bind * to the skeleton, strengthening it and turning it into A fiery skeletal lich!"
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/lich fire form.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You bind * to the skeleton, strengthening it and turning it into A frost covered skeletal lich!"
 omit_from_output="y"
send_to="14"
 script="ngag"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/lich ice form.ogg")</send>
 </trigger>
</triggers>
<triggers>
  <trigger
   enabled="y"
   match="Your*teeth grow restless.  It would be unwise to collect any more."
   send_to="14"
   sequence="100"
  >
  <send>if autosac==true then
autosac=false
Send("sacrifice ?corpse")
end</send>
  </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You don't see any usable teeth *."
 send_to="14"
omit_from_output="y"
 sequence="100"
 >
 <send>
if autosac==true then
autosac=false
Send("sacrifice ?corpse")
end
if teeth~=0 then
if gs("dteeth")==true then
Send("drop "..teeth.." teeth")
end
Note("You extract "..teeth.." teeth.")
end
if dteeth~=0 then
Note("You extract "..dteeth.." dragon teeth.")
end

teeth=0
dteeth=0
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You can't safely carry any more teeth, and stop."
 send_to="14"
omit_from_output="y"
 sequence="100"
 >
 <send>
if autosac==true then
autosac=false
Send("sacrifice ?corpse")
end
if teeth~=0 then
if gs("dteeth")==true then
Send("drop "..teeth.." teeth")
end
Note("You extract "..teeth.." teeth.")
end
if dteeth~=0 then
Note("You extract "..dteeth.." dragon teeth.")
end

teeth=0
dteeth=0
</send>
 </trigger>

 <trigger
 enabled="y"
 match="^ccheck\&lt;(.*)\&gt;\s*(.*)$"
 omit_from_output="y"
 regexp="y"
 sequence="2"
send_to="14"
 >
<send>
eql[act[2]]={}
eql[act[2]].container=act[3]
eql[act[2]].mode=creatingmode
Send("remove "..act[3])
Execute("eqlt")
Note("set created.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="ccheckYou insult *"
 omit_from_output="y"
 send_to="14"
 sequence="2"
 >
 <send>
eql[act[2]]={}
eql[act[2]].mode=creatingmode
eql[act[2]].container=act[3]
Execute("eqlt")
Note("set created.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You insult *"
 send_to="14"
 sequence="2"
 >
 <send>cmi=0
SetClipboard(cmistr)
cmistr=""
</send>
 </trigger>

 <trigger
 enabled="y"
 match="ccheckWho or what do you want to insult?"
 omit_from_output="y"
 send_to="14"
 sequence="2"
 >
 <send>Note("Error - You don't have "..act[3].." in your inventory.")
for i,v in pairs(eql.setnames) do
if v==act[2] then
table.remove(eql.setnames,i)
end
end
creatingset=false
creating=false</send>
 </trigger>
 <trigger
 enabled="y"
 match="eqlcWho or what do you want to insult?"
 omit_from_output="y"
 send_to="14"
 sequence="2"
 >
 <send>if eql.creating then
eql.creating=false
Note("You can't make a set out of nothing!")
eql[act[2]]=nil
return
else
if eql.wearing then
moving=false
weareq(moving)
end
end
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^eqlc(\w+)\s*-\s*(.*?)\s*?(\w+)$"
 omit_from_output="y"
 regexp="y"
 script="eqltrig"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^eqlc(about body)\s*-\s*(.*?)\s*?(\w+)$"
 omit_from_output="y"
 regexp="y"
 script="eqltrig"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^eqlc(on body)\s*-\s*(.*?)\s*?(\w+)$"
 omit_from_output="y"
 regexp="y"
 script="eqltrig"
 sequence="100"
 >
 </trigger>

</triggers>

<triggers>
 <trigger
 enabled="y"
 match="(You can only split gold with players, not minions.)"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="\s*You receive a combat point!"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/get point.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="With the last soulstone, A prepared * corpse is fully prepared."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("With the last soulstone, A prepared %1 corpse is fully prepared.") end
Sound(sdir.."necromancer/prepare full.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You chant a spell to magically bind * to A prepared * corpse."
omit_from_output="y"
 sequence="100"
send_to="12"
 >
 <send>
--if not gag.spells then Note("You chant a spell to magically bind %1 to A prepared %2 corpse.") end
Sound(sdir.."necromancer/prepare soul.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="A ghoul goes berserk in battle!"
script="ngag"
 send_to="14"
 sequence="30"
 >
 <send>
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ghoul jumps to your side in battle!"
script="ngag"
 send_to="14"
 sequence="30"
 >
 <send>
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A skeleton jumps to your side in battle!"
 send_to="14"
 sequence="30"
 >
 <send>
Sound(sdir.."undead/skw-assist.ogg")
</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="A ghoul rips and tears into * with filthy, diseased claws!"
script="ngag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.minions then Note("A ghoul rips and tears into %1 with filthy, diseased claws!")
end
Sound(sdir.."undead/ghoulclaws.ogg")
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ghoul bites * with diseased, razor sharp teeth!"
script="ngag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.minions then Note("A ghoul bites %1 with diseased, razor sharp teeth!")
end
Sound(sdir.."undead/ghoulbite.ogg")
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ghoul bites * with diseased, razor sharp teeth!"
script="ngag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.minions then Note("A ghoul bites %1 with diseased, razor sharp teeth!")
end
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")
Sound(sdir.."undead/ghoulbite.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ghoul jumps at * clawing and biting!"
script="ngag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.minions then Note("A ghoul jumps at %1 clawing and biting!")
end
Sound(sdir.."undead/ghoulclaws2.ogg")
Sound(sdir.."undead talk/ghoul/"..math.random(1,ghoultalk)..".ogg")</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="A skeletal mage throws a bolt of fire at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A skeletal mage throws a bolt of fire at %1!") end
Sound(sdir.."necromancer/magefire/"..math.random(1,magefire)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A fiery skeletal lich throws a bolt of fire at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A fiery skeletal lich throws a bolt of fire at %1!") end
Sound(sdir.."necromancer/magefire/"..math.random(1,magefire)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A skeletal mage throws a bolt of ice at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A skeletal mage throws a bolt of ice at %1!") end
Sound(sdir.."necromancer/mageice/"..math.random(1,mageice)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A frost covered skeletal lich throws a bolt of ice at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A frost covered skeletal lich throws a bolt of ice at %1!") end
Sound(sdir.."necromancer/mageice/"..math.random(1,mageice)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A skeletal mage throws a bolt of lightning at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A skeletal mage throws a bolt of lightning at %1!") end
Sound(sdir.."necromancer/magezap/"..math.random(1,magezap)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A lightning wielding skeletal lich throws a bolt of lightning at *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("A lightning wielding skeletal lich throws a bolt of lightning at %1!") end
Sound(sdir.."necromancer/magezap/"..math.random(1,magezap)..".ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You set up a crude summoning circle and place * on the ground inside it."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."necromancer/s-circle.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your offer of * is accepted."
 send_to="14"
 sequence="100"
 >
 <send>minion=true
DoAfterSpecial(2,'Sound(sdir.."necromancer/accept offer.ogg")',12)</send>
 </trigger>
 <trigger
 enabled="y"
 match="An energetic green demon appears out of a flash of green light in the middle of the circle."
 send_to="14"
 sequence="100"
 >
 <send>minion=true
DoAfterSpecial(1,'Sound(sdir.."necromancer/green demon.ogg")',12)</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* is near death!"
 send_to="14"
 sequence="100"
 >
 <send>
if gs("soulsteal")==true then
if kspells["soulsteal"]==1 then
stealnext=true
end
end
Sound(sdir.."necromancer/near death.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You throw a ball of freezing unfire at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You throw a ball of freezing unfire at %1") end
yspell("coldfire")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="A clay man forms from nearby dirt and clay to serve you."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.minions then Note("A clay man forms from nearby dirt and clay to serve you.") end
minion=true
noreclay=true
Sound(sdir.."necromancer/clay man.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="Enter your message. Type *"
 send_to="14"
 sequence="100"
 >
 <send>afk=1</send>
 </trigger>

 <trigger
 enabled="y"
 match="^getContext\:(.*)$"
omit_from_output="y"
 send_to="14"
regexp="y"
 sequence="99"
 >
 <send>
   noContext="What kind of information would you like?"
   noContextShowHelpString="Type \'help show info\' to see a general list of things you can use."
   if ("%1"==noContext) then
   -- no context; nothing much to do here other than set the variables to none.
set_current_context_variables("none",no_context_id())
   editing=0
   login() -- continue loading if starting up.

   elseif ("%1"==noContextShowHelpString) then -- break to not parse the second line to the show command:
   return
   else
   -- handle different context
   refresh_context()
   editing=1
   end
 </send>
 </trigger>

  <trigger
 enabled="y"
 match="^getCurrentContext\:\[\s*(\d+)\] - (.*)  \<--------- current context$"
omit_from_output="y"
 send_to="14"
                                                             script="refresh_context"
regexp="y"
 sequence="99"
                                                             >
  </trigger>
 <trigger
 enabled="y"
 match="^kxwt_context (.*)$"
omit_from_output="y"
 script="k_context"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>
   
   afk=1
editing=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_context (none)$"
omit_from_output="y"
 script="k_context"
 regexp="y"
 send_to="14"
 sequence="98"
 >
 <send>
      afk=0
editing=0
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_action (\d+)"
regexp="y"
omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
if "%1" == "0" or "%1" == "10" then
 kxwt_action = 0
else
 kxwt_action = 1
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="The crystals in the air ring loudly as they are disturbed!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/chimes.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your hands take on a sickly green tint."
script="sgag"
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sickening touch.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You lightly touch * hands, and they take on a sickly green tint."
script="sgag"
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sickening touch.ogg")</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You cast the spell to separate soul from body, and pull * essence into a * soulstone!"
 send_to="14"
omit_from_output="y"
 sequence="100"
 >
 <send>if not gag.spells then Note("You cast the spell to separate soul from body, and pull %1 essence into a %2 soulstone!")
else
Note("You obtain %1 %2 soulstone!")
end
soulstone=true
if gs("soulaction")==2 then
  if gs("sscontainer")~=nil then
    Send("put soulstone "..gs("sscontainer"))
  end
elseif gs("soulaction")==3 then
  Send("soulmarket sell %2 -f")
end
Sound(sdir.."spells/soulsteal/"..math.random(1,rsoul)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You struggle to pull * essence into a * soulstone!"
 send_to="14"
omit_from_output="n"
 sequence="100"
 >
 <send>
soulstone=true
if gs("soulaction")==2 then
  if gs("sscontainer")~=nil then
    Send("put soulstone "..gs("sscontainer"))
  end
elseif gs("soulaction")==3 and gs("sellstruggle")==true then
  Send("soulmarket sell %2 -f")
end
Sound(sdir.."necromancer/soul struggle.ogg")
</send>
 </trigger>

</triggers>

<triggers>
 <trigger
 enabled="y"
 match="You down a small potion, cast the spell, and quickly lie down before it takes effect."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/deathly sleep on.ogg")
 nocastdeathly=1
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel the deathly sleep leave your veins and begin sleeping normally."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/deathly sleep off.ogg")
 nocastdeathly=0
 </send>
 </trigger>

 <trigger
 enabled="y"
 match="You feel your soul leaving your body..."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/free spirit.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="(?:^You quickly return to your body.$|^You return to your senses, unaware of where you are or how you got here.$)"
 send_to="14"
 regexp="y"
 sequence="100"
 >
   <send>
     Sound(sdir.."spells/free return.ogg")
     -- Finish reloading if the user connects with free spirit; Setting kxwt isn't possible.
     SendNoEcho("/show |prefix getContext:")
   </send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="Your friends * are logged in."
 omit_from_output="y"
 send_to="14"
script="friends"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^\(friend\) (.+) was killed(| by .+)\!$"
 ignore_case="y"
 send_to="14"
 regexp="y"
 sequence="1"
 >
 <send>
Sound(sdir.."notifications/friend dies.ogg")
Execute("history_add all=%0")
Execute("history_add friends=%0")
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="(notify) (player) The Lag Monster killed by Thantos the Executioner while in room [ 0] The Unholy Temple of Dentin"
 sequence="1"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^mzuVersion\s+Tag\s+mushz-stable\s+-\s+(\S+).*$"
 omit_from_output="y"
 send_to="14"
regexp="y"
 sequence="1"
 >
 <send>
if gs("version")~=GetVariable("version") then
 ss("version",GetVariable("version"))
end
curvertbl = utils.split(GetVariable("version"), "-") -- Split the current version variable into a table, delimited by dashes
newver="%1"
newvertbl = utils.split(newver, "-") -- Split the latest version variable into a table, delimited by dashes
if(newver==GetVariable("version")) then
Note("You are using the latest version of mush-z.")
elseif string.match(GetVariable("version"), "b") then
 PSend("version | grep mushz-beta | prefix mzbu")
else
utils.msgbox("It is time to update! The latest stable release of mush-z is newer than your version. The latest stable release is "..newver..". Your current version is "..GetVariable("version")..".","Update time!")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^mzbuVersion\s+Tag\s+mushz-beta\s+-\s+(\S+).*$"
 omit_from_output="y"
 send_to="14"
regexp="y"
 sequence="1"
 >
 <send>
if gs("version")~=GetVariable("version") then
 ss("version",GetVariable("version"))
end
if string.match(GetVariable("version"), "b") and (newver ~= nil) then
 newbetaver = "%1"
 curvertbl = utils.split(GetVariable("version"), "-") -- Split the current version variable into a table, delimited by dashes
 newvertbl = utils.split(newver, "-")
 newbetavertbl = utils.split(newbetaver, "-") -- Split the latest version variable into a table, delimited by dashes
 if tonumber(curvertbl[2]..curvertbl[3]) &lt; tonumber(newvertbl[1]..newvertbl[2]) then
  utils.msgbox("It is time to update! The latest stable release of mush-z is newer than your beta version. The latest stable release is "..newver..". Your current version is "..GetVariable("version")..".","Update time!")
 else
  Note("You are running mush-z beta version b-" ..curvertbl[2].."-"..curvertbl[3]..".")
  if tonumber(curvertbl[2]..curvertbl[3]) &lt; tonumber(newbetavertbl[2]..newbetavertbl[3]) then
   Sound(sdir.."notifications/new beta.ogg")
   Note("There is a newer beta version available! Please run the beta updater to update to version b-" ..newbetavertbl[2].."-"..newbetavertbl[3]..".")
  else
   Note("This is currently the latest beta version available.")
  end
 end
end
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^tnl.*$"
 omit_from_output="y"
regexp="y"
 sequence="300"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^tnl You can train to get a practice, at a cost of (\d+) experience each."
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>tnl_prac=%1
</send>
 </trigger>
 <trigger
 enabled="y"
match="tnlClass Current Cost to level Percent"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^tnlCleric\s*-{0,1}\d?.*\((.*)%\)"
 omit_from_output="y" regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>tnl_cleric=tonumber(removespaces("%1"))</send>
if not tnl_cleric then tnl_cleric=0 end
print(tnl_cleric)
 </trigger>
 <trigger
 enabled="y"
 match="^tnlMage\s*-{0,1}\d+.*\((.*)%\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
tnl_mage=tonumber(removespaces("%1"))</send>
 </trigger>
 <trigger
 enabled="y"
 match="^tnlNecromancer\s*-{0,1}\d+.*\((.*)%\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>tnl_necro=tonumber(removespaces("%1"))
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^tnlDruid\s*-{0,1}\d+.*\((.*)%\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>tnl_druid=tonumber(removespaces("%1"))
tnl_exp=exp
arr_max={}
 if(tnl_prac==nil) then
tnl_prac=praccost
end
str=""
if tnl_mage and tnl_mage&lt;100 then str=str.."m "..tnl_mage.." " end
if tnl_cleric and tnl_cleric&lt;100 then str=str.."c "..tnl_cleric.." " end
if tnl_thief and tnl_thief&lt;100 then str=str.."t "..tnl_thief.." " end
if tnl_warrior and tnl_warrior&lt;100 then str=str.."w "..tnl_warrior.." " end
if tnl_necro and tnl_necro&lt;100 then str=str.."n "..tnl_necro.." " end
if tnl_druid and tnl_druid&lt;100 then str=str.."d "..tnl_druid.." " end
if ((tnl_exp/tnl_prac*100)&lt;100) then
prac="prac "..(tnl_exp/tnl_prac*100) 
str=str..prac
end
tnl_mage=nil
tnl_cleric=nil
tnl_thief=nil
tnl_warrior=nil
tnl_necro=nil
tnl_prac=nil;
Note(str)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="^tnlThief\s*-{0,1}\d+.*\((.*)%\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
tnl_thief=tonumber(removespaces("%1"))</send>
 </trigger>
 <trigger
 enabled="y"
 match="^tnlWarrior\s*-{0,1}\d+.*\((.*)%\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
tnl_warrior=tonumber(removespaces("%1"))</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="rgs"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="rgsEvent based regen is currently OFF."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>eventregen=0</send>
 </trigger>
 <trigger
 enabled="y"
 match="rgsEvent based regen is currently ON."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>eventregen=1</send>
 </trigger>
 <trigger
 enabled="y"
 match="rgsTo change it, use 'set regen on' or 'set regen off'."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="rgsYou may only do this once per login."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will no longer see tick markers."
 omit_from_output="y"
 sequence="100"
 send_to="14"
 >
 <send>
PSend("autotick | prefix mzscr") -- Make this context aware to avoid an editor with autotick.
</send>
 </trigger>
 <trigger
 enabled="y"
 match="WARNING - Your storage locker expires in *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You don't see anything named that in the corpse of *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
<trigger 
match="Type: WEAPON   Composition: *"
script="idnote"
 enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
 <send>
if gs("shortid")==1 then return end
iacapply=nil
Note("a %1 weapon.")
</send>
</trigger>
<trigger 
match="Type: * Composition: * Defense: * ac-apply"
script="idnote"
 enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
>
 <send>
if gs("shortid")==1 then return end
if "%1"~="weapon" then
iacapply="%3, %2"
else
iacapply="%2"
end
</send>
</trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^\*TICK\*"
 omit_from_output="y"
regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
if(gs("ticksounds")==true) then
Sound(sdir.."notifications/tick.ogg")
DoAfterSpecial(25,'Sound(sdir.."notifications/tick5.ogg")',12)
end
if (gs("autotime") == 2 or gs("autotime")==3) and (at2 == "00") and atold1 ~= at1 then -- Only trigger if autotime is enabled and it's the top of a game hour, and the current hour isn't a repeat of the last one.
Note(at1.." "..at3)
Sound(sdir.."notifications/hour.ogg")
if gs("autotime") == 3 then -- If user chose audio announcements
if (at1 == "6") or (at1 == "12") then -- If the hour is 6 or 12
DoAfterSpecial(0.25,'Sound(sdir.."notifications/day/"..at1..at3.." "..math.random(1,5)..".ogg")',12)
end -- if hour is 6 or 12
end -- if user chose audio announcements
end -- autotime
if gs("sunsounds") == true and at1 == "7" and at2 == "00" and atold1 ~= at1 then -- if sunsounds is enabled, the hour is 7, the minute is 00, and this hour isn't a repeat of the last one
if at3 == "am" then -- play the right sunsound
DoAfterSpecial(0.25,'Sound(sdir.."notifications/sunsounds/sunup 1.ogg")',12)
elseif at3 == "pm" then
DoAfterSpecial(0.25,'Sound(sdir.."notifications/sunsounds/sundown 1.ogg")',12)
end -- play the right sunsound
end -- sunsounds
</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="Weapon speed: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("speed %1")
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You link hands with * to the right."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You link hands with %1 to the right.") end
ppi.play(sdir.."spells/gcast/link2.ogg",0,50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You link hands with * to the left."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You link hands with %1 to the left.") end
ppi.play(sdir.."spells/gcast/link1.ogg",0,-50)
</send>
 </trigger>
<trigger
 match="* lead* the group in the casting of a spell..."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("%1 lead%2 the group in the casting of a spell...") end
DoAfterSpecial(0.4,'Sound(sdir.."spells/gcast/circle.ogg")',12)
</send>
 </trigger>
<trigger
 match="You feel power coursing through your body as the spell is cast."
omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You feel power coursing through your body as the spell is cast.") end
DoAfterSpecial(1.3,'Sound(sdir.."spells/gcast/energy.ogg")',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Someone suddenly stabs you in the back!"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You are affected by:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="mzscrClosed doors will no longer be automatically displayed."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>PSend("autodoor")
Note("Configuring autodoor.")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are affected by:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="^You try to .* (\w?)'s .* injuries."
regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
PSend("condition %2")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You suddenly feel less tired and more refreshed!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You suddenly feel less tired and more refreshed!") end
play("skills/secondwind",0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="The physical reserve deep within you feels replenished."
 send_to="14"
 sequence="100"
 >
 <send>play("skills/secondwind charge",0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your body is still too exhausted from last time."
 send_to="14"
 sequence="100"
 >
 <send>play("skills/secondwind fail",0)</send>
 </trigger>

 <trigger
 enabled="y"
 match="You try to push beyond the boundries of your endurance, but nothing happens!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You try to push beyond the boundries of your endurance, but nothing happens!") end
play("skills/secondwind fail",0)</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="You do not seem to be carrying anything named '$held'."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 group="show5"
 match="^tnlYou need (-{0,1}\d+) experience to .*level (\w*) ?t?o? ?(.*) ?and have (-{0,1}\d+) experience\. \(.*\)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
expInfo.tnl.exp=tonumber("%1")
expInfo.tnl.class="%2"
expInfo.tnl.leveling="%3"
if (gs("praccing")==false) then
exptnl=tonumber("%1")
classtnl="%2"
if(expInfo.practices.showCostNoEcho~=true) then
if "%2" == "" then
Note("Your next cheapest level is a tie for "..exptnl) 
elseif string.find("%3", ":") then
Note("Your next cheapest level is a "..classtnl.." micro for "..exptnl) 
else
Note("Your next cheapest level is "..classtnl.." for "..exptnl) 
end
end
levtnl="%3"
end
EnableGroup("show",0)
expInfo.practices.showCostNoEcho=false</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="[new line]"
 send_to="14"
 sequence="100"
 >
<send>
afk=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are now AFK."
 send_to="14"
 sequence="100"
 >
 <send>afk=1
Note("timers disabled.")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Subject:"
 send_to="14"
 sequence="100"
 >
 <send>afk=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Enter message one line at a time. '/help' for help."
 send_to="14"
 sequence="100"
 >
 <send>afk=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Message written."
 send_to="14"
 sequence="100"
 >
 <send>afk=0
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Whatever you were writing on, its gone now!"
 send_to="14"
 sequence="100"
 >
 <send>afk=0
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Who is this note addressed to?"
 send_to="14"
 sequence="100"
 >
 <send>afk=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Message posted."
 send_to="14"
 sequence="100"
 >
 <send>afk=0
</send>
 </trigger>
 <trigger
 enabled="y"
 match="What is the short title or subject of your note?"
 send_to="14"
 sequence="100"
 >
 <send>afk=1
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You return to your keyboard."
 send_to="14"
 sequence="100"
 >
 <send>afk=0</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* stops resting, and stands up."
 sequence="99"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="kxwt_spst *, * minutes"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="99"
 >
 <send>spell="%1"
mins=tonumber("%2")
if (mins==nil) then
  return
end
if (mins&lt;21) then
  if (mins==20) then
    if (warned3[spell]~=1) then
      if gs("warn") then
         Note("Warning - "..spell.." will fall in 3.")
      end
      warned1[spell]=0
      warned2[spell]=0
      warned3[spell]=1
      DoAfterSpecial(45,"warned3[spell]=0",12)
    end
  elseif (mins==10) then
    if (warned2[spell]~=1) then
      if gs("warn") then
        Note("Warning - "..spell.." will fall in 2.")
      end
      warned1[spell]=0
      warned2[spell]=1
      warned3[spell]=0
      DoAfterSpecial(45,"warned2[spell]=0",12)
    end
  elseif (mins==0) then
    if (warned1[spell]~=1) then
      if gs("warn") then
        Note("Warning - "..spell.." is about to fall.")
      end
      if (grouped==1) and (gs("swarn")==true) then
        PSend("sub "..spell.." in 1.")
      end
      warned1[spell]=1
      warned2[spell]=0
      warned3[spell]=0
      DoAfterSpecial(45,"warned1[spell]=0",12)
    end
  end
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="Class Current Cost to level Percent"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="spfl*"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You barely remember anything about that spell, but attempt to cast it anyway."
 send_to="14"
 sequence="100"
 >
 <send>casting=""</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="mzstatWeapon: *, damage type *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="mzstat*|*Dex: */* | Zap: *|*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_dex=tonumber("%3")
s_sz="%5"
if (s_dex~=s_prevdex) then
if (jli==0) then
if (gs("autostat")==true) then
Note("Your dex is now "..s_dex)
end
end
s_prevdex=s_dex
end
if (s_sz~=s_prevsz) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your zap save is now "..s_sz)
end
end
s_prevsz=s_sz
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstat-------------------+--------------+--------------+-----------------------"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzstat-------------------+--------------+--------------+-----------------------"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzstatArmor: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_ac="%1"
if (s_ac~=s_prevac) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Armor: "..s_ac)
end
end
s_prevac=s_ac
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatCler: * | Chr: */* | Poison: * | *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_chr=tonumber("%2")
s_sp="%4"
if (s_chr~=s_prevchr) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your chr is now "..s_chr)
end
end
s_prevchr=s_chr
end
if (s_sp~=s_prevsp) then
if (jli==0) then
if (gs("autostat")==true) then
Note("Your poison save is now "..s_sp)
end
end
s_prevsp=s_sp
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="^mzstatHit Bonus:\s*(-{0,1}\d+)\s*Damage\/Time\:\s*(-{0,1}\d+)"
regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
s_hit=tonumber("%1")
if (s_hit~=s_prevhit) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your hitroll is now "..s_hit)
end
end
s_prevhit=s_hit
end
s_dam=tonumber("%2")
if (s_dam~=s_prevdam) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your damage is now "..s_dam)
end
end
s_prevdam=s_dam
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^mzstat.*$"
regexp="y"
 omit_from_output="y"
 sequence="300"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzstatHit Roll: * Attack speed: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_hit="%1"
if (s_hit~=s_prevhit) then
if (jli==0) then
if (gs("autostat")==true) then

Note("your hitroll is now"..s_hit)
end
end
s_prevhit=s_hit
end
s_speed="%2"
if (s_speed~=s_prevspeed) then
if (jli==0) then
if (gs("autostat")==true) then

Note("your speed is now "..s_speed)
end
end
s_prevspeed=s_speed
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatHp: */* | Str: */* | Spells: * | Experience: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_str=tonumber("%3")
s_ss="%5"
if (s_str~=s_prevstr) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your strength is now "..s_str)
end
end
s_prevstr=s_str
end
if (s_ss~=s_prevss) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your spell save is now "..s_ss)
end
end
s_prevss=s_ss
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatMage: * | Con: */* | Breath: * | Age: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_con=tonumber("%2")
s_sb="%4"
if (s_con~=s_prevcon) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your con is now "..s_con)
end
end
s_prevcon=s_con
end
if (s_sb~=s_prevsb) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your breath save is now "..s_sb)
end
end
s_prevsb=s_sb
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatMana: */* | Int: */* | Fire: * | Gold: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_int=tonumber("%3")
s_sf="%5"
if (s_int~=s_prevint) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your intelligence is now "..s_int)
end
end
s_prevint=s_int
end
if (s_sf~=s_prevsf) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your fire save is now "..s_sf)
end
end
s_prevsf=s_sf
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatMove: */* | Wis: */* | Cold: * | Practices: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_wis=tonumber("%3")
s_sc="%5"
if (s_wis~=s_prevwis) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your wisdom is now "..s_wis)
end
end
s_prevwis=s_wis
end
if (s_sc~=s_prevsc) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your cold save is now "..s_sc)
end
end
s_prevsc=s_sc
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatThie: * |*| Normal: * | Weight: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_sn="%3"
if (s_sn~=s_prevsn) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your physical save is now "..s_sn)
end
end
s_prevsn=s_sn
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatWarr: * |*| Magic: * | Encumbrance: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>s_sm="%3"
s_enc="%4"
if (s_sm~=s_prevsm) then
if (jli==0) then
if (gs("autostat")==true) then

Note("Your magic res is now "..s_sm)
end
end
s_prevsm=s_sm
end
if (s_enc~=s_prevenc) then
if (jli==0) then
if (gs("autostat")==true) then

--Note("Your encumbrance is now "..s_enc)
end
end
s_prevenc=s_enc
end</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* tries to disarm *."
 omit_from_output="y"
 sequence="100"
script="t_disarm"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You fail the rescue!"
 omit_from_output="y"
 sequence="100"
send_to="14"
 >
<send>
counters.frescue=counters.frescue+1
PSend("rescue "..res)
Sound(sdir.."grouping/fail res.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* rushes to aid *!"

 sequence="100"
send_to="14"
 >
<send>
Sound(sdir.."combat/special/male/"..math.random(1,mspecial)..".ogg")
bfight("%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You heroically rescue *!"
 omit_from_output="y"
 sequence="100"
send_to="14"
 >
<send>if not gag.combat then Note("You heroically rescue %1!") end
Sound(sdir.."grouping/rescue.ogg")
counters.rescue=counters.rescue+1
</send>
 </trigger>

 <trigger
 enabled="y"
 match="tnpYou have * of the experience you need to level your cheapest class."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^BOSS SPAWNED$"
 regexp="y"
 send_to="12"
 sequence="100"
 >
<send>
Sound(sdir.."puzzlewood/boss_spawned.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="^BOSS DEFEATED$"
regexp="y"
 send_to="12"
 sequence="100"
 >
 <send>
Sound(sdir.."puzzlewood/boss_defeated.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gestures towards you."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/dispel you.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="* gestures towards *."
   omit_from_output="y"
 send_to="14"
 sequence="101"
 >
 <send>
  if (not gag.spells) or (areaname ~= "The Planar Knot observation platform") then
   Note("%1 gestures towards %2.")
  end
 </send>
</trigger>
 <trigger
 enabled="y"
 match="* utters the words, 'dispel magic'"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
  if (not gag.spells) or (areaname ~= "The Planar Knot observation platform") then
   Note("%1 casts 'dispel magic'")
  end
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="(*) * contains:"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("%1 contains:")
EnableGroup("room",0)
DoAfterSpecial(2,'EnableGroup("room",1)',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel the threads of magic about you begin to unravel."
 send_to="14"
omit_from_output="y"
 sequence="100"
 >
 <send>if not gag.spells then Note("You feel the threads of magic about you begin to unravel.") end
Sound(sdir.."spells/dispel yourself.ogg")
</send>
</trigger>

 <trigger
 enabled="y"
 match="You gesture towards *."
 omit_from_output="y"
 send_to="14"
script="sgag"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dispel other.ogg")
if (dispelling==1) then
PSend("c dispel "..dtarget)
dispelled="%1"
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The magic holding * together weakens."
 omit_from_output="y"
 send_to="14"
script="sgag"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dispel weaken.ogg")
</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^knw\s*(.+?)\s*(very bad|very good|bad|poor|fair|average|good|moderate|perfect|exceptional)\s*"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>
sk="%1"
sk=string.gsub(sk, " ", "", 50)
kskills[sk]=1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^zknow.*$"
 omit_from_output="y"
 sequence="300"
regexp="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="knw*"
 omit_from_output="y"
keep_evaluating="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
match="^zknow\s*(.+?)\s*(very bad|very good|bad|poor|fair|average|good|moderate|perfect|exceptional)"
omit_from_output="y"
 regexp="y"
 send_to="14"
keep_evaluating="y"
 sequence="1"
 >
 <send>
sp="%1"
sp=string.gsub(sp, " ", "", 50)
kspells[sp]=1
--print("you know "..sp.." %2")
</send>
 </trigger>
</triggers>

<triggers>

 <trigger
 enabled="y"
 match="zknowYou know the following spells:"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>require "wait"
wait.make(function()
wait.time(2)
if (kspells["soothewounds"]==1) then
spells["heal"]="soothe wounds"
end
if (kspells["bolster"]==1) then
spells["heal"]="bolster"
end
if (kspells["heal"]==1) then
spells["heal"]="heal"
end
if (kspells["majorheal"]==1) then
spells["heal"]="major heal"
end
end)
</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="*'s displaced image abruptly rejoins * body."
 send_to="12"
 sequence="100"
 >
 <send>
spellfall("displace", "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="*'s skin fades from grey stone to normal color."
 send_to="14"
 sequence="100"
 >
 <send>if (kspells["crystalcoat"]==1) then
spellfall("crystalcoat", "%1")
end</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
regexp="y"
 ignore_case="y"
 match="^setway(\s*)(-{0,1}\d+)\s*(->|-)\s*(.*)"
 omit_from_output="y"
script="wayadd"
 sequence="99"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
regexp="y"
 ignore_case="y"
 match="^setway(->\s*)(-{0,1}\d+)\s*(->|-)\s*(.*)"
 omit_from_output="y"
script="wayadd"
 sequence="99"
 >
 <send>
</send>
 </trigger>

 <trigger
 enabled="y"
 keep_evaluating="y"
 match="setway*"
 omit_from_output="y"
 sequence="100"
send_to="12"
 >
<send>
EnableGroup("ways", 1)</send>
 </trigger>
</triggers>
<triggers>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="lvlYou have * of the experience you need to level your cheapest class."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="* beckons for you to follow."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/beckon.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You do not seem to be wearing anything named '$held'."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="You * into your hiding spot."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You %1 into your hiding spot.") end
Sound(sdir.."skills/hide1.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
regexp="y"
 match="^You follow (.*) (\w+)."
group="group"
 omit_from_output="y"
 script="follow"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You throw your own personal rainbow at *, who is momentarily blinded and awestruck by its beauty."
 omit_from_output="y"
 send_to="12"
 sequence="100"
 >
 <send>if not gag.spells then Note("You throw your own personal rainbow at %1, who is momentarily blinded and awestruck by its beauty.") end
Sound(sdir.."spells/colorspray.ogg")
Sound(sdir.."spells/shower of sparks.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You separate a bottle of .* from .+\.$"
 send_to="12"
 sequence="100"
 >
 <send>
Sound(sdir.."brewing/bottle.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You fill a bottle with .* liquid from .*\, creating .*\.$"
 send_to="12"
 sequence="100"
 >
 <send>
Sound(sdir.."brewing/bottle.ogg")</send>
 </trigger>
<trigger
 enabled="y"
 match="You're the first to submit this recipe!"
 send_to="12"
 sequence="100"
 >
 <send>
require "wait"
wait.make(function()
wait.time(2)
Sound(sdir.."brewing/submit first.ogg")
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You fumble and ruin the potion."
 send_to="12"
 sequence="100"
 >
 <send>
require "wait"
wait.make(function()
Sound(sdir.."brewing/fumble.ogg")
wait.time(0.6)
Sound(sdir.."brewing/nasty mess.ogg")
end)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You try to move stealthily, but fail!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You try to move stealthily, but fail!") end
Sound(sdir.."skills/fail stealth.ogg")
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="mzc*"
 omit_from_output="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 group="group"
 match="* tells the group, 'sleep'"
 keep_evaluating="y"
 send_to="14"
 sequence="1"
 >
<send>
if (leader ~= "%1") or (gs("autoregen") == false) then
return
end

if (pose~="sleep") then
PSend("sleep")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 group="group"
 match="* tells the group, 'regen'"
 keep_evaluating="y"
 send_to="14"
 sequence="1"
 >
<send>
if (leader~="%1") or (gs("autoregen") == false) then
return
end

if (pose~="sleep") then
PSend("sleep")
end
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* appears out of a flickering blue glow."
 sequence="100"
send_to="14"
 >
 <send>Sound(sdir.."movement/glow-appear.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* appears in the middle of the room."
 sequence="100"
send_to="14"
 >
 <send>Sound(sdir.."movement/glow-appear.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* vanishes into a flickering red glow."
 sequence="100"
send_to="14"
 >
 <send>Sound(sdir.."movement/glow vanish.ogg")</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 group="group"
 match="You will now try to protect * in battle."
send_to="14"
 sequence="1"
 >
<send>
PSend("sub I will now try to protect %1 in battle.")
</send>
</trigger>
 <trigger
 enabled="y"
 group="group"
 match="* tells the group, 'look *'"
 keep_evaluating="y"
send_to="14"
 sequence="1"
 >
 <send>
if (gs("automove")==true) then
if ("%1"==leader) then
Send("look at %2")
end
end
</send>
 </trigger>

 <trigger
 enabled="y"
send_to="14"
 match="* begins * climb *ward*"
 sequence="1"
 >
 <send>
if (gs("automove")==true) then
if ("%1"==leader) then
Send("climb %3")
end
end
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* goes to sleep."
send_to="14"
 sequence="100"
 >
 <send>
if (gs("autosleep")==true) then
if (grouped==1) then
string="%1"
if (leader~="%1") then
return
end --if not leader
if(pose~="sleep") then
PSend("sleep")
end --pose
end --group
end --auto sleep
</send>
 </trigger>
</triggers>

<triggers>
 <trigger
 enabled="y"
 match="You are not yet advanced enough in your training."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (grouped==0) then
Note("You are not yet advanced enough in your training.")
return
else
if (spells["heal"]==nil) then
else
PSend("c "..spells["heal"].." "..gname)
casting=spells["heal"].." %2"
end
end</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* has left the group."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."grouping/leave group.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* has been kicked out of the group!"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."grouping/leave group.ogg")</send>
 </trigger>

</triggers>
<triggers>
 <trigger
 enabled="y"
 match="(you can set this channel with the 'friend on' and 'friend off' commands)"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
match="^heal\[(.*?)\s*Lvl\s*(-{0,1}\d+).*hp\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mn\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mv\s*(-{0,1}\d+)\/(-{0,1}\d+) .*$"
 omit_from_output="y"
script="healer"
 regexp="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
match="^heal(.*?)\s*Lvl\s*(-{0,1}\d+).*hp\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mn\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mv\s*(-{0,1}\d+)\/(-{0,1}\d+) .*$"
 omit_from_output="y"
 regexp="y"
 sequence="101"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You sense the death of your comrade *!"
 send_to="14"
 sequence="100"
 >
 <send>
local minionDeath=false
for i,v in pairs(kxwt_players) do -- search for player names.
if (i=="%1") then -- Only display death of players
Sound(sdir.."grouping/sense death.ogg")
Execute("history_add all=You sense the death of %1!")
Execute("history_add group=You sense the death of %1!")
else -- Death of minions
minionDeath=true
end
end
-- Now filter minions and play sounds for them:
if (not gag.minions and minionDeath==true) then
Sound(sdir.."grouping/sense death.ogg")
Execute("history_add all=You sense the death of %1!")
Execute("history_add group=You sense the death of %1!")
end
minionDeath=nil
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(\w+) is rescued from the brink of death(.*)$"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."notifications/brinkofdeath.ogg")
Execute("history_add all=%1 is rescued from the brink of death%2")
Execute("history_add group=%1 is rescued from the brink of death%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* is now a member of the group."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."grouping/new member.ogg")
Execute("history_add group=%1 is now a member of the group.")
Execute("history_add all=%1 is now a member of the group.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The group is now open to new members."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/open.ogg")
Execute("history_add group=the group is now open to members")
Execute("history_add all=the group is now open to members")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* has summoned you into * group!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/groupsum.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The group is now closed/noshow to new members."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/noshow.ogg")
Execute("history_add group=the group is now closed to members")
Execute("history_add all=the group is now closed to members")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="^groupm\[(.*?)\s*Lvl\s*(-{0,1}\d+)\s*(.*)\s*hp\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mn\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mv\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*(.*)"
 omit_from_output="y"
 regexp="y"
script="monitor"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^groupm(.*?)\s*Lvl\s*(-{0,1}\d+)\s*(.*)\s*hp\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mn\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*mv\s*(-{0,1}\d+)\/(-{0,1}\d+)\s*(.*)"
 omit_from_output="y"
 regexp="y"
script="monitor"
 sequence="101"
 >
 </trigger>
 <trigger
 enabled="y"
 match="groupmMembers of your group:"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>group={}
require "wait"
wait.make(function()
wait.time(1.2)
--PSend("gt now watching "..#group.." members: "..table.concat(group, ", "))
end)</send>
 </trigger>
 <trigger
 enabled="y"
 match="healMembers of your group:"
 omit_from_output="y"
 sequence="100"
 >
</trigger>

 <trigger
 enabled="y"
 match="tankonYou don't know enough about tanking to do that."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>notank=1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You rush forward to * *!"
 send_to="14"
 sequence="100"
 >
 <send>
restime=1
Sound(sdir.."skills/%1.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your friends channel is currently turned ON."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="tankoffYou will no longer behave like a tank."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>tank off.</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankoffYou will no longer fight defensively in melee combat."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>Defensive off</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankoffYou will now attempt to tank in any groups you are in."
 omit_from_output="y"
 sequence="100"
 >
 <send>tank | prefix tankoff</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankoffYou will now fight defensively in melee combat."
 omit_from_output="y"
 sequence="100"
 >
 <send>def | prefix tankoff</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankonYou will no longer behave like a tank."
 omit_from_output="y"
 sequence="100"
 >
 <send>tank | prefix tankon</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankonYou will no longer fight defensively in melee combat."
 omit_from_output="y"
 sequence="100"
 >
 <send>def | prefix tankon</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankonYou will now attempt to tank in any groups you are in."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>Tank on.</send>
 </trigger>
 <trigger
 enabled="y"
 match="tankonYou will now fight defensively in melee combat."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>Defensive on.</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="* turns to attack you!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.combat then Note("%1 turns to attack you!") end
Sound(sdir.."skills/taunt/taunted2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You taunt *, and * attacks you!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("You taunt %1, and %2 attacks you!") end
Sound(sdir.."skills/taunt/taunted.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You attempt to goad * into attacking you."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("You attempt to goad %1 into attacking you.") end
Sound(sdir.."skills/taunt/fail.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You shout a challenge to everyone nearby."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("You shout a challenge to everyone nearby.") end
Sound(sdir.."skills/taunt/area.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You get * gold coins."
 send_to="14"
 sequence="99"
 >
 <send>Sound(sdir.."items/get gold container.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gives you * gold coins."
 send_to="14"
 sequence="99"
 >
 <send>Sound(sdir.."items/get gold container.ogg")
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="^You get (\d+) gold coins from (.+)."
 send_to="14"
regexp="y"
 sequence="98"
 >
 <send>Sound(sdir.."items/get gold container.ogg")
gg=tonumber(%1)
counters.steal=counters.steal+gg
</send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="invcheckYou are carrying:"
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 match="invcheck*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(inv, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="invcheckNothing."
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 </trigger>

 <trigger
 enabled="y"
 match="invcheck*a magical lantern (light)"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>table.insert(inv, "the lantern")</send>
 </trigger>

</triggers>

<triggers>
 <trigger
 enabled="y"
 match="invcheck*abort*"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send >
 if (#inv&lt; 1) then
Note("You aren't carrying anything.")
else
Note("You are carrying the following "..#inv.." items:")
if (#inv>1) then
count=#inv-1
Note(table.concat(inv, ", ", 1, count)..", and "..inv[#inv]..".")
else
Note(table.concat(inv, ", "))
end
end
inv={}</send>
 </trigger>

 <trigger
 enabled="y"
 match="^\*abort\*$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/abort.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\*stop\*$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/abort.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\*interrupt\*$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/abort.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="^            Welcome to Alter Aeon!$"
 regexp="y"
 send_to="12"
 sequence="100"
 >
 <send>ppi.stop(0)
Sound(sdir.."notifications/welcome back.ogg")
Execute("tts_stop")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 8)A leaf and stick hut is floating here."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 group="fishing"
 match="You reel in a*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You reel in a%1") end
if gs("donfish")==true then
PSend("don fish")
end
Sound(sdir.."misc/fishcatch.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlCleric\s*\w++\:\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>cleric=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your coat of crystal scales suddenly shatters in a chain reaction!"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/stoneskin off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You notice that the foul taste in your mouth seems to be gone."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/foulblood off.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="The air smells cleaner, and you realize your rancid flesh spell has expired."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/rancid flesh off.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="You find yourself no longer able to sense encroaching death."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."necromancer/dread portent off.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="You feel the pent up vengeance in your blood dissipate."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dying breath off.ogg")
</send>
</trigger>

 <trigger
 group="fishing"
 match="You reel in your line and recast it."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You reel in your line and recast it.") end
Sound(sdir.."misc/fishcast.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlMage\s*\w++\:\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>mage=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are quickly covered in a coat of crystal scales!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You are quickly covered in a coat of crystal scales!") end
Sound(sdir.."spells/stone skin.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="You * a * fireball at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You %1 a %2 fireball at %3"
) end
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/fireball.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 match="(auction) Auction failed, item returned to seller."
enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/item sold.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You reply to *, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You reply to %1, %2")
if (gs("chist") == true) then
Execute("history_add tells=You reply to %1, %2")
Execute("history_add all=You reply to %1, %2")
end
  if gs("comlog")==true and gs("comlogtells")==true then
    local rpmsg
    rpmsg="You reply to %1, %2"
    AppendToNotepad("comlog", rpmsg.. "\\r\\n")
end --comlog
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your storage locker expires in * days."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You add * to your group."
 send_to="14"
 sequence="100"
 >
 <send>
if minion then
minion=false
Sound(sdir.."grouping/minion joins.ogg")
else
if not has_minion_sound then
Sound(sdir.."grouping/you add someone.ogg")
else
has_minion_sound = nil
end
if (grouped==0) then
if gs("automark") == 2 then
  if exm.status == nil and leader == settings.me.status then -- if user isn't already marking and user is the group leader
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 3 then
  if exm.status == nil and leader ~= settings.me.status then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 4 then
  if exm.status == nil then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
end -- automark is enabled
end
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* has become a member of the group."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/new member.ogg")
</send>
 </trigger>

 <trigger
 match="(auction) Current bid is * gold coins for *"
enabled="y"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="(?:^zchnInfo:(\w+)(?:\s*|\s+(\(turned off\))(?:\s+|$))(?:$|(\(private\)$|\(password\)$))|^zchnInfo:.*$)"
ignore_case="y"
regexp="y"
 omit_from_output="y"
script="zchnInfoParse"
 send_to="14"
 sequence="1"
 >
</trigger>
 <trigger
 enabled="y"
 match="^zchn\:\[([a-zA-Z]+)\] ([a-zA-Z ]+)\: (.+)$"
regexp="y"
   ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
handlechannel("%2", "%1", "%3", "brackets", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^zchn\:\(([a-zA-Z]+)\) ([a-zA-Z ]+)\: (.+)$"
regexp="y"
   ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
handlechannel("%2", "%1", "%3", "parenthesis", TriggerStyleRuns)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="^Dice: .+$"
 omit_from_output="n"
   regexp="y"
 send_to="14"
 sequence="1"
 >
 <send>
if (gs("groupdice")==1) then return 0 end

if (gs("groupdice")==2) then
Execute("history_add group=%0")
return 0
end

if (gs("groupdice")==3) then
Execute("history_add all=%0")
Execute("history_add group=%0")
return 0
end
</send>
</trigger>
 <trigger
 enabled="y"
 match="^zchn\:(.+) ([a-zA-Z ]+)s\, \'(.+)\'$"
 ignore_case="y"
 omit_from_output="y"
   regexp="y"
 send_to="14"
 sequence="1"
 >
 <send>
handlechannel("%1", "%2", "%3", "verb", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^zchn\:([^\[\]\(\)]+) ([a-zA-Z ]+)s\: (.+)$"
 ignore_case="y"
 omit_from_output="y"
   regexp="y"
 send_to="14"
 sequence="2"
 >
 <send>
handlechannel("%1", "%2", "%3", "verb", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 match="(auction) First call for '*', at * gold coins."
enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/auction bell1.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="[MA CL TH WA NC]*"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 match="(auction) Last call for '*', at * gold coins."
enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/auction bell3.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You stealthily move into position..."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("You stealthily move into position...") end
Sound(sdir.."skills/thief/backstab1.ogg")
EnableGroup("stab", 1)</send>
 </trigger>
 <trigger
 match="(auction) Now accepting bids for *, minimum bid is *"
enabled="y"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You still have enough experience to level!"
 omit_from_output="n"
 sequence="100"
 >
 </trigger>
 <trigger
 match="You fail to cast the spell*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
enabled="y"
 >
 <send>if not gag.spells then Note("You fail to cast the spell%1") end
Sound(sdir.."spells/fail/"..math.random(1,fspell)..".ogg")
if reclayed==true then reclayed=false end
if(nfight==1) then
return
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You fail to pick the lock."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You fail to pick the lock.") end
Sound(sdir.."doors/fail pick2.ogg")
if (gs("autopick") == true) then
Execute("pick " .. pick)
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your * increases*"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You stop using *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You stop using %1.") end
checkstats()
Sound(sdir.."combat/unwield.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="mzscrNotify channel on."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>notify on.</send>
 </trigger>
 <trigger
 enabled="y"
 match="* calls upon * to bring peace to this place."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/peace.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You feel a light touch, *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You feel a light touch, %1") end
Sound(sdir.."spells/chill touch.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* looks about dazedly, but is whole once again."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/res1.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="The white aura around * fades."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sancoff.ogg")
if (dispelling==1) and (dispelled=="%1") then
dispelling=0
dispelled=0
PSend("gt dispelling accomplished.")
PSend("brag gt mana")
end
spellfall("sanctuary", "%1")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscrThe size of the things will be implied."
 omit_from_output="y"
 sequence="100"
 >
 <send>autosize | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel a slight tingle and you feel somehow abandoned."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/bless off.ogg")
if (grouped==1) and (gs("swarn") == true) then
PSend("sub bless out.")
end
checkstats()
</send>
 </trigger>
 <trigger
 group="combat"
 match="* parries your attack."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.combat then Note("%1 parries your attack.") end
ppi.play(sdir.."combat/parry/" ..math.random(1, tparry).. ".ogg",0,50)
counters.parryc=counters.parryc+1
</send>
 </trigger>
 <trigger
 enabled="n"
 match="There is no more meat left *"
 sequence="100"
 >
 <send>sacrifice ?corpse
stand</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscrWeapon: *, damage type *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>EnableGroup("stats", 0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel as though * is watching over you."
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/bless.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="* pokes you in the ribs."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."socials/poke.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Time of last access/finger: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="stab"
 match="* quickly avoids your backstab."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%1 quickly avoids your backstab.") end
Sound(sdir.."skills/backstab/avoided.ogg")
EnableGroup("stab", 0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="* quickly avoids *'s backstab."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/avoided.ogg")
bfight("%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="Time of last save: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will automatically unhide now."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>auto unhide configured.</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_event.*?(microlevel|level) (\d+) (\w+)"
omit_from_output="y"
 send_to="14"
regexp="y"
script="k_level"
 sequence="100"
 >
 <send></send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_event quest *"
omit_from_output="y"
 send_to="14"
regexp="y"
 sequence="100"
 >
 <send>
Sound(sdir.."notifications/quest complete.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You gain a practice!"
 send_to="14"
 sequence="100"
 >
 <send>
PSend("show practices|prefix practiceTbl:")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="To gain a level, you can use the 'level' command."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* recognizes you as a murderer!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/recognized murderer.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlThief\s*\w++\:\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>thief=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="(*) * contains:"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("%1 contains:")
EnableGroup("room",0)
DoAfterSpecial(2,'EnableGroup("room",1)',12)
</send>
 </trigger>
 <trigger
 group="combat"
 match="You run away from the battle like a yellow bellied coward!!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
world.Execute ("tts_stop")
else
Note("You run away from the battle like a yellow bellied coward!!")
end
counters.flee=counters.flee+1
Sound(sdir.."combat/flee2.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlWarrior\s*\w++\:\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="99"
 >
 <send>warrior=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are coated by a thin film of electrically conductive magic."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You are coated by a thin film of electrically conductive magic.") end
Sound(sdir.."spells/ground on.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are protected from ice by a magical layer of fire."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You are protected from ice by a magical layer of fire.") end
Sound(sdir.."spells/fireshield on.ogg")
checkstats()
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You are protected from fire by a magical film of ice."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You are protected from fire by a magical film of ice.") end
Sound(sdir.."spells/iceshield on.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 match="You scramble to retrieve *!"
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="1"
 >
 <send>if not gag.combat then Note("You scramble to retrieve %1!") end
Sound(sdir.."combat/scramble disarmed.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(very bad)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>table.insert(vbad, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="[MA CL TH WA] Kills Rank Name"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You are drowning!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/drown2.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="You scramble to retrieve your weapon..."
 omit_from_output="y"
 sequence="90"
 >
 </trigger>
 <trigger
 enabled="y"
 match="zchn:[arena] * killed by * in arena *"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("arena %1 died to %2.")
play("channels/arenadeath",0)
if (gs("logpk")==true) then
Execute("history_add arena=%1 died to %2.")
Execute("history_add all=%1 died to %2.")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="zchn:[arena] (player) * killed by * while in room [*] *"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("pk %1 died to %2 in %4.")
play("channels/pkdeath",0)
if (gs("logpk")==true) then
Execute("history_add arena=%1 died to %2 in %4.")
Execute("history_add all=%1 died to %2 in %4.")
end
</send>
 </trigger>

 <trigger
 match="(auction) Second call for '*', at * gold coins."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/auction bell2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You see a glowing light, suspended in mid air."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "invis")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(\w+) drops *$"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."items/drop/" .. math.random(1,drops)..".ogg")</send>
 </trigger>
 <trigger
 match="(auction) Starting bid on * at * gold."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("New auction: %1, %2 gold.")
Execute("history_add auction=new: %1 for %2 gold")
Sound(sdir.."auction/start auction.ogg")
</send>
 </trigger>
 <trigger
 match="(auction) The item of interest appears to have vanished. Terminating auction."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/item sold.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You struggle desparately for air to breathe!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/drown1.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
script="fighting"
 keep_evaluating="y"
 match="^kxft(.*)"
omit_from_output="y"
 regexp="y"
 sequence="2"
 >
 </trigger>


 <trigger
 match="(auction) This item is being sold by *"
 omit_from_output="y"
enabled="y"
 send_to="2"
 sequence="100"
 >
 <send>sold by %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You struggle for air but find none!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/drown1.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="(notify) *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channels/notify.ogg")
Execute("history_add all=notify %1")
Execute("history_add misc=notify %1")
</send>
 </trigger>
 <trigger
 group="frostbite"
 match="You struggle with the spell, and the line of frost zips randomly across the*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You struggle with the spell, and the line of frost zips randomly across the%1") end
Sound(sdir.."spells/frost4.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel less protected from evil."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/pfe off.ogg")
</send>

 </trigger>
 <trigger
 enabled="y"
 match="You tell *, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You tell %1, %2")
if (gs("chist") == true) then
Execute("history_add tells=You tell %1, %2")
Execute("history_add all=You tell %1, %2")
end
  if gs("comlog")==true and gs("comlogtells")==true then
    local tlmsg
    tlmsg="You tell %1, %2"
    AppendToNotepad("comlog", tlmsg.. "\\r\\n")
end --comlog
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Cl Tot Pr uL]"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You feel less protected."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/armor off.ogg")
if (grouped==1) and (gs("swarn") == true) then
PSend("sub armor out.")
end
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You think you got a nibble, but you aren't sure..."
 omit_from_output="y"
 sequence="100"
send_to="14"
 >
<send>if not gag.misc then Note("You think you got a nibble, but you aren't sure...") end</send>
 </trigger>
 <trigger
 enabled="y"
 match="Class Current Cost to level"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will no longer automatically split gold with group members."
 omit_from_output="y"
 sequence="100"
 >
 <send>autosplit | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel less tired."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You feel less tired.") end
Sound(sdir.."spells/refresh self.ogg")
announce_move=true
if (map==1) then
AppendToNotepad("map", "c refresh;")

end
mvalarm=0</send>
 </trigger>
 <trigger
 enabled="y"
 match="Combat tactics:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will not see any extra size info about characters."
 omit_from_output="y"
 sequence="100"
 >
 <send>autosize | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel righteous."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.spells then Note("You feel righteous.") end
Sound(sdir.."spells/pfe.ogg")</send>
 </trigger>
 <trigger
group="telltriggers"
enabled="y"
 match="* replies to you, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 replies, %2")
Execute("history_add tells=%1 replied, %2")
Execute("history_add all=%1 replied, %2")
Sound(sdir.."channels/reply.ogg")
if gs("comlog")==true and gs("comlogtells")==true then
  local rpmsg
  rpmsg="%1 replied, %2"
  AppendToNotepad("comlog", rpmsg.. "\\r\\n")
end --comlog
</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 0)A ball of light hovers peacefully here."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will not see any extra size info about characters."
 omit_from_output="y"
 sequence="100"
 >
 <send>autosi | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel * protecting you."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.spells then Note("You feel %1 protecting you.") end
Sound(sdir.."spells/armor on.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your skin flashes a dark amber color, and you feel a powerful curse ward protecting you."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.spells then Note("Your skin flashes a dark amber color, and you feel a powerful curse ward protecting you.") end
Sound(sdir.."spells/curse ward on.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="The scent of something rotten fills your nose."
 omit_from_output="y"
 send_to="14"
 sequence="100"
script="sgag"
 >
 <send>
Sound(sdir.."spells/rancid on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel sick to your stomach and a foul taste fills your mouth."
 omit_from_output="y"
 send_to="14"
 sequence="100"
script="sgag"
 >
 <send>
Sound(sdir.."spells/foulblood on.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="Things take on a ghostly red hue."
 omit_from_output="y"
script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/infra on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your eyes tingle."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dinvis on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You chant while moving your hands in a circular pattern parallel to the ground."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* begins chanting and moving * hands in circular patterns above the ground."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="A floating blue-tinted disc slowly solidifies and hovers before you."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>ppi.play(sdir.."spells/tensor.ogg",0,0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="A clear blue-tinted disc of energy solidifies and hovers in the air before *."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Tensor's floating disc abruptly winks out of existence. (carried by you)"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/tensor pop.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You feel more aware of your surroundings."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/sl on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* restored you to full health!"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=%1 restored you to full health.")
Execute("history_add misc=%1 restored you to full health.")
Sound(sdir.."misc/god restore.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The pantheon of gods restores you to full health!"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=The pantheon of gods restored you to full health.")
Execute("history_add misc=The pantheon of gods restored you to full health.")
Sound(sdir.."misc/god restore.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="This restore brought to you by *!"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=%1 restored you to full health.")
Execute("history_add misc=%1 restored you to full health.")
Sound(sdir.."misc/god restore.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Compared to your current *"
group="compare"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will now automatically split gold with group members."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>autosplit configured.</send>
 </trigger>
 <trigger
 group="combat"
 match="* rushes forward to defend you!"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
world.Execute ("tts_note %1 rushes forward to defend you!")
else
Note("%1 rushes forward to defend you!")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will now see the height/size of the things in front of the ground string."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>size display configured.</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have a few scratches."
script="cngag"

 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/scratches.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
   regexp="y"
 match="^.+ savagely devours (a|an|the) .+ of .+\.$"
 send_to="14"
 sequence="100"
 >
 <send>ppi.play(sdir.."necromancer/consume corpse"..math.random(1,5)..".ogg",0,math.random(-50, 50))</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have been KILLED!!!! *"
 send_to="14"
 sequence="100"
 >
 <send>
rct={}
require "wait"
wait.make(function()
Sound(sdir.."combat/killed.ogg")

wait.time(1.2)
if (gs("playquotes")==true) then
  Sound(sdir.."combat/pkmsgs/" ..math.random(1, pkmsg).. ".ogg")
end
end)
prevhp = 0
prevmn = 0</send>
 </trigger>
 <trigger
 enabled="y"
 match="* says to you, * like you are not welcome here*"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>%1 thinks %2 like you aren't welcome here.</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(very good)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>table.insert(vgood, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 0)A number of large, melting icy spikes jut up from the ground."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(poor)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(poor, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You sense something different about *..."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."items/random.ogg")
table.insert(uniques,"%1")
Execute("history_add misc=%1 randomed!")
Execute("history_add all=%1 randomed!")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have big nasty wounds and scratches."
script="cngag"

 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/big nasty.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are in an awful condition!"
script="cngag"

 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/awful.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="(21)A mound of sand has a hole dug into it."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You sit down and rest your tired bones."
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (gfighting==0) then
fight = 0
fc = 0
Sound(sdir.."misc/uncrouch.ogg")
 fc = 0
end
Sound(sdir.."misc/rest.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^You have lost (-?\d+) experience.$"
 regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
<send>Note("You have lost "..ntrunk(tonumber("%1")).." experience.")</send>
</trigger>

 <trigger
 enabled="y"
 match="^You have spent (-?\d+) experience.$"
 regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
<send>Note("You have spent "..ntrunk(tonumber("%1")).." experience.")</send>
</trigger>

 <trigger
 enabled="y"
 match="^You have lost (-{0,1}\d+) experience points so far due to deaths\.$"
 regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You have lost "..ntrunk("%1").." experience so far due to deaths.")
</send>
 </trigger>
<trigger
enabled="y"
match="^You weep as you think of the (\d+) experience that you lost.$"
regexp="y"
 omit_from_output="n"
 send_to="14"
 sequence="100"
>
<send>
expInfo.death=tonumber("%1")
if (exm.status==true) then
hExpMarkHandle(nil,true,"death")
end
</send>
</trigger>

 <trigger
 enabled="y"
 match="You are in excellent condition."
 omit_from_output="y"
script="cngag"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/excellent.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="skl*user abort*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
EnableGroup("ranks", 0)
if (#vbad~=0) then
Note("Very bad ("..#vbad.." skills/spells):")
Note(table.concat(vbad, ", "))
Note("----------")
vbad={}
end
if (#bad~=0) then
Note("Bad ("..#bad.." skills/spells):")
Note(table.concat(bad, ", "))
Note("----------")
bad={}
end
if (#poor~=0) then
Note("Poor ("..#poor.." skills/spells):")
Note(table.concat(poor, ", "))
Note("----------")
poor={}
end
if (#fair~=0) then
Note("Fair ("..#fair.." skills/spells):")
Note(table.concat(fair, ", "))
Note("----------")
fair={}
end
if (#moderate~=0) then
Note("Moderate ("..#moderate.." skills/spells):")
Note(table.concat(moderate, ", "))
Note("----------")
moderate={}
end
if (#avg~=0) then
Note("Average ("..#avg.." skills/spells):")
Note(table.concat(avg, ", "))
Note("----------")
avg={}
end
if (#good~=0) then
Note("Good ("..#good.." skills/spells):")
Note(table.concat(good, ", "))
Note("----------")
good={}
end
if (#vgood~=0) then
Note("Very good ("..#vgood.." skills/spells):")
Note(table.concat(vgood, ", "))
Note("----------")
vgood={}
end
if (#exceptional~=0) then
Note("Exceptional ("..#exceptional.." skills/spells):")
Note(table.concat(exceptional, ", "))
Note("----------")
exceptional={}
end
if (#perfect~=0) then
Note("Perfect ("..#perfect.." skills/spells):")
Note(table.concat(perfect, ", "))
perfect={}
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You slow down and feel really burned out."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/haste off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have * gold coins."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>goldhand="%1"</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have one gold coin."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>goldhand=1</send>
 </trigger>

 <trigger
 enabled="y"
 match="You have no gold."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>goldhand=0</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have * gold coins in the bank."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>goldbank=tonumber("%1")
if(goldbank>0) then
if(bwithdraw==1) then
PSend("bank withdraw "..goldbank)
bwithdraw=0
return
end
end
bwithdraw=0
if(goldhand==0) then
if(goldbank==0) then
Note("You have no gold at all.")
else
Note("You have no gold in hand and "..goldbank.." in bank")
end
else
if(goldbank==0) then
Note("You have "..goldhand.." in hand and nothing in the bank.")
else
Note("You have "..goldhand.." in hand and "..goldbank.." in the bank.")
end
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have no gold in the bank."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>goldbank=0
if(goldhand==0) then
if(goldbank==0) then
Note("You have no gold at all.")
else
Note("You have no gold in hand and "..goldbank.." in bank")
end
else
if(goldbank==0) then
Note("You have "..goldhand.." in hand and nothing in the bank.")
else
Note("You have "..goldhand.." in hand and "..goldbank.." in the bank.")
end
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You are mortally wounded, and will die soon if not aided."
script="cngag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/8.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="sklYou know the following *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>EnableGroup("ranks", 1)</send>
 </trigger>
 <trigger
 enabled="y"
 match="You slowly fade into existence."
 send_to="14"
 sequence="100"
 >
 <send>
if (grouped==1) and (gs("swarn") == true) then
PSend("warn invis out!")
end
Sound(sdir.."spells/invis off.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="^kxwt_supported$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="1"
 >
<send>
  ppi.unload()
  ppi.init()
  startup_clear_working_vars()
  soundfile_init()
  resetvol()

  jli=1
  DoAfterSpecial(12, 'jli=0', 12)
  SendNoEcho("/show |prefix getContext:") -- Check for current context first instead of calling login.
</send>
</trigger>

 <trigger
 enabled="y"
 match="^Logging in character \'(\w+)\'"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (gs("tts") == true) then
world.Execute ("tts_interrupt Logging in %1.")
else
Note("Logging in %1.")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_myname (\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
script="postInit"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You are no longer fishing."
 send_to="14"
 sequence="100"
 >
 <send>EnableGroup("fishing", 0)</send>
 </trigger>
 <trigger
 enabled="y"
 match="* accuses you of being a thief!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("%1 thinks you are a thief!")
Sound(sdir.."misc/recognized thief.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
match="You slowly fade out of existence."
 omit_from_output="y"
script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/invis.ogg")</send>
 </trigger>
 <trigger
 enabled="n"
 match="^You (\w+)\: (.*?)$"
 ignore_case="y"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
-- I'm almost sure this trigger doesn't get used anymore, since we use the ZCHN prefix...
-- But i'll set it up to use handlechannel in case it ever does get used
handlechannel(gs("me"), "%1", "%2", "youverbcolen", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are now a group member."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/you join.ogg")
-- help note disabled to discourage general use
-- Note("Note: To learn to use the group bots, use the '!help' command.")
if gs("automark") == 2 then
  if exm.status == nil and leader == settings.me.status then -- if user isn't already marking and user is the group leader
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 3 then
  if exm.status == nil and leader ~= settings.me.status then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 4 then
  if exm.status == nil then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
end -- automark is enabled
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You throw dirt in *'s face, blinding *!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/blind on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* appears to be blinded!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/blind on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^You need (\w+) experience to train a practice\, and you have (\w+)\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>exp=%2
toprac=%1
Note("You still need "..toprac-exp.." experience to train a practice. It costs "..toprac..".")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You thought you had something, but you were mistaken."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/pickpocket/nothing2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You try, but the blood fever remains just out of your reach!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk no.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="* attracts your attention, fresh meat! KILLLLLLLL!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk another target.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You throw a large ball of pent-up * electricity at *."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
Sound(sdir.."spells/ball lightning.ogg")
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Turning on channel *"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."channels/on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Turning off channel *"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."channels/off.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You throw caution to the wind *"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel stronger."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/strength on.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your muscles deflate as your strength spell wears out."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/strength off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A sense for evil manifests itself as red in your vision."
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You no longer sense the presence of evil."
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel the last of your curse ward come down."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/curse ward off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You sense the strange presence of undead creatures in the distance."
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You become unable to sense the presence of undead creatures."
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 group="combat"
 match="You trip *, sending * sprawling to the ground!"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
play_trip_sound_delayed(50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You find nothing of value."
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."mining/find nothing.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A small rockslide pelts you with falling debris!"
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."mining/find nothing.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You try to disarm *, but fail."
 omit_from_output="y"
script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/you fail to disarm.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* deflects your pitiful attempt to disarm *."
 omit_from_output="y"
script="cgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/you fail to disarm.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Death exp offset: 1000"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzscrYou will now stay hidden when using most commands."
 omit_from_output="y"
 sequence="100"
 >
 <send>autounhide | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="You fire an arrow, *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You flee from combat!!"
script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
world.Execute ("tts_stop")
else
Note("You flee from combat!")
end
counters.flee=counters.flee+1
Sound(sdir.."combat/flee2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* whispers to you, '*'"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add say=%1 whispered, %2")
Execute("history_add all=%1 whispered, %2")
Sound(sdir.."channels/whisper.ogg")
Note("%1 whispers, %2")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gives you *"
 send_to="14"
 sequence="102"
 >
 <send>
Execute("history_add misc=%1 gave you %2")
Sound(sdir.."items/they give.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gives you a soft nudge."
 send_to="14"
 sequence="101"
 >
 <send>
Sound(sdir.."socials/nudge.ogg")
</send>
</trigger>
 <trigger
 enabled="y"
 match="* throw* head back and cackle* with insane glee."
 send_to="14"
 sequence="1"
 >
 <send>
Sound(sdir.."socials/cackle.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* throw* head back and cackle* with insane glee."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/cackle",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* cough* loudly."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/cough",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* yawns so wide everyone can see his tonsils."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/yawn1",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* yawns so wide everyone can see her tonsils."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/yawn2",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* pukes all over the place."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/puke",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* snickers softly."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/snicker1",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* sighs somberly."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/sigh1",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* laugh* out loud."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/laugh2",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* grabs *, thrusts it into the air and shouts, *"
 send_to="14"
 sequence="1"
 >
 <send>play("socials/raa",0)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You sigh."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/sigh2",0)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* rolls about the floor laughing."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/rofl",0)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You roll about the floor laughing."
 send_to="14"
 sequence="1"
 >
 <send>play("socials/rofl",0)
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You give * to *"
 send_to="14"
 sequence="1"
 >
 <send>
Sound(sdir.."items/you give.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* says, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add say=%1 says, %2")
Execute("history_add all=%1 says, %2")
Sound(sdir.."channels/say.ogg")
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 says, %2")</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(bad)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(bad, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You gain * exp*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("+"..ntrunk("%1").." xp!")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* screams in pain as * places * in * back."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/7.ogg")
bfight("%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 group="stab"
 match="* screams in pain as you place * in * back."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/7.ogg")
EnableGroup("stab", 0)
Note("screams in pain.")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Everything around you slows down."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/haste on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 0)A pile of gold coins."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."items/coins.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(average)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(avg, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* seems to have dropped *!*"
 omit_from_output="y"
 send_to="14"
 sequence="200"
 >
 <send>
Sound(sdir.."skills/thief/pickpocket item.ogg")
if gag.expert then
Note("You got %2!")
else
Note("%1 seems to have dropped %2!%3")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have quite a few wounds."
script="cngag"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/quite a few.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* sees your attempt to trip * in time to avoid your foot."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/they avoid your trip.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have reached the limits of your abilities."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/out of mana.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* shivers and shakes from the cold."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/chill shiver.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 0)One miserable gold coin."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."items/coin.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="smh*critical*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>knowheal=1</send>
 </trigger>
 <trigger
 enabled="y"
 match="smc*refresh*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>knowref=1</send>
 </trigger>
 <trigger
 enabled="y"
 match="kns*stone*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>knowstone=1</send>
 </trigger>

 <trigger
 enabled="y"
 match="You have some small wounds and bruises."
script="cngag"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/small wounds.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are pretty hurt."
script="cngag"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."condition/"..gs("scheme").."/pretty hurt.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="smhSpells:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

 <trigger
 enabled="y"
 match="smcSpells:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^You have spent +(\d+) experience points so far\.$"
 regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You have spent "..ntrunk("%1").." experience so far.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* utters the words, 'dexterity"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="( *)The corpse of * is lying here."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("the corpse of %2")
Sound(sdir.."steps/corpse/"..math.random(1,scorpse)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* rescues you and takes over the battle!"
 omit_from_output="y"
script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
world.Execute ("tts_note You are rescued by %1!")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are rescued from certain death by *"
 omit_from_output="y"
script="mgag"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
world.Execute ("tts_note You are rescued by %1!")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="smhYou know the following spells:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

 <trigger
 enabled="y"
 match="smcYou know the following spells:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>


 <trigger
 enabled="y"
 match="* utters the words, *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>%1 casts %2</send>
 </trigger>
 <trigger
 enabled="y"
 match="( *)The disfigured corpse of * is lying here."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("%2's corpse")
Sound(sdir.."steps/corpse/"..math.random(1,scorpse)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The distance is too great for this waypoint to bridge the gap."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."misc/waypoint gap.ogg")</send>
 </trigger>
 <trigger
 group="stats"
 match="-------------------+--------------+--------------+-----------------------"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You are surrounded by a strong force shield."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/shield on.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="* avoids your feeble bash, and trips you in the process."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/bashtrip.ogg")
Note("avoid trip.")
play_trip_sound_delayed(-50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="1) Change low level limit [level *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>1 low level limit %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)(\w+) is here, fighting .*\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 fighting")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel power flowing into your body!"
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/restoration.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are surrounded by a white aura."
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sanc on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* avoids your feeble bash, and you fall flat on your face."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/bash4.ogg")
Note("avoided.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="2) Change high level limit *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>2 high level limit %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)(\w+) is here, sound asleep\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 sleeping")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Done!  Come back soon!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
  rct={}
  Sound(sdir.."notifications/leave game.ogg")
 </send>
 </trigger>

 <trigger
 enabled="y"
 match="* backs slowly away from you..."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/turn/target.ogg")
Sound(sdir.."skills/turn/repel.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You try to strike up a conversation with *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>You try to talk to %1</send>
 </trigger>

 <trigger
 enabled="y"
 match="( *)A soft Groan is heard from behind a closed door."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "Groan")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( *)Takezo Kensei laughs at you while standing in a pool of his own blood."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "Kensei")</send>
 </trigger>
 <trigger
 enabled="y"
 match="( *)The elusive Samon is here swimming upstream to mate and lay eggs."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "samon")</send>
 </trigger>

 <trigger
 enabled="y"
 match="^\([0-9 ]+\)(\*?)(\w+) is here\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="90"
 >
 <send>table.insert(players, "%2")
if "%1" == "*" then
yup=false
for i,v in ipairs(players) do
--print(k,v)
if string.find(players[i],"%2")~=nil then
yup=true
players[i]=players[i].." invis"
end
end
yup=nil
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* begins to regain * vision."
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/blind off.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You unlock *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/unlock.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* begins to twitch and react with lightning speed to everything around *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You use a small crystal to focus your powers and throw a confusing wash of color and force at *!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/prism.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You use your turning skill to hold the undead at bay..."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/turn/repel.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Fight string: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You gather yourself for the attack..."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/leap1.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You successfully finished a full * attack combo!*"
 omit_from_output="n"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."notifications/battlecombo full.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You got a * attack combo!*"
 omit_from_output="n"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."notifications/battlecombo.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wake up and begin resting."
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
fight = 0
fc = 0
Sound(sdir.."misc/uncrouch.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="For example, 'list *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(exceptional)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(exceptional, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You get *."
 send_to="14"
 sequence="100"
omit_from_output="y"
 >
<send>
require "wait"
wait.make(function()
table.insert(getitems, "%1")
if not (getblock==1) then
Sound(sdir.."items/get item.ogg")
end
getblock=1
getcount=getcount+1
wait.time(0.4)
if (getsay==0) then
getsay=1
for i,v in pairs(getitems) do
if IsInTable(uniques,v)==0 then
if gs("items")~=3 then
length=0
word=""
for w in string.gmatch(v, "%S+") do
if string.len(w)>length then
if IsInTable(banned,w)==0 then
word=w
length=string.len(w)
end
end
end
if gs("items")==1 then
if gs("container")~=nil then
Send("put "..word.." "..gs("container"))
end
elseif gs("items")==2 then
Send("drop "..word)
Send("sac "..word)
elseif gs("items")==4 then
Send("donate "..word)
end --gs items
elseif gs("items")==5 then
Send("storage put "..word)
end
else
if gs("container")~=nil then
Send("put "..v.." "..gs("container"))
end
end
end
if getcount&lt;1 then

elseif getcount==1 then
Note("You get %1.")
elseif getcount>1 then
Note("You get "..getcount.." items: "..table.concat(getitems, ", "))
end
getsay=0
getblock=0
getcount=0
end
getitems={}
uniques={}
end)
</send>
</trigger>
  <trigger
   enabled="y"
   match="You get the feeling *"
   sequence="1"
  >
  </trigger>

 <trigger
 enabled="n"
 match="Ground string: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You go to sleep."
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."misc/sleep.ogg")
</send>
 </trigger>


 <trigger
 enabled="y"
 match="Here lies one very dead, very dumb DentinMud player."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="( 0)Shards and pieces of crystal litter the ground at your feet."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(fair)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(fair, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You got * gold coins."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/thief/steal gold.ogg")
gg=tonumber(%1)
counters.steal=counters.steal+gg
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* shrinks away in fear."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/turn/target.ogg")
Sound(sdir.."skills/turn/repel.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 ignore_case="y"
 match="Huh?"
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/command wrong.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* slips from the shadows."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/thief/slip from shadows.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="Your * annoys *"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
ppi.play(sdir.."combat/armor/"..math.random(1,armor)..".ogg",0,50)
 
</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(good)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(good, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You hit the ground below!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/hit ground.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
group="combat"
 match="* stands up."
 script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="90"
 >
 <send>
Sound(sdir.."combat/stand/"..mg.."/"..math.random(1,stand[mg])..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="[Exits: * ]"
 omit_from_output="y"
 script="exitst"
 sequence="2"
 >
 </trigger>
 <trigger
 enabled="y"
 match="[Exits: * ] [Doors: * ]"
 omit_from_output="y"
 script="exitstd"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="moving[Exits: *]"
 omit_from_output="y"
 script="exitsm"
 sequence="2"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You jump to assist *!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/assist.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Asking * if you can join * group*"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."grouping/ask join.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* would like to join your group*"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=%1 would like to join your group.")
Execute("history_add group=%1 would like to join your group.")
Sound(sdir.."grouping/joining.ogg")</send>
 </trigger>


 <trigger
 enabled="y"
 match="* starts following you."
 send_to="14"
 sequence="100"
 >
 <send>if not minion then
Sound(sdir.."grouping/start following.ogg")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="zchn:You *, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="2"
 >
 <send>
handlechannel(gs("me"), "%1", "%2", "youverb", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You keep a steady eye on *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/target.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="zchn:You *: *"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="2"
 >
 <send>
handlechannel(gs("me"), "%1", "%2", "youverbcolen", TriggerStyleRuns)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You are surrounded with a pink halo."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/faerie fire you.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You knock the legs out from under * and * stumbles to the ground!"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
play_trip_sound_delayed(50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="3) Change required kills to win [currently *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>3 required kills %1</send>
 </trigger>
 <trigger
 group="fishing"
 match="You land *, holy cow it's big!"
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/fishbig.ogg")
if (gs("donfish") == true) then
PSend("donate fish")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="4) Change max players allowed [currently *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>4 max players %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)(\w+) is resting here\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 resting")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You back away from * and get out of combat range."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/stopmelee.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="5) Allow grouping [currently *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>5 allow grouping %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)*(\w+) is here\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1")</send>
 </trigger>
 <trigger
 group="combat"
 match="You bash full tilt into *"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/bash2.ogg",0,50)
theygrunt()
end)
Note("full tilt!")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* but atempt to cast it anyway."
 send_to="14"
 sequence="100"
 >
 <send>casting=""</send>
 </trigger>
 <trigger
 enabled="y"
 match="6) Boot players from arena when killed [currently *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>6 recall players when killed %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)*(\w+) is resting here\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 resting")</send>
 </trigger>
 <trigger
 group="combat"
 match="You bash headfirst into *"
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/bash6.ogg",0,50)
theygrunt()
end)
Note("headfirst.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* catches you with your hands in * pockets!"
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/thief/caught pickpocket.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="7) Allow clan members to kill each other [currently *]"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>7 allow same clan embers to kill each other %1</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)\*(\w+) is here, fighting .*\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 fighting")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* circles at a distance, but does not approach."
script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/turn/target.ogg")
Sound(sdir.."skills/turn/repel.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\( \w+\)\*(\w+) is here, sound asleep\.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(players, "%1 sleeping")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You could kill * quite easily."
script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 group="combat"
 match="* disarms you and sends your weapon flying!"
script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/disarmed.ogg")
</send>
 </trigger>
 <trigger
 match="* disarms * and sends * weapon flying!"
group="group"
 omit_from_output="y"
 send_to="14"
 sequence="101"
 >
 <send>
if (kskills["trip"]==1) then
hitting="trip"
end
if (kskills["bash"]==1) then
hitting="bash"
end
if (kskills["kick"]==1) then
hitting="kick"
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You want to cast the spell where?"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."notifications/command wrong.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You couldn't find it."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."items/can't find item.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* dodges your attack."
script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>counters.theydodge=counters.theydodge+1
if (mg=="male") then
drnd = math.random(1, mdodge)
elseif (mg=="female") then
drnd = math.random(1, fdodge)
elseif (mg=="neuter") then
drnd = math.random(1,mdodge)
end
Sound(sdir.."combat/dodge/"..mg.."/"..drnd .. ".ogg")
</send>
 </trigger>
  <trigger
   enabled="y"
   ignore_case="y"
   group="combat"
   match="^(You block (\w*)\'s attack.|(\w*) blocks your attack.)$"
   regexp="y"
   script="cgag"
 omit_from_output="y"
 send_to="14"
   sequence="100"
  >
  <send>Sound(sdir.."/combat/shieldblock/block" ..math.random(1,2).. ".ogg")</send>
  </trigger>
 <trigger
 enabled="y"
 match="You wear *."
 omit_from_output="y"
 send_to="14"
 sequence="101"
 >
 <send>checkstats()
Sound(sdir.."wear/feet.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * on your * hand."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/ring.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You start using * as a shield."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/shield.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * about your body."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/about_body.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You guide the spell directly toward *"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/frost3.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You create a * crystal spear and send it hurtling *"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/crystal spear.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * around your left wrist."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/wrist2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Inactivity disconnect in two ticks."
 send_to="14"
 sequence="100"
 >
 <send>Execute("afk idle")
Sound(sdir.."misc/inactivity.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You happen to find * gold coins, how fortunate!"
script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>pg=tonumber(%1)
counters.steal=counters.steal+pg
Note(pg .." gold.")
if (pg&lt;=10) then
Sound(sdir.."skills/pickpocket/2.ogg")
end
if (pg&gt;10) and (pg&lt;=50) then
Sound(sdir.."skills/pickpocket/1.ogg")
end
if (pg&gt;50) and (pg&lt;=70) then
Sound(sdir.."skills/pickpocket/6.ogg")
end
if (pg&gt;70) and (pg&lt;=100) then
Sound(sdir.."skills/pickpocket/3.ogg")
end
if (pg&gt;100) and (pg&lt;=150) then
Sound(sdir.."skills/pickpocket/5.ogg")
end
if (pg&gt;150) then
Sound(sdir.."skills/pickpocket/4.ogg")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You create and magically throw bolts of ice at *"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/icebolt.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_audio spell/cause_critical$"
regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/cause crit.ogg",0,50)
theygrunt()
end)
</send>
</trigger>
 <trigger
 enabled="y"
 match="You flick * at *..."
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="Gaping wounds are torn into *'s body!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="A bluish cone of cold streams from your outstretched fingertips to engulf *!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
ppi.play(sdir.."spells/cone.ogg",0,50)
theygrunt()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A bluish cone of cold streams from you to hit *!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
ppi.play(sdir.."spells/cone.ogg",0,50)
theygrunt()
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You wear * around your neck."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/neck.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Item has effects as:"
 omit_from_output="y"
 sequence="100"
 >
<send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have * experience points."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You have "..ntrunk("%1").." experience.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You create and magically throw * shards of crystal at *!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/shards.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Leader Members Levels Leader Rating Type"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>leader members levels rating flags</send>
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(moderate)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(moderate, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="fDate of character creation: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^You have (-?\d+) experience.$"
regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("You have "..ntrunk("%1").." experience.")
</send>
 </trigger>
 <trigger
 enabled="y"
regexp="y"
 match="^(\w+) stops following you."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."grouping/stop following.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* begins to shiver and shake with cold!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/spectral cold.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="An ethereal hand appears and attacks * from behind!"
script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/spectral hand.ogg")</send>
 </trigger>
 <trigger
 enabled="n"
 match="Press &lt;return&gt; or 'cont' to continue, anything else to quit..."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>require "wait"
wait.make(function()
wait.time(0.5);
Send("cont")
end)</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzstatNecr: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzstatDrui: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>

 <trigger
 enabled="y"
 match="^kxwt_gdeath (.*)"
regexp="y"
 send_to="14"
 sequence="100"
omit_from_output="y"
 >
 <send>
if not gag.minions then
Execute("history_add all=someone's %1 minion died!")
Execute("history_add minions=someone's %1 minion died!")
if utils.readdir(sdir.."mdeath/%1.ogg") then
ppi.play(sdir.."mdeath/%1.ogg",0,80)
else
Sound(sdir.."mdeath/grminion.ogg")
end
end
table.insert(kxwts,"minion %1")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_ydeath (.*)"
regexp="y"
 send_to="14"
 sequence="100"
omit_from_output="y"
 >
 <send>
Execute("history_add all=%1 minion died!")
Execute("history_add minions=%1 minion died!")
 if utils.readdir(sdir.."mdeath/%1.ogg") then
Sound(sdir.."mdeath/%1.ogg")
else
Sound(sdir.."mdeath/yourminion.ogg")
end
if IsInTable(toreclay,"%1")==1 then
if gs("reclay")~=nil then
if gs("reclay")==true then
Execute("abort")
DoAfter(0.1,"c clay man")
end --reclay
end --reclay2
else
table.insert(kxwts,"minion %1")
end --minion if
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The world suddenly seems grey and lifeless, with spirits always at the edge of your vision."
 send_to="14"
 sequence="100"
omit_from_output="y"
script="sgag"
 >
 <send>Sound(sdir.."necromancer/dread portent.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You carefully extract one tooth and put it in your bag."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>teeth=teeth+1
if not gag.misc then Note("You carefully extract one of the teeth and put it in your bag.") end
ppi.play(sdir.."necromancer/Get Teeth"..math.random(1,3)..".ogg",0,math.random(-25,25))
if counters.teeth==nil then
counters.teeth=1
else
counters.teeth=counters.teeth+1
end

</send>
 </trigger>
 <trigger
 enabled="y"
 match="You carefully extract one dragon tooth and put it in your bag."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You carefully extract one dragon tooth and put it in your bag.") end
dteeth=dteeth+1
ppi.play(sdir.."necromancer/Get DTeeth"..math.random(1,3)..".ogg",0,math.random(-25,25))</send>
 </trigger>

 <trigger
 enabled="y"
 regexp="y"
 match="^You sacrifice blood from (a|an|the) .+ of (.+), drawing power from it\!$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%0") end
Sound(sdir.."necromancer/blood sac1.ogg")
DoAfterSpecial(0.3,'Sound(sdir.."necromancer/transfer none.ogg")',12)</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You sacrifice blood from (a|an|the) .+ of (.+)\, drawing power from it and transferring it to (.+)\!$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%0") end
Sound(sdir.."necromancer/blood sac1.ogg")
DoAfterSpecial(0.3,'Sound(sdir.."necromancer/transfer other.ogg")',12)</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^(.+) sacrifices blood from (a|an|the) .+ of (.+)\, drawing power from it and transferring it to you\!$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%0") end
Sound(sdir.."necromancer/blood sac2.ogg")
DoAfterSpecial(0.3,'Sound(sdir.."necromancer/transfer you.ogg")',12)</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^(.+) sacrifices blood from (a|an|the) .+ of (.+) and draws the power into (.+)\.$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%0") end
Sound(sdir.."necromancer/blood sac2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^(.+) sacrifices blood from (a|an|the) .+ of (.+)\, drawing power from it\.$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.skills then Note("%0") end
Sound(sdir.."necromancer/blood sac2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You shatter one of the teeth attempting to remove it."
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if not gag.misc then Note("You shatter one of the teeth attempting to remove it.") end
ppi.play(sdir.."necromancer/Break Teeth"..math.random(1,3)..".ogg",0,math.random(-25,25))
if counters.bteeth==nil then
counters.bteeth=1
else
counters.bteeth=counters.bteeth+1
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="No players visible out of * connected (max was *)."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>No visible players.</send>
 </trigger>
 <trigger
 enabled="y"
 match="fFight string: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You have * unread mudmail messag*"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add tells=%0")
Execute("history_add all=%0")
Sound(sdir.."notifications/email.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="(* is trying to get your attention)"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add misc=%1 is trying to get your attention.")
Execute("history_add all=%1 is trying to get your attention.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="(FYI: * has just sent you a*)"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=%1 sent you an email.")
Execute("history_add tells=%1 sent you an email.")
Sound(sdir.."notifications/newemail.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="* suddenly stabs you in the back!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/you are backstabbed.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="No-one in your group is currently in need of healing."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="ranks"
regexp="y"
 match="^skl\s*(.+?)\s+(perfect)\s+.*%$"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>table.insert(perfect, "%1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* tells the clan, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
local clanmsg
if gag.expert then
  clanmsg="%1 clan, %2"
else
  clanmsg="%1 tells the clan, %2"
end
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), clanmsg)
Execute("history_add clan=".. clanmsg)
Execute("history_add all=".. clanmsg)
Sound(sdir.."channels/clan tell.ogg")
if gs("comlog")==true and gs("comlogclan")==true then
  AppendToNotepad("comlog", clanmsg.. "\\r\\n")
end -- comlog
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You tell the clan, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
local clanmsg
if gag.expert then
  clanmsg="You clan, %1"
else
  clanmsg="You tell the clan, %1"
end
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), clanmsg)
if (gs("chist") == true) then
  Execute("history_add clan=".. clanmsg)
  Execute("history_add all=".. clanmsg)
end
Sound(sdir.."channels/clan tell.ogg")
if gs("comlog")==true and gs("comlogclan")==true then
  AppendToNotepad("comlog", clanmsg .."\\r\\n")
end -- comlog
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* broadcasts to the clan, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
local clanbroadcastmsg
if gag.expert then
  clanbroadcastmsg="%1 broadcasts, %2"
else
  clanbroadcastmsg="%1 broadcasts to the clan, %2"
end
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), clanbroadcastmsg)
Execute("history_add clan=".. clanbroadcastmsg)
Execute("history_add all=".. clanbroadcastmsg)
Sound(sdir.."channels/clan broadcast.ogg")
if gs("comlog")==true and gs("comlogclan")==true then
  AppendToNotepad("comlog", clanbroadcastmsg.. "\\r\\n")
end -- comlog
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* tells the elders, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
local claneldermsg
if gag.expert then
  claneldermsg="%1 elders, %2"
else
  claneldermsg="%1 tells the elders, %2"
end
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), claneldermsg)
if(gs("elderBuffer")==true) then
Execute("history_add elders=".. claneldermsg)
else
Execute("history_add tells=".. claneldermsg)
end
Execute("history_add all=".. claneldermsg)
Sound(sdir.."channels/clan elder tell.ogg")
if gs("comlog")==true and gs("comlogclan")==true then
  AppendToNotepad("comlog", claneldermsg.. "\\r\\n")
end -- comlog
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You tell the elders, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="98"
 >
 <send>
local claneldermsg
if gag.expert then
  claneldermsg="You elder, %1"
else
  claneldermsg="You tell the elders, %1"
end
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), claneldermsg)
if (gs("chist") == true) then
if(gs("elderBuffer")==true) then
  Execute("history_add elders=".. claneldermsg)
else
  Execute("history_add tells=".. claneldermsg)
end
  Execute("history_add all=".. claneldermsg)
end
Sound(sdir.."channels/clan elder tell.ogg")
if gs("comlog")==true and gs("comlogclan")==true then
  AppendToNotepad("comlog", claneldermsg .."\\r\\n")
end -- comlog
</send>
 </trigger>

 <trigger
 group="fishing"
 match="You get a bite, but it swims free."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="10"
 >
 <send>Sound(sdir.."misc/fishescape.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="skl*"
 omit_from_output="y"
keep_evaluating="y"
 sequence="1"
 >

 </trigger>

 <trigger
 enabled="y"
 match="You land on your enemy, putting all your weight behind your swing!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/leap2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* tells the group, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 group, %2")
Execute("history_add group=%1 group, %2")
Execute("history_add all=%1 group, %2")
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 tells the group, %2")
Execute("history_add group=%1 tells the group, %2")
Execute("history_add all=%1 tells the group, %2")
end
Sound(sdir.."channels/group.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You tell the group, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You group, %1")
if (gs("chist") == true) then
Execute("history_add group=You group, %1")
Execute("history_add all=You group, %1")
end
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You tell the group, %1")
if (gs("chist") == true) then
Execute("history_add group=You tell the group, %1")
Execute("history_add all=You tell the group, %1")
end
end
Sound(sdir.."channels/group.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* tells the subgroup, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 sub, %2")
Execute("history_add group=%1 sub, %2")
Execute("history_add all=%1 sub, %2")
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 tells the subgroup, %2")
Execute("history_add group=%1 tells the subgroup, %2")
Execute("history_add all=%1 tells the subgroup, %2")
end
Sound(sdir.."channels/subgroup.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You tell the subgroup, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You sub, %1")
if (gs("chist") == true) then
Execute("history_add group=You sub, %1")
Execute("history_add all=You sub, %1")
end
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You tell the subgroup, %1")
if (gs("chist") == true) then
Execute("history_add group=You tell the subgroup, %1")
Execute("history_add all=You tell the subgroup, %1")
end
end
Sound(sdir.."channels/subgroup.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* warns the group, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 warns, %2")
Execute("history_add group=%1 warns, %2")
Execute("history_add all=%1 warns, %2")
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 warns the group, %2")
Execute("history_add group=%1 warns the group, %2")
Execute("history_add all=%1 warns the group, %2")
end
Sound(sdir.."channels/groupwarn.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You warn the group, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if gag.expert then
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You warn, %1")
if (gs("chist") == true) then
Execute("history_add group=You warn, %1")
Execute("history_add all=You warn, %1")
end
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You warn the group, %1")
if (gs("chist") == true) then
Execute("history_add group=You warn the group, %1")
Execute("history_add all=You warn the group, %1")
end
end
Sound(sdir.."channels/groupwarn.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You say, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You say, %1")
Sound(sdir.."channels/say.ogg")
if (gs("chist") == true) then
Execute("history_add say=You say, %1")
Execute("history_add all=You say, %1")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You yell, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You yell, %1")
Sound(sdir.."channels/yell.ogg")
if (gs("chist") == true) then
Execute("history_add channels=You yell, %1")
Execute("history_add all=You yell, %1")
end
</send>
 </trigger>
  <trigger
   enabled="y"
   match="You yell, 'Retreat!  Retreat!'"
   ignore_case="y"
   omit_from_output="y"
   send_to="12"
   sequence="1"
  >
  <send>Execute("tts_stop")</send>
  </trigger>
 <trigger
 enabled="y"
 match="You say to *, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "You say to %1, %2")
Sound(sdir.."channels/say.ogg")
if (gs("chist") == true) then
Execute("history_add say=You say to %1, %2")
--Execute("history_add all=You say to %1, %2")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* says to *, '*'"
 ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 says to %2, %3")
Sound(sdir.."channels/say.ogg")
Execute("history_add say=%1 says to %2, %3")
Execute("history_add all=%1 says to %2, %3")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You whisper to *, '*'"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>Note("You whisper to %1, %2")
Sound(sdir.."channels/whisper.ogg")
if (gs("chist") == true) then
Execute("history_add whisper=You whisper to %1, %2")
Execute("history_add all=You whisper to %1, %2")
end
</send>
 </trigger>
  <trigger
   enabled="y"
   match="^([a-zA-Z]+) is another player\, you can use the \'say\' command to talk directly to (him|her|it)\.$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="* tries to strike up a conversation with you."
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>

 <trigger
 group="fishing"
 match="You get a nibble on the line..."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="10"
 >
 <send>Sound(sdir.."misc/fishlinepull.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You land your roundhouse kick squarely on *"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/kick1.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 match="* tells you, '*'"
group="telltriggers"
 ignore_case="y"
enabled="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if "%1" == "Soul Eater" then
  ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 tells you, %2")
end
if "%1" ~= "Soul Eater" and string.sub("%2",1,5) ~= "nmzta" then
  ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 tells you, %2")
  Sound(sdir.."channels/tell.ogg")
  Execute("history_add tells=%1 tells you, %2")
  Execute("history_add all=%1 tells you, %2")
  if gs("comlog")==true and gs("comlogtells")==true then
    local tlmsg
    tlmsg="%1 tells you, %2"
    AppendToNotepad("comlog", tlmsg.. "\\r\\n")
  end --comlog
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You get a bite, and after a little effort you manage to reel in *"
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="89"
 >
 <send>Sound(sdir.."misc/fishcatch.ogg")
if (gs("donfish") == true) then
PSend("donate fish")
end</send>
 </trigger>
 <trigger
 enabled="y"
 match="You learn from your mistakes, and become more adept at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("More adept at %1")
Execute("history_add learn=More adept at %1")
Execute("history_add all=More adept at %1")
counters.betterats=counters.betterats+1
better_at()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You become better at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>better_at()
counters.betterats=counters.betterats+1
Execute("history_add learn=Better at %1")
Execute("history_add all=Better at %1")
Note("Better at %1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have completed the achievement: *"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."notifications/achievement.ogg")
Execute("history_add misc=You have completed the achievement %1")
Execute("history_add all=You have completed the achievement %1")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You let out a mighty roar as the blood fever takes hold of you!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk on.ogg")
berserk=1</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ball of blue white lightning crackles gleefully as it fries *"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/ball lightning.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* leaping attack misses you*"
 omit_from_output="y"
 send_to="14"
 sequence="98"
 >
 <send>Sound(sdir.."combat/weapon sounds/they miss leap.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You have sudden insight, and become much better at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>better_at()
Execute("history_add learn=Sudden insight into %1")
Execute("history_add all=Sudden insight into %1")
Note("Sudden insight into %1")
counters.betterats=counters.betterats+1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You become much better at *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>better_at()
Execute("history_add learn=Much better at %1")
Execute("history_add all=Much better at %1")
counters.betterats=counters.betterats+1
Note("Much better at %1")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You lose a bit of your knowledge of *"
 send_to="14"
 sequence="100"
 >
 <send>
Execute("history_add all=when you died, you lost knowledge of %1.")
Execute("history_add misc=when you died, you lost knowledge of %1.")
Execute("history_add learn=when you died, you lost knowledge of %1.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A ball of light flies idly in circles around your head."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You begin chanting and cast a powerful spell..."
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="A ball of light forms near * head."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/continual light.ogg")</send>
 </trigger>
<trigger
 enabled="y"
 regexp="y"
 match="^You hold your hands a few inches apart and grow a glowing crystal between them\.$|^.+ holds \w+ hands a few inches apart\, and a brightly glowing crystal grows into existence between them\.$"
 omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
<send>
 Sound(sdir.."spells/crystal light.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^area: (.*?)gold: (\w+)mana: (\w+)max (\w+)cond: (.*?)hit: (\w+)max (\w+)terrain: (.*?)mv\: (\w+)max\: (\w+)dt: (.*?)xp: (.*)$"
 omit_from_log="y"
 omit_from_output="y"
 regexp="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You begin digging at an iron vein..."
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* doesn't appear to be carrying anything of value."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/pickpocket/nothing.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A beautiful web of blazing * fire bursts forth from your hands and hits *, setting * on fire!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
Sound(sdir.."spells/fireweb.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_fighting (-{0,1}\d+) (\w+) (.*)"
 omit_from_log="y"
 omit_from_output="y"
 regexp="y"
 script="fprompt"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="A blazing ring of * fire forms around you as you complete the spell!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
Sound(sdir.."spells/firefield.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlCleric\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>cleric=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * around your right wrist."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/wrist1.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlMage\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>mage=%1</send>
 </trigger>
 <trigger
 match="You cut * from *"
 sequence="100"
 >
 <send>donate meat
donate skin</send>
 </trigger>
 <trigger
 group="combat"
 match="* easily moves out of the way of your poorly placed kick."
 omit_from_output="y"
 script="skgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."kick/kickdodge.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * for protection of your torso."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/on_body.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You detect nothing magical about *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/detect nothing magical.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* gets in a good hit as * quickly gets out of your way."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/bash5.ogg")
Note("gets in a good hit.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * on your arms."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/arms.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="fGround string: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You dig for a while and find a block of stone."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."mining/find stone.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your pickaxe breaks."
 send_to="14"
group="mining"
 sequence="100"
 >
 <send>
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You wear * on your hands."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/hands.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You dig for a while and find a lump of clay."
 send_to="14"
 sequence="100"
group="mining"
 >
 <send>
Sound(sdir.."mining/find clay.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* heroically jumps to the aid of *"
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("%1 assists %2")
bfight("%2")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * on your head."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/head.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Overall difficulty: *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>it's a %1.</send>
 </trigger>
 <trigger
 enabled="y"
 match="You dig for a while and find a pile of iron ore."
 send_to="14"
 sequence="100"
group="mining"
 >
 <send>
Sound(sdir.."MINING/find iron.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* hits, but * no * you."
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
ppi.play(sdir.."combat/armor/"..math.random(1,armor)..".ogg",0,-50)
 counters.absorb=counters.absorb+1
</send>
 </trigger>
 <trigger
 enabled="y"
 match="PANIC!! +You couldn't escape!"
 script="mgag"
regexp="y"
ignore_case="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/couldn't flee.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* tries to disarm you, but fails."
 script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="9"
 >
 <send>
Sound(sdir.."combat/weapon sounds/they fail disarm.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_mdeath (.*)"
omit_from_output="y"
regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
if ("%1"=="blood demon red winged") then
 return
 end
deadmob=1
if gs("deathaction")==true then
  Execute("death-action");
end
deadmobname = "%1"
stealnext=false
DoAfterSpecial(1,'deadmob=0',12)
play_trip_sound_delayed(0)
require "wait"
wait.make(function()
  if pose~="stand" then 
    PSend("stand")
  end
  if (gs("randoms")==2 and string.lower(leader)==string.lower(gs("me")) and grouped==0) or (gs("randoms")==3 and grouped==1 and string.lower(leader) == string.lower(gs("me"))) or (gs("randoms")==4 and string.lower(leader)==string.lower(gs("me"))) then
    -- If iether of these are true, run the randoms code:
    -- if randoms is set to only when soloing and grouped is 0 (there are only minions in your group). Or.
    -- if randoms is set to 3 (only when grouping), grouped is 1, (There are more than just minions, or no minions), and if the group leader's name matches yours. Or.
    -- Randoms is set to 4, and you are the leader (iether soloing or leading)
    Execute("licrnd")
  end
  wait.time(0.2)
  if (gs("musictype")==2) and (gs("battlemusic")==true) then
    if nfight==1 then
      Sound("stop="..sdir.."music/2/dying.ogg")
      Sound(sdir.."music/2/died.ogg")
    end
  end
  gclear()
  gfighting=0
  if (job=="healer") and (gname~=nil) then
    if (kskills["healingtouch"]==1) then
      PSend("heal "..gname)
    end
  end
  counters.kills=counters.kills+1
  if (pose~="stand") then
    PSend("stand")
  end
  if soulstone then
    soulstone=false
  else
    wait.time(0.7)
    if (mg=="male") then
      Sound(sdir.."combat/deaths/male/"..math.random(1,mdeaths)..".ogg")
    end
    if (mg=="female") then
      Sound(sdir.."combat/deaths/female/"..math.random(1,fdeaths)..".ogg")
    end
    if (mg=="neuter") then
      Sound(sdir.."combat/deaths/neuter/"..math.random(1,ndeaths)..".ogg")
    end
  end
  wait.time(2)
  if (gs("playquotes")==true) then
    Sound(sdir.."combat/pkmsgs/" .. math.random(1,pkmsg).. ".ogg")
  end
end)</send>
 </trigger>
 <trigger
 enabled="y"
 match="Players listening to channel * are:"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>players listening are:</send>
 </trigger>
 <trigger
 group="combat"
 match="* tries to trip you, *"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/they fail to trip you.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* is engulfed in flames!"
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Some of the crystal shards at your feet dissolve and vanish."
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 group="combat"
 match="* trips you, sending you sprawling!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>theyspecial()
play_trip_sound_delayed(-50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="( 3)A large bulletin board is hovering above the ground here."
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>A board is here for posting.</send>
 </trigger>
 <trigger
 enabled="y"
 match="You make an odd *, then look at * through your interlocked fingers."
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* turns and attacks you!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/turn/target.ogg")
Sound(sdir.."skills/turn/attack.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* annoys you."
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
ppi.play(sdir.."combat/armor/"..math.random(1,armor)..".ogg",0,-50)
 counters.absorb=counters.absorb+1</send>
 </trigger>
 <trigger
 enabled="y"
 match="* unlocks *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/unlock.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* leaping attack * you*"
 send_to="14"
 sequence="99"
 >
 <send>Sound(sdir.."combat/weapon sounds/they leap.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* looks you over and tells you, 'I can teach you *"
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You buy *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/buy something.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You miss *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
ppi.play(sdir.."combat/weapon swings/slice/"..math.random(1,swings["slice"])..".ogg",0,40)
counters.theydodge=counters.theydodge+1
if not gag.combat then
Note("You miss.")
end
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="A cloud of choking green gas billows forth from your hand to engulf *"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/noxious cloud.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You can't carry that many items."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (carryblock==1) then
else
Sound(sdir.."items/arms full.ogg")
end
require "wait"
wait.make(function()
carryblock=1
carrycount=carrycount+1
wait.time(1)
if (carrysay==0) then
carrysay=1
Note("You can't carry any more, "..carrycount.." items left.")
wait.time(3)
carrysay=0
end
carryblock=0
carrycount=0
end)</send>
 </trigger>
 <trigger
 enabled="y"
 match="You move to defend yourself from *"
 script="cgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="A crackling blue-white glow suddenly surrounds your hands."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/shocking grasp on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You lightly touch * hands, and a crackling blue-white glow surrounds them."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/shocking grasp on.ogg")</send>
 </trigger>

 <trigger
 group="lvl"
 match="^lvlThief\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>thief=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You can't carry that much weight."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>require "wait"
wait.make(function()
Sound(sdir.."items/can't lift weight.ogg")
carryblock=1
wait.time(2)
carryblock=0
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A pale blue glow surrounds *, then flows outward to surround you."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/refresh area.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A golden glow surrounds *, then flows outward to surround you."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/refresh area.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A golden glow surrounds you, then flows outward."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/refresh area.ogg")</send>
 </trigger>
 <trigger
 group="lvl"
 match="^lvlWarrior\s*\w+\s*(\w+)"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>warrior=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You can't seem to figure out how it works."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/fail pick1.ogg")
if (gs("autopick") == true) then
Execute("pick " ..pick)
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* glows with a bright light!"
 
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
yup=false
for i,v in ipairs(players) do
--print(k,v)
if string.find(players[i],"%1")~=nil then
yup=true
players[i]=players[i].." sanced"
end
end
if not yup then print("%1 is sanced.")
end
yup=nil
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A pale red glow suddenly surrounds your hands."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/burning hands on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You lightly touch * hands, and a pale red glow surrounds them."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/burning hands on.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You cast refresh on *"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/refresh someone.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* goes berserk in battle!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk other.ogg")
if (job=="hitter") then
PSend("berserk")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A shower of * sparks suddenly engulfs *"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
 Sound(sdir.."spells/shower of sparks.ogg")
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscr:You currently gain * hitpoints, * mana, and * movement while *"
 omit_from_log="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
hpregen =tonumber(%1)
mnregen=tonumber(%2)
mvregen=tonumber(%3)
regenscr()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gold deposited into your account."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."gold/deposit.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * on your waist."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/waist.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You disarm * and send * weapon flying!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("You disarm %1!")
counters.disarm=counters.disarm+1
Sound(sdir.."combat/you disarm.ogg")
if (grouped==1) and (job=="hitter") then
if (kskills["trip"]==1) then
hitting="trip"
end
if (kskills["bash"]==1) then
hitting="bash"
end
if (kskills["kick"]==1) then
hitting="kick"
end
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* gold withdrawn from your account."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."gold/withdraw.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wear * to protect your legs."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>checkstats()
Sound(sdir.."wear/legs.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You do not see that character here."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/command wrong.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="(friend) * posted: *"
 ignore_case="y"
 send_to="14"
   omit_from_output="y"
 sequence="100"
 >
 <send>
if "%1"~=gs("me") then
Execute("history_add channels=[friend] %1: %2")
Execute("history_add all=[friend] %1: %2")
end
local frmsg
if gag.expert then
  frmsg="[friend] %1: %2"
else
  frmsg="[friend] %1 posted: %2"
end
Note(frmsg)
Sound(sdir.."channels/friend.ogg")
if gs("comlog")==true and gs("comlogfriends")==true then
  AppendToNotepad("comlog", frmsg.. "\\r\\n")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You do not seem to have that item."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."items/can't find item.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You wield *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
checkstats()
Sound(sdir.."combat/wield/"..math.random(1,wield)..".ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Something REALLY big catches your line, and breaks it!"
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/fishsnap.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You dodge * attack."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>counters.dodge=counters.dodge+1
if (gender=="male") then
Sound(sdir.."combat/dodge/male/" ..math.random(1,mdodge) .. ".ogg")
end
if (gender=="female") then

Sound(sdir.."combat/dodge/female/" .. math.random(1,fdodge) .. ".ogg")
end
if (gender=="neuter") then

Sound(sdir.."combat/dodge/male/" .. math.random(1,mdodge) .. ".ogg")
end
if not gag.combat then
Note("You dodge %1 attack.")
end
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="* is mortally wounded, and will die soon if not aided."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>require "wait"
if stealnext then
Execute("c soulsteal")
stealnext=false
end
wait.make(function()
if (mort==0) then
mort=1
if kxwt_players["%1"] ~= nil then
Sound(sdir.."grouping/mort.ogg")
Execute("tts_interrupt %1 is mortally wounded!")
Execute("history_add all=%1 is mortally wounded!")
Execute("history_add group=%1 is mortally wounded!")
elseif (mg=="male") then
Sound(sdir.."combat/mort/male/"..math.random(1,mmort)..".ogg")
elseif (mg=="female") then
Sound(sdir.."combat/mort/female/"..math.random(1,fmort)..".ogg")
elseif (mg=="neuter") then
Sound(sdir.."combat/mort/neuter/"..math.random(1,nmort)..".ogg")
end
wait.time(2)
mort=0
end
end)</send>
 </trigger>
 <trigger
 enabled="y"
 match="You would be challenged by * but think you could win the battle."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Stat Current Cost (in practices)"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You don't have enough mana."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/out of mana.ogg")
if (grouped==1) then
if gs("swarn") then
if (safety~=1) then
PSend("warn ~ROOM")
safety=1
DoAfterSpecial(3,"safety=0",12)
end
end
end
if (job=="blaster") or (job=="healer") or (job=="healblast") or (job=="areaman") then
EnableTimer("grtimer", false)
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* is on fire!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/fireweb fire.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="That really did hurt!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/that really did hurt!.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* is ready to go *, but you would be left behind!"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."notifications/alert1.ogg")
if k_move&lt;=10 then
if kspells["refresh"]==1 then
Send("c refresh")
end --know ref
end --move low
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The * is closed."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/it is closed.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="fTime of last save: *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* is surrounded by a fuzzy pink outline*"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send> Sound(sdir.."spells/faerie fire someone.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A billowing purple cloud flows forth from your outstretched hand!"
 script="sgag"
omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send> Sound(sdir.."spells/faerfog.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="The air snaps as * abruptly disappears."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/someone summoned out.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* is surrounded by a white aura."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sanc on.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* tells you, 'The following items are available for sale at this time'"
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You open *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/open.ogg")
if mtime then
Note("To add this door to your map, type zmap door or zmd open doorname and optional direction if necessary. Do it before you move! Example: zmd open gates n")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* warns the group, 'I am using mushclient-z which can be downloaded from *"
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="To see a specific item in detail, *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>End of list.</send>
 </trigger>
 <trigger
 enabled="y"
 match="You order * to *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* yells, 'Retreat!  Retreat!'"
 send_to="12"
 sequence="99"
 >
<send>
Sound(sdir.."channels/yell retreat.ogg")
Execute("history_add channels=%1 yells, Retreat!  Retreat!")
Execute("history_add all=%1 yells, Retreat!  Retreat!")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="To use a waypoint, give its number, for example 'waypoint *'."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You parry * attack."
 script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>counters.parry=counters.parry+1

ppi.play(sdir.."combat/parry/" .. math.random(1, tparry) .. ".ogg",0,-50)
 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* yells, '*'"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 yells, %2")
Sound(sdir.."channels/yell.ogg")
Execute("history_add channels=%1 yells, %2")
Execute("history_add all=%1 yells, %2")
</send>
 </trigger>
 <trigger
 group="combat"
 match="You catch * a little off center with your bash!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/bash3.ogg",0,50)
theygrunt()
end)
Note("off center.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Trying to enable echo."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* places * in the back of *."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/4.ogg")
bfight("%1")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You place * in the back of *."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/4.ogg")</send>
 </trigger>
 <trigger
 group="frostbite"
 match="A white line of frost * away from your staff*"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/frost2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Object is: "
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Your fingers quickly become more nimble as magic flows through you."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dex on.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your magically induced dexterity abruptly disappears."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/dex off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You circle behind * and find a perfect opportunity!"
 script="skgag"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>freak 2!</send>
 </trigger>
 <trigger
 enabled="y"
 match="You pray to * for transportation..."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (map==1) then
AppendToNotepad("map", "recall;")
end
Sound(sdir.."misc/recall.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You pray to * for transportation!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (map==1) then
AppendToNotepad("map", "recall;")
end
Sound(sdir.."spells/word.ogg")</send>
 </trigger>
 <trigger
 match="^Affects\: \s*(.*) by \s*(.*)$"
 omit_from_output="y"
enabled="y"
 ignore_case="y"
regexp="y"
 sequence="100"
send_to="14"
 >
 <send>
--print(iaffects)
if (gs("shortid")==1) or (iaffects == nil) then
Note("%1 by %2")
return
end
if (gs("shortid")==3) then
Note("%1 by %2")
end
if affs["%1"]~=nil then
table.insert(iaffects," "..affs["%1"].." %2")
else
table.insert(iaffects," %1 %2")
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="Your force shield slowly dissipates."
 send_to="14"
 sequence="100"
omit_from_output="y"
script="sgag"
 >
 <send>
Sound(sdir.."spells/shield off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You climb into your hiding spot."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/hide.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Type: MAGIC Composition: * Ac-apply: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("This magical armor gives %2 ac")
ac=" ac %2 "
</send>
 </trigger>
 <trigger
 group="fishing"
 match="After a big fight, you reel in *"
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("donfish") == true) then
PSend("donate fish")
end
Sound(sdir.."misc/fishcatch.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^tnpYou have (\w+) experience and \w+ total levels in your .* classes.$"
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>exp=%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your form shifts slightly, then separates from where your body actually is."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/displacement.ogg")
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="You can feel an invisible mana shield connect to your mana."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/mana shield on.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You lift off the ground as an invisible bundle of magic forms beneath your feet."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/fly.ogg")</send>
 </trigger>

 <trigger
 enabled="y"
 match="You close *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/close.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* growls at you, warning you away."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."combat/warning growl.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Alas, you cannot go that way."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."movement/wrong exit/"..terrain..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^tnpYou can train to get a practice, at a cost of (\d+) experience each."
 omit_from_output="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>pcost=%1
prac=exp/pcost*100
prac=tostring(prac)
dot=string.find(prac, "%p")
if (dot ~= nil) then
  dot2=dot+1
  prac=string.sub(prac, 1,dot)..string.sub(prac,dot2,dot2)
end
Note("you are "..prac.." percent to training a prac.")
if (gs("praccing")==true) then
exptnl=pcost
classtnl="practice"
end
</send>
 </trigger>
 <trigger
 group="combat"
 match="Your full circle kick plants a foot right where it should be."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/kick3.ogg",0,50)
theygrunt()
end)
Note("full circle!")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You could kill * naked and weaponless."
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="n"
 match="* has already been stripped * there is nothing edible left."
 sequence="100"
 >
 <send>sacrifice ?corpse
stand</send>
 </trigger>
 <trigger
 enabled="y"
 match="You create and scatter some ice crystals, then force them to grow!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Spiked flowers of ice quickly form on everything in a ring around you!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/frostflower.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You throw a magical dart of blue fire at *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/blue dart.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You blast * with a bright * fan of static electricity!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/static blast.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You sense a hidden life form in the room."
 send_to="12"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sense life.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="A * bolt of lightning leaps from you to *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/lightning bolt.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\-\*BOOM\*\- (.*?) lightning bolt strikes a ball of lightning\, causing an explosion near (.*?)\!"
 regexp="y"
   omit_from_output="y"
   script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>
if not gag.sounds then
Sound(sdir.."spells/boom lightning.ogg")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\-\*BOOM\*\- (.*?) blast of static electricity explodes some of the frost flowers near (.*?)\!"
 regexp="y"
 omit_from_output="y"
 script="sgag"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/boom frost.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* blasted by a terrific bolt of lightning!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>ppi.play(sdir.."spells/chain/1.ogg",0,math.random(-100,100))</send>
 </trigger>
 <trigger
 enabled="y"
 match="* blasted by a bolt of lightning!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>ppi.play(sdir.."spells/chain/2.ogg",0,math.random(-100,100))</send>
 </trigger>
 <trigger
 enabled="y"
 match="* hit by a bolt of lightning!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>ppi.play(sdir.."spells/chain/3.ogg",0,math.random(-100,100))</send>
 </trigger>
 <trigger
 enabled="y"
 match="A bolt of lightning fizzles out with a loud electrical pop."
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/chain//fizzle.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The lightning bolt arcs and jumps to *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="a Halloween Pumpkin carried by *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 ignore_case="y"
 match="* has been killed!"
 send_to="14"
 sequence="100"
 >
 <send>
if kxwt_players["%1"] ~= nil then
Sound(sdir.."combat/die group.ogg")
Execute("history_add group=%1 has died!")
Execute("history_add all=%1 has died!")
else
if (gs("playquotes")==true) then
  Sound(sdir.."combat/pkmsgs/" ..math.random(1, pkmsg) .. ".ogg")
end
end
Sound(sdir.."combat/die player.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="a Halloween Pumpkin in (object) a pine crate for holiday events."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You don't know that spell at all, but attempt to cast it anyway."
 send_to="14"
 sequence="100"
 >
 <send>casting=""</send>
 </trigger>
 <trigger
 enabled="y"
 match="^\(friend\) (.+) has entered the game.$"
 regexp="y"
group="friendsnotify"
 ignore_case="y"
 send_to="14"
 sequence="95"
 >
 <send>Sound(sdir.."channels/enter.ogg")
Execute("history_add all=%0")
Execute("history_add friends=%0")
</send>

 </trigger>
  
     <trigger
 enabled="y"
 match="^(.+) has entered the game.$"
 regexp="y"
 ignore_case="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channels/enter.ogg")
Execute("history_add all=%0")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You would feel really bad about killing * as you are so much higher level."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You don't see any of your group members here to split the gold with."
 omit_from_output="y"
 sequence="100"
>
 </trigger>
 <trigger
 enabled="y"
 match="zchn:[arena] * has joined pk arena *"
 ignore_case="y"
 send_to="14"
 omit_from_output="y"
 sequence="100"
 >
 <send>Sound(sdir.."combat/arena/someone joins arena.ogg")
Execute("history_add arena=%1 joined arena %2.")
if gs("logarena") == true then
Execute("history_add all=%1 joined arena %2.")
end
Note("%1 has joined arena %2.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="zchn:[arena] * has cowardly recalled from arena *"
 ignore_case="y"
 send_to="14"
 sequence="100"
 omit_from_output="y"
 >
 <send>Sound(sdir.."combat/arena/someone joins arena.ogg")
if gs("logarena") == true then
Execute("history_add all=%1 recalled from the arena.")
end
Execute("history_add arena=%1 recalled from the arena.")
Note("%1 has cowardly recalled from arena %2")
</send>
 </trigger>
 <trigger
 group="combat"
 match="Your * hits, but *"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
ppi.play(sdir.."combat/armor/"..math.random(1,armor)..".ogg",0,50)
 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You don't see anyone named that here."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."notifications/command wrong.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="Your * hits, but *"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>
ppi.play(sdir.."combat/armor/"..math.random(1,armor)..".ogg",0,50)

</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^The earth suddenly buckles and heaves (around you|violently near .+)\!$"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/earthquake.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="gendYou are *, and currently * feet, * inches tall."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>gender="%1"</send>
 </trigger>
 <trigger
 enabled="y"
 match="* is surrounded with a dark black aura."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
worked=false
for i,v in ipairs(players) do
--print(k,v)
if string.find(players[i],"%1")~=nil then
worked=true
players[i]=players[i].." darkened"
end
end
if not worked then print("%1 is darkened.") end
worked=nil
</send>
 </trigger>
 <trigger
 group="combat"
 match="Your arrow narrowly misses *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/arrow miss.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The fever passes and you regain your senses*to find your target no longer before you."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk pass.ogg")
berserk=0</send>
 </trigger>
 <trigger
 enabled="y"
 match="lvl"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You drop *"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."items/drop/" .. math.random(1,drops)..".ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="* knocks your legs out from under you!"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
theyspecial()
play_trip_sound_delayed(-50)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The fever passes, leaving you exhausted and still in battle!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/berserk interrupted OMV.ogg")
berserk=0</send>
 </trigger>
 <trigger
 enabled="y"
 match="lvlClass Current Cost to level"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>EnableGroup("lvl", 1)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* laughs mercilessly at you."
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."skills/turn/target.ogg")
Sound(sdir.."skills/turn/laugh.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The flames pass silently through you without any effect."
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="lvlYou must specify which class to level - for example 'level cleric'"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 group="stab"
 match="* looks mildly annoyed as you place *"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/6.ogg")
EnableGroup("stab", 0)
Note("mildly annoyed.")</send>
 </trigger>
 <trigger
 enabled="y"
 match="* looks mildly annoyed as * places *"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/6.ogg")
bfight("%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="The following items are currently up for grabs:"
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* makes a strange sound as * places * in * back."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/3.ogg")
bfight("%2")
</send>
 </trigger>

 <trigger
 enabled="y"
 group="stab"
 match="* makes a strange noise as you place * in * back."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/3.ogg")
EnableGroup("stab", 0)
Note("strange noise.")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The mud school trainer says, '*'"
 omit_from_output="y"
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You pray to your god for transportation!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (map==1) then
AppendToNotepad("map", "recall;")
end
Sound(sdir.."spells/word.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="The white aura around your body fades."
 send_to="14"
 sequence="99"
 >
 <send>
Sound(sdir.."spells/sancoff.ogg")
if (grouped==1) and (gs("swarn") == true) then
PSend("warn sanc out!")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You slowly float back to the ground as your fly spell wears off."
 send_to="14"
 sequence="99"
 >
 <send>
Sound(sdir.."spells/fly off.ogg")
if (grouped==1) and (gs("swarn") == true) then
PSend("sub fly down.")
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="Type: TRASH *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="The * guildmaster says, '*'"
 omit_from_output="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You put * in *"
 send_to="14"
 sequence="100"
omit_from_output="n"
 >
 <send>
if brewing==1 then
ritems=ritems+1
table.insert(recipe,"%1")
else
Sound(sdir.."misc/put in container.ogg")
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You put * in your storage locker."
 send_to="14"
 script="mgag"
omit_from_output="y"
 sequence="90"
 >
 <send>Sound(sdir.."misc/put in locker.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You drop * gold coins."
 send_to="14"
 sequence="99"
 >
 <send>Sound(sdir.."items/drop/dropgold.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Variable * to *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/variable set.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You emote: *"
 omit_from_output="y"
 send_to="2"
 sequence="1"
 >
 <send>%1</send>
 </trigger>
 <trigger
 enabled="y"
 match="You put one end of * to the ground and begin the spell."
 script="sgag"
 omit_from_log="y"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/frost1.ogg")
EnableGroup("frostbite", 1)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^You get (.*) from (.*)\."
 send_to="14"
 sequence="99"
regexp="y"
omit_from_output="y"
 >
 <send>
require "wait"
wait.make(function()
table.insert(getitems, "%1")
if not (getblock==1) then
Sound(sdir.."items/get item container.ogg")
end
getblock=1
getcount=getcount+1
wait.time(0.4)
if (getsay==0) then
getsay=1
for i,v in pairs(getitems) do
if IsInTable(uniques,v)==0 then
if gs("items")~=3 then
length=0
word=""
for w in string.gmatch(v, "%S+") do
if string.len(w)>length then
word=w
length=string.len(w)
end
end
if gs("items")==1 then
if gs("container")~=nil then
Send("put "..word.." "..gs("container"))
end
elseif gs("items")==2 then
Send("drop "..word)
Send("sac "..word)
elseif gs("items")==4 then
Send("donate "..word)
elseif gs("items")==5 then
Send("storage put "..word)
end
end
end
end
if getcount&lt;1 then
elseif getcount==1 then
Note("You get %1 from %2.")
elseif getcount>1 then
Note("You get "..getcount.." items from %2: "..table.concat(getitems, ", "))
end
getsay=0
getblock=0
getcount=0
end
getitems={}
uniques={}
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your god appreciates your sacrifice."
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Wear locations are: *"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
iworn=""
s = "%1"
for w in string.gmatch(s, "%S+") do
if (gs("shortid")==1) then
Note("-"..w)
return
end
if (gs("shortid")==3) then
Note("-"..w)
end

iworn=iworn.." "..w
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You say, 'boner, *'"
 omit_from_output="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You receive * experience points."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You receive "..ntrunk("%1").." experience.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Are you mad?"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You get the feeling that this spot is fished out."
 sequence="99"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Your hook gets stuck on something, and you have to break the line."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/fishsnap.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You learn very little from this battle.  You receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You learn very little from this battle.  You receive "..ntrunk("%1").." experience.")
death_exp(%1)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You receive "..ntrunk("%1").." experience.")
death_exp(%1)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Arena battles: (none)"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You create an invisible ball of magic and project it to hit *"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/magic missile.ogg")</send>
 </trigger>
 <trigger
 match="(auction) '*', going once for * gold coins."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/auction bell1.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="As the world goes black you feel pieces of your mind fading..."
 omit_from_output="n"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="Your magical protection from electricity weakens, then fades."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/ground off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The magical flames protecting you flicker and go out."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/fireshield off.ogg")
checkstats()
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your ice shield fades and is gone."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/iceshield off.ogg")
checkstats()
</send>
 </trigger>

 <trigger
 enabled="y"
group="friendsnotify"
 match="^\(friend\) (.+) has left the game.$"
 regexp="y"
 ignore_case="y"
 send_to="14"
 sequence="95"
 >
 <send>Sound(sdir.."channels/leave.ogg")
Execute("history_add all=%0")
Execute("history_add friends=%0")
</send>
 </trigger>
  
   <trigger
 enabled="y"
 match="^(.+) has left the game.$"
 regexp="y"
 ignore_case="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channels/leave.ogg")
Execute("history_add all=%0")
</send>
 </trigger>
  
 <trigger
 match="(auction) '*', going twice for * gold coins."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."auction/auction bell2.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You slowly float to the ground."
 send_to="14"
 sequence="100"
 >
 <send>flystatus="walking"</send>
 </trigger>
 <trigger
 enabled="y"
 match="As you hit * a bright fan of lightning bolts leaps from your hands to blast *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/shocking grasp blast.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your sickening touch spreads to * as you hit *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/sickening touch blast.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your name would go down in history if you actually managed to win such an impossible fight."
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* has reconnected."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channels/reconnected.ogg")
Execute("history_add friends=%1 reconnected.")
Execute("history_add all=%1 reconnected.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* has lost * link."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."channels/leave linkdead.ogg")
Execute("history_add all=%1 lost %2 link.")
</send>
 </trigger>
 <trigger
 match="(auction) * has bid * gold coins for *"
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("%1 bids %2.")
Sound(sdir.."auction/bid.ogg")</send>
 </trigger>
 <trigger
 regexp="y"
 match="^\(auction\) New bid.* (\d+) gold coins for \'(.+)\'\.$"
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("Bid: %1 gold for %2.")
Sound(sdir.."auction/bid.ogg")</send>
 </trigger>
 <trigger
 group="group"
 match="You split * gold coins with your group."
 omit_from_output="y"
send_to="14"
 sequence="100"
 >
<send>gg=tonumber(%1)
counters.steal=counters.steal-gg</send>
 </trigger>
 <trigger
 match="(^\w+) tells you\, \'\!ping\'"
 regexp="y"
group="telltriggers"
 ignore_case="y"
enabled="y"
 omit_from_output="y"
 sequence="1"
send_to="14"
 >
 <send>
if (safety ~= 1) and ("%1" == "Shran" or "%1" == "Dentin" or "%1" == "Mushz" or "%1" == "Kurek" or "%1" == "Slej" or "%1" == "Dernan" or "%1" == "Rhorae	") then
Note("%1  is checking which version of mush-z you are running...")
safety=1
version=Version()
PSend("tell %1 pong! mush-z "..GetVariable("version")..", mushclient version "..version.." | prefix mzc")
DoAfterSpecial(10,"safety=0",12)
else
ColourNote(RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['textcolour']), RGBColourToName(TriggerStyleRuns[#TriggerStyleRuns]['backcolour']), "%1 tells you, !ping")
if "%1" ~= "Soul Eater" then
Sound(sdir.."channels/tell.ogg")
Execute("history_add tells=%1 tells you, !ping")
Execute("history_add all=%1 tells you, !ping")
end
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="pingYou reply to *, '*'"
 ignore_case="y"
 omit_from_output="y"
 sequence="1"
 >
 </trigger>
 <trigger
 enabled="y"
 match="As you hit * a bright flash of red fire leaps from your hands to scorch *!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/burning hands blast.ogg")</send>
 </trigger>

 <trigger
 match="(auction) * sold to * for * gold coins."
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("Auction finished, sold to %2")
Execute("history_add auction=finished: %1 sold to %2 for %3.")
Sound(sdir.."auction/item sold.ogg")
</send>
 </trigger>
 <trigger
 regexp="y"
 match="^\(auction\) \'(.+)\' sold for (\d+) gold coins\.$"
 omit_from_output="y"
enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("Auction finished at %2 gold.")
Execute("history_add auction=finished: %1 sold for %2.")
Sound(sdir.."auction/item sold.ogg")
</send>
 </trigger>
 <trigger
 group="combat"
 match="Your arrow strikes *!"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."combat/arrow strike.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You squeeze a plush poison-dart frog, firing a poisoned dart at *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You dump *, and a * liquid flows all over the place."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."brewing/dump container.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel lost pieces of your mind coming back..."
 send_to="14"
 sequence="100"
 >
 <send>
DoAfterSpecial(0.6,'Sound(sdir.."spells/youres2.ogg")',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="A high-pitched whine fills your hearing, and you feel exhausted."
 send_to="14"
 sequence="100"
 >
 <send>
DoAfterSpecial(1,'Sound(sdir.."spells/youres3.ogg")',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Everything turns white, and the pressure of traveling impossibly fast fills your senses!"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/youres1.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="* has summoned you!"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/got summoned.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your backstab does considerable damage to *"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."skills/backstab/2.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You stand up."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."misc/stand.ogg")
nocastdeathly=0
</send>
 </trigger>
 <trigger
 enabled="y"
group="combat"
 match="You stand up."
 script="cgag"
 omit_from_output="y"
 send_to="14"
 sequence="90"
 >
 <send>
Sound(sdir.."misc/stand.ogg")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You earn * experience points*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You earn "..ntrunk("%1").." experience.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* has won the deathmatch in arena *"
 send_to="14"
 sequence="100"
   keep_evaluating="y"
 >
 <send>Sound(sdir.."combat/arena/win arena.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your blood freezes as you hear * death cry!"
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You start fishing."
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."misc/fishcast.ogg")
EnableGroup("fishing", 1)</send>
 </trigger>
 <trigger
 enabled="y"
 match="lvlor 'level thief'."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="You end up with a stinky*but no*."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."brewing/nasty mess.ogg")
if gs("brewcontainer") ~= "" then
Execute("empty "..gs("brewcontainer"))
end
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your chance of winning:"
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="The gods grant you a new lease on life!"
 script="mgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="It is already open!"
 send_to="14"
 sequence="100"
 >
 <send>
if mtime then
Note("To add this to your map use zmd open * or zmap door open *. For example, zmd open gates")
end
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You enter *."
 send_to="14"
omit_from_output="y"
 sequence="100"
 >
 <send>if (map==1) then
AppendToNotepad("map", "enter %1;")
end
Note("You enter %1")
if mtime then
Note("To add this to your map use zmd enter * or zmap door enter *.")
else
Note("You enter %1")
end
Sound(sdir.."movement/enter portal.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="You begin your climb *ward."
 send_to="14"
 sequence="100"
 >
 <send>if (map==1) then
AppendToNotepad("map", "climb %1;")
end
if mtime==true then
table.insert(curmap,"climb %1")
end
Sound(sdir.."movement/climb.ogg")</send>
 </trigger>

 <trigger
 group="combat"
 match="* misses you."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>counters.dodge=counters.dodge+1
if not gag.combat then
if (mg=="male") then
Note("he misses.")
end
if (mg=="female") then
Note("she misses.")
end
if (mg=="neuter") then
Note("it misses.")
end
end

ppi.play(sdir.."combat/weapon swings/slice/"..math.random(1,swings["slice"])..".ogg",0,-50)
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="Your displaced image rejoins your body."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/displacement off.ogg")
if (grouped==1) and (gs("swarn") == true) then
PSend("sub displace out.")
end
checkstats()</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel your invisible mana shield flicker and go out."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/mana shield off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The red in your vision disappears."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/infra off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The detect invisible wears off."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/dinvis off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You feel less aware of your surroundings."
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."spells/sl off.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="The leader of * group is rated as *"
 omit_from_output="y"
 send_to="2"
 sequence="100"
 >
 <send>The leader is rated as %2</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscr:You feel *"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="* muscles magically fill out as artificial strength courses through * body."
 script="sgag"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^\*Click\*.*$"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."doors/pick door.ogg")
 if gs("autoopen") == true then
  PSend("open "..pick)
 end
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="The spear shatters as it hits *, shards go flying!"
 script="sgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>blasting="greater"
Note("No affect, too much ac")
blasting="greater fireball"
Sound(sdir.."spells/crystal spear shatter.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzscrNotify channel off."
 omit_from_output="y"
 sequence="100"
 >
 <send>notify | prefix mzscr</send>
 </trigger>
 <trigger
 enabled="y"
 match="The spell fails utterly."
 send_to="14"
 sequence="100"
 >
 <send>Sound(sdir.."spells/fails utterly.ogg")
</send>
 </trigger>
 <trigger
 group="combat"
 match="You kick * in the back of the head, causing critical damage."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/kick2.ogg",0,50)
theygrunt()
end)
</send>
 </trigger>
 <trigger
 enabled="y"
 regexp="y"
 match="^You receive (\d+) gold coins for your sacrifice of (.+)\.$"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("sacsplit") == true) and (grouped == 1) then
Execute("split %1")
end
gg=tonumber(%1)
counters.steal=counters.steal+gg
Sound(sdir.."misc/sac1.ogg")
DoAfterSpecial(2.2,'Sound(sdir.."misc/sac2.ogg")',12)
</send>
 </trigger>
 <trigger
 enabled="y"
 group="stab"
 match="You place * in the back of * mortally wounding *"
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>Sound(sdir.."skills/backstab/1.ogg")
EnableGroup("stab", 0)</send>
 </trigger>
 <trigger
 group="fishing"
 match="After an exhausting struggle, you land *"
 script="mgag"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("donfish") == true) then
PSend("donate fish")
end
Sound(sdir.."misc/fishcatch.ogg")</send>
 </trigger>
 <trigger
 group="combat"
 match="Your kick to * could have been better, but you got the point across."
 script="skgag"
 omit_from_output="y"
 send_to="14"
 sequence="99"
 >
 <send>
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."skills/kick4.ogg",0,50)
theygrunt()
end)
Note("Could have been better.")
</send>
 </trigger>
</triggers>
<triggers>
 <!-- Crafting sounds and filtering -->
 <trigger
 enabled="y"
 match="You uncover a deposit of * and stake it out."
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/mining_find.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You make a critical error while separating the gangue from the deposit and accidentally destroy some of it."
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/mining_fail_land.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You misjudge the angle of your dig, and part of the deposit sinks into the water and is lost."
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/mining_fail_water.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You keep looking for deposits\.\.\.|You don't find anything\, so you continue prospecting\.|You continue searching for minerals and ores\.\.\.)$"
 omit_from_output="y"
 script="crgag"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You excavate * from a deposit of *."
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/mining_dig/"..math.random(1,6)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You continue excavating\.\.\.|You carefully chip away at a deposit of .*\.\.\.|You keep digging\.\.\.|You have some trouble separating the gangue from the deposit\, so you keep excavating\.)$"
 send_to="14"
 omit_from_output="y"
 script="crgag"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/mining_dig/"..math.random(1,6)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You saw out a rough shape from *"
 omit_from_output="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/saw/"..math.random(1,3)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You peel off long strips from .*\, rounding its basic shape\.\.\.|You chip off long flakes from .*\, rounding its basic shape\.\.\.|You chip a few long flakes of bone from .*\.\.\.|You split off large chips from .*\, refining its shape\.\.\.|You shave off long curls of wood from .*\.\.\.)$"
 omit_from_output="y"
 regexp="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/bone_wood_big/"..math.random(1,3)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You carefully shave some wood from .*\.\.\.|You make a quick series of small cuts on .*\.\.\.|You cut a few notches into .*\.\.\.|You smooth the edges of .*\.\.\.)$"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/bone_wood_small/"..math.random(1,4)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(After a final sanding and examination\, .* is complete\.|You mount the fletching and .* is complete\.)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/woodcraft_finish.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You make the wrong move and crack *, ruining it!"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/woodcraft_ruin.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^With a bit of effort you (saw .* in half\!|split .* into four equal pieces\!)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/saw/"..math.random(1,3)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You hammer at .*\, knocking off the scored pieces to get a basic shape\.\.\.|You knock smaller pieces off from .*\, refining its shape\.\.\.|You break apart .* and carefully chip holes through the rough beads\.\.\.)$"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_big/"..math.random(1,3)..".ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You carefully grind down the surface of .*\.\.\.|You carefully chisel a few notches into .*\.\.\.|You grind away at .*\.\.\.|You carve .* into a rough cylinder\.\.\.|You grind a few more beads from .*\.\.\.|You carefully smooth the edges of .*\.\.\.)$"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_small.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You deeply score .*|You carefully score shallow grooves into the sides of .*\.\.\.)$"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_score.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You strike at the wrong angle and crack .*\, shattering it into dust\!|You fumble your grip and crack .*\, shattering it into dust\!|You make the wrong move and crack .*\, shattering it into dust\!)$"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_fail.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="After a final buff and polish, * is complete!"
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_finish.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You string the beads on a cord and tie it off, and * is complete."
 send_to="14"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_beads.ogg")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^(.* melts down .*to.*|You melt down .* to form two smaller ingots\.|You melt down .* and .* to form a new, larger ingot\.\.\.|You stoke up the forge and place .*)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_smelt.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(.* works the bellows of the forge\.|.* places .* into the forge and works the bellows\.|You stoke up the forge and place .* in it to roast\.|You hold .* in a pair of tongs and heat it up red hot\.|.* begins to heat up\.\.\.|You continue working the bellows as .* roasts in the forge\.|.* starts to crack and smoke as the impurities are burnt away\.|Molten metal pools in a crucible at the bottom of the forge as .* burns away\.|You blast the crucible in the forge to burn away as many of the impurities as you can\.|.* melts in the crucible as you work the bellows of the forge\.|You place .* back into the forge and heat it up\.)$"
 send_to="14"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 sequence="99"
 >
 <send>
 Sound(sdir.."crafting/forge_smelt.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(.* removes* .* from the forge and begins* beating it into a rough shape.*|You pull .* from the forge and pound .*|.* pulls .* from the forge and begins working on it\.|You prepare .* to be inlaid\.)$"
 send_to="14"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_big/"..math.random(1,5)..".ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You retrieve the crucible with a pair of tongs and prepare to pour out the metal\.|You pour the molten metal from the crucible into a mold and let it cool\.|You pull the crucible from the forge and pour its contents into a mold to cool\.)$"
 send_to="14"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 sequence="100"
 >
 <send>
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You carefully remove .* from its mold\.|You open the mold and string the beads on a cord\, and .* is complete!)$"
 send_to="14"
 regexp="y"
 sequence="99"
 >
 <send>
 Sound(sdir.."crafting/forge_generic_mold.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You pull .* from the forge and carefully .* quick\, decisive taps\.|You rivet the edges of the armor with short\, swift blows\.)$"
 send_to="14"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_generic_small.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You quench the metal and .* is complete!$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_generic_finish.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You finish riveting the pieces together and .* is complete!*$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_armor_finish.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You assemble all the pieces together\, creating .*!$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_weapon_finish.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You pound .* flat\, then carefully inlay it onto .*\.$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_inlay.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You make a mistake and end up with a .* lump instead of a fine metal item!|You make a mistake\, and ruin .* beyond repair!)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_generic_fail.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You make a mistake while attempting to inlay with .*!|You make a mistake while smelting\, and contaminate .*|You make a mistake and end up with molten metal all over the ground instead of a finished metal item!|.* is reduced to slag!)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/forge_smelt_fail.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You mount .* in its setting and .* is complete!$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_mount.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You chip off pieces of .* and carefully tamp them down, and .* is complete!$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/lapidary_inlay.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You start cutting up and stitching together .* from .*\.$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/leathercraft/"..math.random(1,7)..".ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You cut out the basic forms you need from .*\.\.\.|You finish cutting out the basic forms and start putting them together\, folding and trimming when necessary\.\.\.|You make a quick series of small cuts on .*(skin|hide|pelt|shell|patchwork|scale).*\.\.\.|You make several long\, straight cuts on .*\.\.\.|You join two edges of .* together\.\.\.|You carefully trim .*\.\.\.|You make a cut and bind the edges on .*\.\.\.)$"
 send_to="14"
 regexp="y"
 omit_from_output="y"
 script="crgag"
 sequence="99"
 >
 <send>
 Sound(sdir.."crafting/leathercraft/"..math.random(1,7)..".ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^You complete .*(skin|hide|pelt|shell|patchwork|scale).*!$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/leathercraft_finish.ogg")
 </send>
 </trigger>
 <trigger
 enabled="y"
 match="^(You finish securing the straps on .*!|You finish braiding .*!)$"
 send_to="14"
 regexp="y"
 sequence="100"
 >
 <send>
 Sound(sdir.."crafting/leathercraft_finish.ogg")
 </send>
 </trigger>
</triggers>
<triggers>
 <trigger
 enabled="y"
 keep_evaluating="y"
 match="*(unique)"
 send_to="14"
 sequence="1"
 >
 <send>Sound(sdir.."notifications/random.ogg")</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzrandom(on ground) * contains:"
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzrandomNothing matching those arguments found."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzrandomNothing."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^Item\: '(.*)'\s*"
regexp="y"
 omit_from_output="y"
 send_to="14"
 sequence="1"
 >
 <send>cmi=1
cmistr=""
idname="%1"
Note("%1")
EnableGroup("compare",true)
DoAfterSpecial(1,'EnableGroup("compare",false)',12)
ac=""
</send>
 </trigger>
 <trigger
 enabled="y"
 match="mzrandomR (* *)*Item: * '*'"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>uuid="%4"
PSend("get "..uuid.." ?corpse ground")
if gs("randomsaction") == 2 and gs("container") ~= nil and gs("container") ~= "" then
PSend("put "..uuid.." "..gs("container"))
elseif gs("randomsaction") == 3 then
PSend("donate "..uuid)
elseif gs("randomsaction") == 4 then
PSend("drop "..uuid..";sacrifice "..uuid)
end
</send>
 </trigger>
 <trigger
 enabled="y"
regexp="y"
 match="^storecheck.*Item:\s*(\w+)\s*'(.*)'"
 omit_from_output="y"
 send_to="1"
 sequence="50"
script="itemfunc"
 >
 <send>
</send>
 </trigger>
 <trigger
 enabled="y"
 match="storecheck*"
 omit_from_output="n"
 send_to="14"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="mzrandomYou do not see that here."
 omit_from_output="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="lagcheck"
 omit_from_output="y"
keep_evaluating="y"
 sequence="100"
 >
 </trigger>
  <trigger
   enabled="y"
   match="zchn:*"
 ignore_case="y"
   omit_from_output="y"
   send_to="2"
   sequence="200"
  >
  <send>%1</send>
  </trigger>

</triggers>

<triggers>
  <trigger
   enabled="y"
   group="rune"
   match="^You open your sewing kit and begin tailoring (?P&lt;item&gt;.*?)\.  Following your instincts, you embroider the rune \'(?P&lt;rune&gt;.*?)\'\.$"
   name="carve_rune_6"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You open your sewing kit and begin tailoring a worn woven belt.  Following your instincts, you embroider the rune 'Ilnak'.
</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^You carefully heat a branding tool and start firebranding (?P&lt;item&gt;.*?)\.  Gradually you shape the rune \'(?P&lt;rune&gt;.*?)\'\.$"
   name="carve_rune_5"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You carefully heat a branding tool and start firebranding black and red leather  gloves.  Gradually you shape the rune 'Hett'.
</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^You get out your heavily enchanted tools and start chiseling on (?P&lt;item&gt;.*?)\.  Gradually you shape the rune \'(?P&lt;rune&gt;.*?)\'\.$"
   name="carve_rune_4"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You get out your heavily enchanted tools and start chiseling on a shadowless cuirass.  Gradually you shape the rune 'Stis'.
</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^It has the following runes cut into it\: (?P&lt;runes&gt;.*?)$"
   name="look_runed_object"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="look_runed_object"
   send_to="14"
   sequence="99"
  >
  <send>--It has the following runes cut into it: Gesu Vin Ber Gesu-Ilnak</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^You examine (?P&lt;item&gt;.*?) and start carving\, and the knots and grain of the wood fall into line with the rune \'(?P&lt;rune&gt;.*?)\'\.$"
   name="carve_rune_1"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You examine a wooden branch and start carving, and the knots and grain of the wood fall into line with the rune 'Gesu-Fell'.</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^You carve the rune \'(?P&lt;rune&gt;.*?)\' into (?P&lt;item&gt;.*?)\.$"
   name="carve_rune_2"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You carve the rune 'Stis' into a black moonstone belt.</send>
  </trigger>
  <trigger
   enabled="y"
   group="rune"
   match="^You get out a pick and some other tiny enchanted tools and start chiseling on (?P&lt;item&gt;.*?)\.  Gradually you shape the rune \'(?P&lt;rune&gt;.*?)\'\.$"
   name="carve_rune_3"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   script="carve_rune"
   send_to="14"
   sequence="99"
  >
  <send>--You get out a pick and some other tiny enchanted tools and start chiseling on a crown of skulls.  Gradually you shape the rune 'Vin'.
--You get out a pick and some other tiny enchanted tools and start chiseling on a stegapalus-plate belt.  Gradually you shape the rune 'Gesu-Ciru'.</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   ignore_case="y"
   match="^A transparent crystal bubble envelopes your body.$"
   regexp="y"
   omit_from_output="y"
   script="sgag"
   send_to="12"
   sequence="100"
  >
  <send>Sound(sdir.."spells/diffraction.ogg")</send>
  </trigger>
  <trigger
   enabled="y"
   ignore_case="y"
   match="^The crystal bubble surrounding you suddenly shatters!$"
   regexp="y"
   omit_from_output="y"
   script="sgag"
   send_to="12"
   sequence="100"
  >
  <send>Sound(sdir.."spells/diffraction down.ogg")</send>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   ignore_case="y"
   match="^(A blinding flare of sunlight lances out of a suncatcher bottle and rakes across .+!|A blinding flare of sunlight lances out of a cracked suncatcher bottle and rakes across .+!)$"
   omit_from_output="y"
   regexp="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   ignore_case="y"
   match="*'s form slowly loses its shape in the blazing sunlight!"
   omit_from_output="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   ignore_case="y"
   match="^(You cast a short unbinding spell on a suncatcher bottle.|You cast a short unbinding spell on a cracked suncatcher bottle.)$"
   omit_from_output="y"
   regexp="y"
   script="sgag"
   send_to="14"
   sequence="100"
  >
  <send>Sound(sdir .."druid/solarflare.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   ignore_case="y"
   match="^A.*suncatcher bottle explodes with a pop, and blinding light fills the air!$"
   omit_from_output="y"
   regexp="y"
   script="sgag"
   send_to="12"
   sequence="100"
  >
  <send>Sound(sdir .."druid/sunblind.ogg")</send>
  </trigger>

  <trigger
   enabled="y"
   match="^Double mob experience is now enabled!$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  Sound(sdir.."notifications/double mob xp on.ogg")
Execute("history_add all=Double mob experience enabled")
Execute("history_add experience=Double mob experience enabled")
  </send>
  </trigger>
  <trigger
   enabled="y"
   match="^Double experience caps for mob kills are now enabled!$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  Sound(sdir.."notifications/double xp caps on.ogg")
Execute("history_add all=Double experience caps enabled")
Execute("history_add experience=Double experience caps enabled")
  </send>
  </trigger>
</triggers>

<aliases>
 <alias
 match="eqlist"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>Execute("eql")</send>
 </alias>
 <alias
 match="eqlist *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>Execute("eql %1")</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="eql"
 enabled="y"
 send_to="2"
 sequence="100"
 >
 <send>The eqlist command is a powerful tool you can use to manage equipment sets.
Options are:
eqlist help - This help screen.
eqlist create &lt;name&gt; &lt;container&gt; [mode] - Make an equipment set with specified name, container and mode
eqlist mode mode - change the global mode. Possible modes are: Meticulous, fast, lightning.
eqlist mode set mode change the mode for a set.
eqlist delete &lt;name&gt; - Delete an equipment set
eqlist clear - clear/delete all your sets.
eqlist list - List your current equipment sets
eqlist show &lt;set name&gt; - Show eq in a given set
eqlist wear &lt;name&gt; - Wear a set
eqlist remove &lt;name&gt; - Remove/unwear all items from a set 
eqlist move &lt;name&gt; &lt;new_container&gt; - moves a set from one container to another (including storage) make sure that if you're moving from a bag or another object it is in your inventory as this does not check for errors and could mess up things badly. If this happens, use the eqlist change command to change it to the container that it was originally in.
eqlist export - export your sets to a backup file.
eqlist import - import sets from backup.
To update a set, recreate it. It will just replace itself.
Note about containers: the container can either be something on your inventory or the word &lt;storage&gt; which puts a set in your storage locker. For storage locker sets, you'll need to be in recall.
Important note about tensor disks and lightning mode: If you are using tensor disks make sure that you are using tensor as the container name and not any shortened word such as t, tens, or any other keywords such as disk or floating. This is important due to lightning mode checks.
For more information about eqlists, read the eqlist section of the mushclient readme file.
</send>
 </alias>
</aliases>
<aliases>
 <alias
 script="eqlf"
 match="eql *"
 enabled="y"
 sequence="100"
 >
 </alias>

 <alias
 script="eqlf"
 match="eqlist *"
 enabled="y"
 sequence="100"
 >
 </alias>

</aliases>
<aliases>
 <alias
 match="eqlt"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>if pose~="stand" then
Send("stand")
end
Send("insult -all | prefix eqlc")</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="md5 *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>Note(md5f("%1"))</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="zrecast"
 enabled="y"
 send_to="12"
 sequence="1"
 >
 <send>
recast_options()
</send>
 </alias>
 <alias
 match="zrecast *"
 enabled="y"
 sequence="1"
 script="recastparse"
 >
 <send></send>
 </alias>

 <alias
 match="hotk*"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>display_accelerator_list()</send>
 </alias>

 <alias
 match="accelerators*"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>display_accelerator_list()</send>
 </alias>

 <alias
 match="filters"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>display_filters()</send>
 </alias>
 <alias
 match="filter"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>display_filters()</send>
 </alias>
 <alias
 match="filter *"
 enabled="y"
 sequence="100"
 script="filterparse"
 send_to="12"
 >
 <send>
</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="strend"
 enabled="y"
 sequence="100"
send_to="12"
 >
 <send>Note("matched "..s_found.." uuids, with "..s_errors.." errors.")
s_found=0
s_errors=0</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="strcheck"
 enabled="y"
 sequence="100"
send_to="14"
 >
 <send>require "wait"
wait.make(function()
txt={}
s_errors=0
s_found=0
table.insert(txt,"cast.txt")
table.insert(txt,"align.txt")
table.insert(txt,"age.txt")
table.insert(txt,"enchant.txt")
table.insert(txt,"enchanted.txt")
table.insert(txt,"mobwear.txt")
table.insert(txt,"hit.txt")
table.insert(txt,"hide sneak.txt")
table.insert(txt,"hpregen.txt")
table.insert(txt,"luck.txt")
table.insert(txt,"misc.txt")
table.insert(txt,"thief.txt")
table.insert(txt,"saves.txt")
table.insert(txt,"sell.txt")
table.insert(txt,"size.txt")
table.insert(txt,"spc.txt")
table.insert(txt,"tank.txt")
table.insert(txt,"stats.txt")
f_uuids={}
found=0
errors=0
s_uuids={}
dir="c:/uri/eq/sets/"
for i in pairs(txt) do
file=io.input(dir..txt[i])
line=file:read("*l") -- read one line
while line do -- if not end of file (EOF)
str=string.match(line,"(%w+)%.")
if str~=nil then
table.insert(f_uuids,str)
str=nil
end
line=file:read ("*l") -- read one line
end
file:close()
end
Note("Total: "..#f_uuids.." uuids in files.")
Execute("stll -head -insult | prefix storecheck")
wait.time(2);
Execute("stll -neck -insult | prefix storecheck")
wait.time(2);
Execute("stll -arms -insult | prefix storecheck")
wait.time(2);
Execute("stll -wrist -insult | prefix storecheck")
wait.time(2);
Execute("stll -hands -insult | prefix storecheck")
wait.time(2);
Execute("stll -finger -insult | prefix storecheck")
wait.time(2);
Execute("stll -on_body -insult | prefix storecheck")
wait.time(2);
Execute("stll -about -insult | prefix storecheck")
wait.time(2);
Execute("stll -waist -insult | prefix storecheck")
wait.time(2);
Execute("stll -legs -insult | prefix storecheck")
wait.time(2);
Execute("stll -feet -insult | prefix storecheck")
wait.time(2);
Execute("stll -held -insult | prefix storecheck")
wait.time(2);
Execute("stll -shield -insult | prefix storecheck")
wait.time(2);
Execute("stll -weapon -insult | prefix storecheck")
end)
</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="exm"
 enabled="y"
 group="Exp mark"
 send_to="12"
 sequence="100"
 >
 <send>
if (expInfo.exp==0 or expInfo.exp==nil) then
Note("Warning! Your xp prompt isn't available yet! Not enableing exp mark.")
Sound(sdir.."luaaudio/error.ogg")
return -1
end-- prompt check

if not exm then exm = {} end
if not exm.events then exm.events = {} end
if not exm.events.leveled then exm.events.leveled = {} end
if not exm.events.microleveled then exm.events.microleveled = {} end
-- This may be slightly buggy
if not exm.status then
require "lua_datetime"
require "lua_convert"
exm.status=true
-- Set exp marking start time for calculations later...
exm.starttime = os.time()
--set total exp gathered value
exm.markedTotal=expInfo.exp
exm.events.leveled.mageExp=0
exm.events.microleveled.mageExp=0
exm.events.leveled.clericExp=0
exm.events.microleveled.clericExp=0
exm.events.leveled.thiefExp=0
exm.events.microleveled.thiefExp=0
exm.events.leveled.warriorExp=0
exm.events.microleveled.warriorExp=0
exm.events.leveled.necromancerExp=0
exm.events.microleveled.necromancerExp=0
exm.events.leveled.druidExp=0
exm.events.microleveled.druidExp=0
exm.events.practExp=0
exm.events.giftExp=0
exm.events.deathExp=0

Note("Exp mark enabled.")
Note("To disable it, type exm off")
Note("To get a detailed report, type exm report.")
Sound(sdir.."luaaudio/on.ogg")
elseif exm.status then -- exp mark is already enabled, report
hExpMarkHandle()
end
</send>
 </alias>
<alias
match="^avexm$"
regexp="y"
 enabled="y"
 group="Exp mark"
send_to="12"
 sequence="100"
 >
<send>
hExpMarkHandle(nil,nil,nil,nil,nil,true)
</send>
</alias>
<alias
match="^exm (?:rep|repo|repor|report)$"
regexp="y"
 enabled="y"
 group="Exp mark"
send_to="12"
 sequence="100"
 >
<send>
if not exm.status then
Note("Exp Marking is currently disabled. Nothing to report.")
else
hExpMarkHandle(nil,false,nil,true)
end
</send>
</alias>

 <alias
 match="exm off"
 enabled="y"
 group="Exp mark" send_to="12"
 sequence="100"
 >
 <send>if not exm then exm = {} end
if not exm.status then
Note("You're not currently exp marking. Type exm to start.")
else
hExpMarkHandle()
Note("Exp marking disabled.")
Sound(sdir.."luaaudio/off.ogg")
exm = { }
end</send>
 </alias>
  <alias
   match="^bra(|g) (\w*) (mark|exm|marked|expgained|explost)"
   enabled="y"
   group="Exp mark"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if exm.status then -- exp marking enabled
hExpMarkHandle("%2")
else
Note("You're not currently exp marking (try exm), nothing to brag about.")
end
</send>
  </alias>

  <alias
   match="^exm settime (\d*) (\d*) (\d*)$"
   enabled="y"
   group="Exp mark"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>-- test alias to set the time for exp mark
-- 1st arg should be the number of hours to add to the exp mark clock
-- 2nd arg should be the number of minutes to add to the exp mark clock
-- 3rd arg should be the number of seconds to add to the exp mark clock
if not exm.status then
Note("Error, exp marking not enabled... starting...")
Execute("exm")
Note("Continueing...")
Execute("exm settime %1 %2 %3")
else -- exp mark is enabled
if tonumber("%1") >= 1 then
local hourstosub = tonumber("%1")*3600 -- multiply the number of hours we're supposed to add to the clock (which really means subtract from the starting time) by the number of seconds in an hour
exm.starttime = exm.starttime-hourstosub
end
if tonumber("%2") >=1 then
local minstosub = tonumber("%2")*60
exm.starttime = exm.starttime-minstosub
end
if tonumber("%3") >=1 then
local secstosub = tonumber("%3")
exm.starttime=exm.starttime-secstosub
end
Note("Ok, %1 hours, %2 minutes, and %3 seconds added to the exp mark clock.")
end</send>
  </alias>
</aliases>

<aliases>
 <alias
 match="goldlog"
 enabled="y"
 sequence="100"
send_to="14"
 >
 <send>if(goldlog==1) then
goldlog=0
Note("gold log is off")
else
goldlog=1
Note("gold log is on")
end</send>
 </alias>
</aliases>
<aliases>
 <alias
 match="bawa"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>bwithdraw=1
PSend("gold")</send>
 </alias>
</aliases>


<!-- Ping timer and ping/pong handlers - for lag estimation.
This should run continuously in the background, sending a 'ping'
command every few seconds (15 is recommended.)  The server will
send back a '*pong*', to which we should response with 'pang'.
This allows both the client and server get lag estimates.
We use send_to target 13 (immediate send to world) to avoid
command queue lag and ensure that the turnaround time is as
accurate as possible.

Note that the server processes ping/pong/pang out of band at
the socket layer, before parsing.  This means that character
lag will not affect the ping time.  The only case where this
isn't true is when the server side command queue is completely
overloaded; in that case, the server stops looking at new
socket data until the queue mostly clears.  As long as people
don't grossly spam the server, this shouldn't be a problem. -->

<timers>
  <timer name="pingtimer" enabled="n" second="20" offset_second="20" send_to="13">
<send>ping
</send>
  </timer>
</timers>

<triggers>
  <trigger
   enabled="y"
   match="^\*pong\*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="13"
   sequence="100"
  >
<send>pang
</send>
  </trigger>

  <trigger
   enabled="y"
   match="^\*pingtime (\d+)\*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
    <send>
      server_estimated_lag = tonumber("%1")
      if server_estimated_lag &lt; 999.5 then
        recent_lag = (math.floor(server_estimated_lag+0.5)).." ms"
      elseif server_estimated_lag &lt; 9999.5 then
        recent_lag = (math.floor(server_estimated_lag/10+0.5)/100).." s"
      else
        recent_lag = (math.floor(server_estimated_lag/100+0.5)/10).." s"
      end
    </send>
  </trigger>
</triggers>

<aliases>
  <alias
  match="ping"
  enabled="y"
  send_to="12"
  sequence="100"
  >
    <send>
      -- show only our estimated local lag
      Note("Lag: "..recent_lag)
    </send>
  </alias>

  <alias
  match="lag"
  enabled="y"
  send_to="12"
  sequence="100"
  >
    <send>
      -- show our estimated local lag, as well as server estimates.
      Note("Lag: "..recent_lag)
      Send("lag -client")
    </send>
  </alias>

  <alias
  match="brag * lag"
  enabled="y"
  send_to="12"
  sequence="100"
  >
    <send>
      -- brag our estimated local lag to the given channel
      lagbrag="%1"
      Send(lagbrag.." I currently have a connection lag of "..recent_lag..".")
    </send>
  </alias>
</aliases>

<!-- End ping timer code -->


<aliases>
 <alias
 match="sim *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>Simulate("%1\\r\\n")</send>
 </alias>
 <alias
 match="acs"
 enabled="y"
 sequence="100"
 >
 <send>ach | grep Yes | wc
ach | grep No | wc</send>
 </alias>
 <alias
 match="zv"
 enabled="y"
   send_to="12"
 sequence="100"
 >
 <send>Note("mush-z "..GetVariable("version"))</send>
 </alias>
 <alias
 match="licrnd"
 enabled="y"
 sequence="100"
 >
 <send>look in ?corpse ground -insult -random | prefix mzrandom</send>
 </alias>
 <alias
 match="grl"
 send_to="12"
 enabled="y"
 sequence="100"
 >
 <send>
if string.lower(leader) == string.lower(gs("me")) then
 Note("You are the current group leader.")
else
 Note(leader.." is the current group leader.")
end
</send>
 </alias>
</aliases>

<aliases>
 <alias
 match="hunt *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>str="%1"
PSend("scan | grep "..string.lower(str))
PSend("scan | grep "..string.upper(string.sub(str,1,1))..string.sub(str,2,#str))</send>
 </alias>
 <alias
 match="dc *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>str="%1"
PSend("deed | grep "..string.lower(str))
PSend("deed | grep "..string.upper(string.sub(str,1,1))..string.sub(str,2,#str))</send>
 </alias>

 <alias
 match="huk"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>str="$k"
PSend("scan | grep "..string.lower(str))
PSend("scan | grep "..string.upper(string.sub(str,1,1))..string.sub(str,2,#str))</send>
 </alias>

 <alias
 match="going"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>lazymoving=1
PSend("look")
</send>
 </alias>
<alias
match="*"
enabled="y"
send_to="12"
sequence="100"
>
 <send>way="%1"
if (ways[way]~=nil) then
PSend("recall")
PSend("way "..ways[way])
else
Note("unknown waypoint: Waypoints you can use are "..table.concat(ways2, ", "))
end
</send>
</alias>
<alias
 match="_sleep"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
if (grouped==1) then
PSend("rest")
else
PSend("sleep")
end
</send>
</alias>
<alias
 match="stand"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
prevpose="stand"
PSend("stand")
</send>
</alias>
<alias
 match="!rt *"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
t="%1"
item="%2"
t[item]=nil
</send>
</alias>
<alias
 match="nsp"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
for i,v in pairs(rct) do
if v==true then
Note(i)
end
end
</send>
</alias>
<alias
 match="gnsp"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
</send>
</alias>

<alias
 match="!recast"
 enabled="y"
 send_to="12"
 sequence="100"
 >
<send>
if (cspells==0) then
cspells=1
Note("recast on.")
return
end
if (cspells==1) then
cspells=0
Note("recast off.")
return
end
</send>
</alias>
</aliases>
<aliases>
 <alias
 match="wi *"
 enabled="y"
 sequence="100"
 >
 <send>var hit %1
wield %1</send>
 </alias>
<alias
match="!help"
enabled="y"
sequence="100"
send_to="2"
>
<send>
Welcome to the group bots!
For now, the following commands are available.
!job &lt;healer, blaster, hitter or tank&gt; sets your own job.
!recast toggles whether you will recast tank and hitters falling spells.
Note that the healer job will always try to cast heal, and area when requested.
The blaster spell has to be indicated with the !blast command.
</send>
</alias>
<alias
match="!blast *"
enabled="y"
sequence="100"
send_to="14"
>
<send>blasting="%1"
Note("Blasting set to %1.")
--PSend("sub I will now use "..blasting.." to blast.")
</send>
</alias>
<alias
match="!job *"
enabled="n"
sequence="100"
send_to="14"
>
<send>
if nobot then
Note("sorry, bots are disabled.")
return
end
if ("%1"=="healer") then
job="healer"
--PSend("sub Job set to healer.")
Note("You are now a healer.")
blasting=""
return
elseif ("%1"=="areaman") then
job="areaman"
--PSend("sub I am now the areaman of the group.")
Note("You are now the area man.")
blasting=""
return

elseif ("%1"=="none") then
job="none"
Note("Bots disabled.")
--PSend("sub bots disabled.")
return
elseif ("%1"=="") then
Note("Job is currently set to "..job)
return
elseif ("%1"=="healblast") then
job="healblast"
--PSend("sub Job set to blaster healer.")
Note("You are now a blaster healer, use the !blast spellname command to set the blasting spell you want to use.")
blasting="greater fireball"
--PSend("sub I will use "..blasting.." to blast.")
return
elseif ("%1"=="blaster") then
Note("You are now a blaster, use the !blast spellname command to set the blasting spell you want to use.")
job="blaster"
--PSend("sub job set to blaster.")
blasting="greater fireball"
PSend("sub I will use "..blasting.." to blast.")
return
elseif ("%1"=="tank") then
if (kskills["tanking"]==1) then
PSend("tank | prefix tankon")
Note("You are now a proper tank.")
else
notank=1
Note("You are now a tank, even though you don't know the skill, but...")
if (kskills["rescue"]==1) then
Note("You know rescue. good.")
else
Note("You don't even know rescue! You can't tank!")
--Send("sub I can't tank, I don't know rescue.")
return
end --res
end --tanking
job="tank"
--PSend("sub job set to tank.")
if (kskills["defensivefighting"]==1) then
PSend("def | prefix tankon")
else
Note("Well you dont know defensive fighting, as a tank you should know it, but oh well. Go learn it.")
end
return
elseif ("%1"=="hitter") then
job="hitter"
--PSend("sub job set to hitter.")
zerking=0
PSend("tank | prefix tankoff")
PSend("def | prefix tankoff")
assisting=0
Note("You are now a hitter. Use the !zerk command to configure whether you want to berserk during battles. Note that the hitter can stab if someone types gt stab mobname, and it will switch weapons after stabbing. for that, the variables $hit and $stab have to be set to the name to the weapon you're gonna use I.e: var hit sword, var stab dagger. It will also rewield the $hit weapon after disarmed.")
return
else
Note("Unknown job, type !help for details.")
end
</send>
</alias>
<alias
enabled="y"
match="!zerk"
sequence="100"
send_to="14"
>
 <send>if (zerk==1) then
zerk=0
Note("You will not zerk in battles.")
return
end
if (zerk==0) then
zerk=1
Note("You will zerk in battles.")
return
end
</send>
</alias>
 <alias
 match="inv"
 enabled="y"
 sequence="100"
 >
 <send>inv | prefix invcheck
abort | prefix invcheck</send>
 </alias>
 <alias
 match="i"
 enabled="y"
 sequence="100"
 >
 <send>inv | prefix invcheck
abort | prefix invcheck</send>
 </alias>
 <alias
 match="grm"
 enabled="y"
 sequence="100"
send_to="14"
 >
<send>
PSend("gr | prefix groupm")
require "wait"
wait.make(function()
wait.time(0.8)
if (issues~=1) then
Note("No one in the group seems to be in trouble.")
end
issues=0
end)
 </send>
 </alias>
</aliases>
<aliases>

 <alias
 match="sl* -f*"
 enabled="y"
send_to="14"
 sequence="100"
 >
 <send>sleep | prefix force</send>
 </alias>
 <alias
 match="redo"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
   Note("reloading...")
   ppi.unload()
   ppi.init()
   startup_clear_working_vars()
   soundfile_init()
   resetvol()

   jli=1
   DoAfterSpecial(12, 'jli=0', 12)
   SendNoEcho("/show |prefix getContext:") -- Check for current context first instead of calling login
 </send>
 </alias>
 <alias
 match="reloadaudio"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("reloading audio...")
ppi.unload()
ppi.init()
soundfile_init()
resetvol()
config_update_sync("areamusic")
config_update_sync("ambience")
</send>
 </alias>

 <alias
 match="fixfix"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("reloading")
DoAfterSpecial(1,"UnloadPlugin('553a883096da345ce6897740')","14")
DoAfterSpecial(2,"ReloadPlugin('553a883096da345ce6897740')","14")
</send>
 </alias>
 <alias
 match="scm reset"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("Counters reset.")
scm_reset()
</send>
 </alias>
 <alias
 match="scm"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("Counters since "..counters.date)
Note("You have been hit "..counters.hits.." times, dodged "..counters.dodge..", and parried "..counters.parry..". Which means you avoided "..math.floor((counters.parry+counters.dodge)/(counters.hits+counters.parry+counters.dodge)*100).."percent of hits.")
Note("You attacked "..counters.enemyhits.." times. Mobs dodged "..counters.theydodge..", and parried "..counters.parryc..". "..math.floor((counters.parryc+counters.theydodge)/(counters.enemyhits+counters.parryc+counters.theydodge)*100) .."percent of your attacks avoided.")
Note("Your armor absorbed "..counters.absorb.." hits.")
Note("You've killed "..counters.kills.." mobs this session, and fled "..counters.flee.." times.")
Note("You've casted a total of "..counters.cast.." spells.")
Note("You have disarmed a total of "..counters.disarm.." mobs.")
if counters.rescue~=0 then
if counters.frescue~=0 then
Note("You have rescued "..counters.rescue.." times, and failed "..counters.frescue.." times!")
else
Note("You have rescued "..counters.rescue.." times.")
end
end
Note("You stole a total of "..counters.steal.." gold this session.")
Note("You became better "..counters.betterats.." times.")
Note("You got "..counters.teeth.." necromancer teeth, and shattered "..counters.bteeth..".")
Note("To reset the counters, type scm reset.")
</send>
 </alias>
 <alias
 match="rank *"
 enabled="y"
 sequence="100"
 >
 <send>skill | grep %1
spell | grep %1</send>
 </alias>
 <alias
 match="re2"
 enabled="y"
 sequence="100"
 >
 <send>var $res $v2
rescue $v2</send>
 </alias>
 <alias
 match="re3"
 enabled="y"
 sequence="100"
 >
 <send>var $res $v3
rescue $v3</send>
 </alias>
 <alias
 match="sl"
 enabled="y"
 sequence="100"
 >
 <send>sleep</send>
 </alias>
 <alias
 match="res *"
 enabled="y"
 sequence="100"
send_to="14"
 >
 <send>res="%1"
Send("res %1")</send>
 </alias>
 <alias
 match="cht"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not (pose == "stand") then
prevpose=pose
PSend("stand")
end
PSend("c "..spells["heal"].." $t")
casting=spells["heal"].." $t"
if(prevpose~="stand") then
PSend(prevpose)
prevpose="stand"
end
</send>
 </alias>
 <alias
 match="st"
 enabled="y"
 sequence="100"
 >
 <send>stand</send>
 </alias>
 <alias
 match="chv"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not (pose == "stand") then
prevpose=pose
PSend("stand")
end
PSend("c "..spells["heal"].." $v")
casting=spells["heal"].." $v"
if(prevpose~="stand") then
PSend(prevpose)
prevpose="stand"
end
</send>
 </alias>
 <alias
 match="tak"
 enabled="y"
 sequence="100"
 >
 <send>target $k</send>
</alias>
 <alias
 match="stg *"
 enabled="y"
 sequence="100"
 >
 <send>
storage get %1
</send>
</alias>

 <alias
 match="stll *"
 enabled="y"
 sequence="100"
 >
 <send>
storage llist %1
</send>
</alias>
 <alias
 match="stp *"
 enabled="y"
 sequence="100"
 >
 <send>
storage put %1
</send>
</alias>
 <alias
 match="cmk"
 enabled="y"
 sequence="100"
 >
 <send>c m $k</send>
 </alias>
 <alias
 match="tarn"
 enabled="y"
 sequence="100"
 >
 <send>tar noone</send>
 </alias>
 <alias
 match="cn"
 enabled="y"
 sequence="100"
 >
 <send>condition</send>
 </alias>
 <alias
 match="tav"
 enabled="y"
 sequence="100"
 >
 <send>target $v</send>
 </alias>
 <alias
 match="tnl"
 enabled="y"
 sequence="100"
 >
 <send>train | prefix tnl | grep each
level | prefix tnl</send>
 </alias>

 <alias
 match="mapping"
 enabled="y"
 send_to="14"
 sequence="100"
 >
<send>
if (map==0) then
map=1
Note("map on.")
Sound(sdir.."luaaudio/on.ogg")
elseif (map==1) then
map=0
Note("map mode off.")
Sound(sdir.."luaaudio/off.ogg")
end
</send>
</alias>
 <alias
 match="stealth"
 enabled="y"
 send_to="14"
 sequence="100"
 >
<send>
if (stealth==0) then
stealth=1
Note("Stealth mode on.")
Sound(sdir.."luaaudio/on.ogg")
elseif (stealth==1) then
stealth=0
Note("Stealth mode off.")
Sound(sdir.."luaaudio/off.ogg")
end
</send>
</alias>
 <alias
 match="rev"
 enabled="y"
send_to="14"
 sequence="100"
 >
 <send>
PSend("rescue $v")
res="$v"
</send>
 </alias>
 <alias
 match="res* *"
 enabled="y"
send_to="14"
 sequence="100"
 >
 <send>
PSend("res%1 %2")
res="%2"
</send>
 </alias>
 <alias
 match="rt"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
if not k_maxhp or not k_maxmana or not k_maxmove then
Note("No prompt available yet.")
return -1
end
Execute("show regen | prefix mzscr:")</send>
 </alias>
 <alias
 match="playsound *"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
Sound(sdir.."%1.ogg")
</send>
 </alias>
 <alias
 match="cn *"
 enabled="y"
 sequence="100"
 >
 <send>condition %1</send>
 </alias>
 <alias
 match="tnl *"
 enabled="y"
 sequence="100"
 >
 <send>level | grep %1</send>
 </alias>
 <alias
 match="cnk"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
Execute("tts_stop")
end
Execute("condition $k")</send>
 </alias>
 <alias
 match="tnp"
 enabled="y"
 sequence="100"
 >
 <send>show cost practice|prefix practnp:
</send>
 </alias>
 <alias
 match="cnt"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>if (gs("tts") == true) then
Execute("tts_stop")
end
Execute("condition $t")</send>
 </alias>





 <alias
 match="u"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("u")
 </send>
 </alias>

 <alias
 match="d"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("d")
 </send>
 </alias>

 <alias
 match="n"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("n")
 </send>
 </alias>

 <alias
 match="s"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("s")
 </send>
 </alias>

 <alias
 match="e"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("e")
 </send>
 </alias>

 <alias
 match="w"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("w")
 </send>
 </alias>

 <alias
 match="ne"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("ne")
 </send>
 </alias>

 <alias
 match="se"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("se")
 </send>
 </alias>

 <alias
 match="nw"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("nw")
 </send>
 </alias>

 <alias
 match="sw"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
sneakwalk("sw")
 </send>
 </alias>

 <alias
 match="bw"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
if (gs("tts") == true) then
if gs("imove") then Execute("tts_stop") end
if (map==1) then
AppendToNotepad("map", "backward;")
end
PSend("backward")
end
 </send>
 </alias>





 <alias
 match="sacc"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>if (pose ~= "stand") then
PSend("stand")
Execute("sac corpse")
else
Execute("sac corpse")
end</send>
 </alias>
 <alias
 match="sant"
 enabled="y"
 sequence="100"
send_to="12"
 >
 <send>Execute("c sanc $t")</send>
 </alias>
 <alias
 match="lbk"
 enabled="y"
 sequence="100"
 >
 <send>c lig bolt $k</send>
 </alias>
 <alias
 match="lic"
 enabled="y"
 sequence="100"
 >
 <send>look in ?corpse</send>
 </alias>
 <alias
 match="frc *"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
PSend("friend list | grep %1")
</send>
 </alias>
 <alias
 match="(?:(?:^cur$|^cure$)|(?:^cur|^cure)\s+(\w+)$)"
 enabled="y"
 send_to="14"
regexp="y"
 sequence="100"
 >
 <send>
if not (spells["heal"]) then
Note("You do not know any healing spells. Reload your client if this message is an error.")
return -1
end

if not (pose == "stand") then
prevpose=pose
PSend("stand")
end
PSend("cast "..spells["heal"].." %1")
casting=spells["heal"].." %1"
if(prevpose~="stand") then
PSend(prevpose)
prevpose="stand"
end
</send>
 </alias>
 <alias
 script="castalias"
 match="^(?:c|ca|cas|cast) +(.+)$"
 enabled="y"
 regexp="y"
 keep_evaluating="y"
 sequence="98"
 >
 </alias>
 <alias
 match="uo *"
 enabled="y"
 sequence="100"
 >
 <send>unlock %1
open %1</send>
 </alias>
 <alias
 match="usage *"
 enabled="y"
 sequence="100"
 >
 <send>%stat %1 | grep count</send>
 </alias>

 <alias
 match="macro-abort"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>do_hard_abort()</send>
 </alias>

 <alias
 match="macro-interrupt"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>do_hard_interrupt()</send>
 </alias>

 <alias
 match="macro-stop"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>do_hard_stop()</send>
 </alias>

 <alias
 match="macro-recast"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Execute("cast "..casting)</send>
 </alias>
 <alias
 match="macro-runnotes"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>os.Execute("Notepad "..sdir.."texts/notes.txt")</send>
 </alias>
 <alias
 match="macro-runquotes"
 enabled="y"
 send_to="14"
 sequence="100"
 >
<send>os.Execute("Notepad "..sdir.."texts/quotes.txt")</send>
 </alias>
 <alias
 match="+ *"
 enabled="y"
 sequence="100"
 >
 <send>%Send $chan %1</send>
 </alias>
 <alias
 match="v *"
 enabled="y"
 sequence="100"
 >
 <send>var %1</send>
 </alias>
 <alias
 match="macro-runset *"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Note("Notepad "..sdir.."texts/sets/%1.txt")</send>
 </alias>
 <alias
 match="macro-sacc"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>require "wait"
wait.make(function()
autosac=true
PSend("get all ?corpse")
wait.time(0.5)
if (carryblock==1) then
Note("Corpse is not empty. Not sacrificing.")
else
if kskills["consume"]==1 then
Send("control all consume ?corpse")
end
if kskills["bloodsacrifice"]==1 then
Send("bloodsacrifice ?corpse")
end
if kskills["harvestbone"]==1 then
Send("harvest bone ?corpse")
end
if kskills["corpsecutter"]==1 then
Send("harvest spellcomp ?corpse")
end
if kskills["harvestbone"]==1 then
Send("harvest bone ?corpse")
end

if kskills["harvestteeth"]==1 then
Send("harvest teeth ?corpse")
else
Send("sacrifice ?corpse")
end
end
end)</send>
 </alias>
 <alias
  match="death-action"
  enabled="y"
  send_to="14"
  sequence="100"
  >
  <send>
if gs("deathaction") == true and grouped == 0 then -- just checking that deathaction is enabled and that user isn't grouped
  daccrnd=math.random(1,4)
  if (gs("deathactionspellcomp") == 3) or (gs("deathactionspellcomp") == 2 and (daccrnd == 1 or daccrnd == 3)) then
    if kskills["corpsecutter"]==1 then
      Send("harvest spellcomp ?corpse")
    end
  end-- spellcomp
  dacrnd=math.random(1,4)
  if (gs("deathactionconsume") == 3) or (gs("deathactionconsume") == 2 and (dacrnd == 1 or dacrnd == 3)) then
    if kskills["consume"]==1 then
      Send("control all consume ?corpse")
    end
  end -- consume
  dabsrnd=math.random(1,4)
  if (gs("deathactionbloodsac") == 3) or (gs("deathactionbloodsac") == 2 and (dabsrnd == 1 or dabsrnd == 3)) then
    if kskills["bloodsacrifice"]==1 then
      Send("bloodsacrifice ?corpse")
    end
  end -- bloodsac
  dasrnd=math.random(1,4)
  if (gs("deathactionsalvage") == 3) or (gs("deathactionsalvage") == 2 and (dasrnd == 1 or dasrnd == 3)) then
    if kskills["salvageequipment"]==1 then
      Send("search ?corpse")
    end
  end
  dahtrnd=math.random(1,4)
  if (gs("deathactionharvestteeth") == 3) or (gs("deathactionharvestteeth") == 2 and (dahtrnd == 1 or dahtrnd == 3)) then
    if kskills["harvestteeth"]==1 then
      Send("harvest teeth ?corpse")
    end
  end
end -- making sure deathaction is enabled
</send>
  </alias>
 
 <alias
 match="macro-sacc2"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>
autosac=true
if kskills["consume"]==1 then
Send("control all consume ?corpse")
end
if kskills["bloodsacrifice"]==1 then
Send("bloodsacrifice ?corpse")
end
if kskills["corpsecutter"]==1 then
Send("harvest spellcomp ?corpse")
end
if kskills["harvestbone"]==1 then
Send("harvest bone ?corpse")
end

if kskills["harvestteeth"]==1 then
Send("harvest teeth ?corpse")
else
Send("sacrifice ?corpse")
end</send>
 </alias>

 <alias
 match="bad *"
 enabled="y"
 sequence="100"
 >
 <send>bank deposit %1</send>
 </alias>
 <alias
 match="bada"
 enabled="y"
 send_to="14"
 sequence="100"
 >
 <send>Execute("bank deposit " .. gold)</send>
 </alias>
 <alias
 match="ga"
 enabled="y"
 sequence="100"
 >
 <send>get all</send>
 </alias>
 <alias
 match="baw *"
 enabled="y"
 sequence="100"
 >
 <send>bank withdraw %1</send>
 </alias>
 <alias
 match="ga *"
 enabled="y"
 sequence="100"
 >
 <send>get all %1</send>
 </alias>
 <alias
 match="gac"
 enabled="y"
 sequence="100"
 >
 <send>get all from ?corpse</send>
 </alias>
 <alias
 match="offset"
 enabled="y"
 sequence="100"
 >
 <send>who -level | grep offset</send>
 </alias>
 <alias
 match="opd"
 enabled="y"
 sequence="100"
 >
 <send>open door</send>
 </alias>
 <alias
 match="fa *"
 enabled="y"
 sequence="100"
 >
 <send>friend add %1</send>
 </alias>
 <alias
 match="opd *"
 enabled="y"
 sequence="100"
 >
 <send>open door %1</send>
 </alias>
 <alias
 match="opg"
 enabled="y"
 sequence="100"
 >
 <send>open gate</send>
 </alias>
 <alias
 match="opg *"
 enabled="y"
 sequence="100"
 >
 <send>open gate %1</send>
 </alias>
 <alias
 match="ph"
 enabled="y"
 sequence="100"
 >
 <send>pray here</send>
 </alias>
 <alias
 match="sk"
 enabled="y"
 sequence="100"
 >
 <send>skills | prefix skl
spells | prefix skl
uabort | prefix skl</send>
 </alias>
 <alias
 match="^p(?:i|ic|ick) +(.+)$"
 enabled="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
pick="%1"
PSend("pick %1")
</send>
 </alias>
 <alias
 match="^u(?:n|nl|nlo|nloc|nlock) +(.+)$"
 enabled="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
pick="%1"
PSend("unlock %1")
</send>
 </alias>
 <alias
 match="^(?:c|ca|cas|cast) +(?:k|kn|kno|knoc|knock) +(.+)$"
 enabled="y"
 regexp="y"
 send_to="14"
 sequence="100"
 >
 <send>
pick="%1"
</send>
 </alias>
</aliases>

<aliases>
  <alias
   match="^zplay help$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>Note("Simple Syntax: zplay path.xxx")
Note("Where path is a pointer to a file supported by Mush Z (located under worlds/alteraeon/sounds), and .xxx is the extension of the target file. For simplicity, use slashes to represent backslashes.")
Note("  Example: zplay spells/magic missile.ogg")
Note("Complex Syntax: zplay path.xxx, volume, position")
Note("Where path.xxx points to a file located under worlds/alteraeon/sounds (see above).")
Note("Volume is a number ranging from 0 to 100, where 0 is muted.")
Note("Pan is a number ranging from -100 to 100, where -100 is far left, 0 is centered, and 100 is far right.")
Note("  Example: zplay spells/magic missile.ogg, -50, 0")</send>
  </alias>
  <alias
   match="^zplay (.+\.\w+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>Sound(sdir.."%1")</send>
  </alias>
  <alias
   match="^zplay (.+\.\w+)\, ([0-9-]+)\, ([0-9]+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>ppi.play(sdir.."/%1", 0, tonumber("%2"), tonumber("%3"))</send>
  </alias>
</aliases>

<!-- Timers -->
<timers>
 <timer minute="1" name="aminutes" second="0.00" offset_second="0.00" send_to="12"
>
 <send>if not amins then amins=0 else amins=amins+1
end</send>

 </timer>
</timers>

<timers>
 <timer name="tipsTimer" enabled="y" minute="5" second="4" offset_second="0.00" send_to="12"
>
 <send>if (gs("showtips")==true) then
if #tipslines>1 then
math.randomseed(os.clock())
 s =tipslines[math.floor(MtRand()*#tipslines)+1]  -- read one line
require "wait"
wait.make(function()
Sound(sdir.."notifications/showtip.ogg")
Note("Tip!")
wait.time(1)
 print (s) -- print that line
print("Type config showtips to disable these tips.")
end)
 end
end
</send>

 </timer>
</timers>
<timers>
 <timer name="ambiencetimer" script="ambtimer" second="45.60" offset_second="0.00" >
 </timer>

 <timer name="grtimer" script="grtimer" second="2.60" offset_second="0.00" >
 </timer>
</timers>
<!-- Script -->


<script>
<![CDATA[
version=tonumber(Version())
if version>tonumber("4.91") then
SetOption ("log_script_errors", 1)
SetOption ("omit_date_from_save_files", 1)
end
PPI = require("ppi")
ppi = PPI.Load("aedf0cb0be5bf045860d54b7")
if not ppi then
  error("Dependency plugin not installed!")
end

----------------------------------------------------------------
-- Channel stuff
----------------------------------------------------------------

function chansound(channelname)
  -- Just so code doesn't get repeated...
  -- If a custom channel sound exists, this function plays it. If not, it falls back on the global
  if (FileExists(sdir.."channels/"..channelname..".ogg")==true) then
    Sound(sdir.."channels/"..channelname..".ogg")
  else
    Sound(sdir.."channels/global.ogg")
  end
end -- function

function zchnInfoParse(n,m,w)
-- for loading the channels you are connected/listening to.
-- Idea for this was to see what needs to be sent to the mud at startup.
--parse every matched trigger string into a channel.
if (w[1]==nil) then
return 0 -- no channel name
end
-- make sure the chn table has an entry:
if not chnInfo[w[1]] then chnInfo[w[1]] = {} end
--If we've made it this far we are adding channel information.
if (w[2]=="(turned off)") then -- channel is turned off
chnInfo[w[1]].disabled=true
else --channel isn't turned off
chnInfo[w[1]].disabled=false
end
-- Parse the private flag where 0 is not private, 1 is password protected, and 2 is password protected+private:
if (w[3])=="(password)" then
chnInfo[w[1]].private=1
elseif (w[3])=="(private)" then
chnInfo[w[1]].private=2
else
chnInfo[w[1]].private=0
end

return 0
end

function handlechannel(name, channelname, message, format, styles)
  -- Handles channel messages. Made so the scattered code in each channel format trig would be easier to update
  local cmsg
  lowername=string.lower(name)
  channelname=string.lower(channelname)
  if string.sub(message,1,5) ~= "nmzca" then 
    -- All the different channel formats
    if format=="verb" then
      cmsg=name .." ".. channelname .."s, ".. message
    elseif format=="verbcolen" then
      cmsg=name .." ".. channelname ..": ".. message
    elseif format=="youverb" then
      cmsg="You ".. channelname ..", ".. message
    elseif format=="youverbcolen" then
      cmsg="You ".. channelname ..": ".. message
    elseif format=="brackets" then
      cmsg="[".. channelname .."] ".. name ..": ".. message
    elseif format=="parenthesis" then
      cmsg="(".. channelname ..") ".. name ..": ".. message
    end -- format stuff
    if lowername == gs("me") or format=="youverb" or format=="youverbcolen" then -- If this is a message sent by me
      if (gs("chist") == true) then
        Execute("history_add channels=".. cmsg)
        Execute("history_add all=".. cmsg)
      end
      if (gs("chans") == 1) then -- Play sound and display message
        chansound(channelname)
        ColourNote(RGBColourToName(styles[#styles]['textcolour']), RGBColourToName(styles[#styles]['backcolour']), cmsg)
      elseif (gs("chans") == 2) then -- Play sound and speak, but don't display
        chansound(channelname)
        Execute("tts_note " ..cmsg)
      elseif (gs("chans") == 3) then -- Only play sound
        chansound(channelname)
      end
    else
      ColourNote(RGBColourToName(styles[#styles]['textcolour']), RGBColourToName(styles[#styles]['backcolour']), cmsg)
      Execute("history_add all=".. cmsg)
      Execute("history_add channels=".. cmsg)
      chansound(channelname)
    end
    if gs("comlog")==true and gs("comlogchans")==true then
      AppendToNotepad("comlog", cmsg .."\r\n")
    end
  end
end -- function


----------------------------------------------------------------
-- miscellaneous
----------------------------------------------------------------
function HandleGroundstring(name, line, wildcards, styles)
  if gs("antigroundstringspam")==true then
hashstring = wildcards[2].." "..wildcards[3]
    itemhash = utils.tohex(utils.md5(hashstring)) -- Hash the size value plus the ground string
    if (roomstuff[itemhash]==nil) then -- No entry for this item yet
      roomstuff[itemhash]={}
      roomstuff[itemhash].count=1
      roomstuff[itemhash].styles=styles
if (gs("showsize")==false) then roomstuff[itemhash].styles=wildcards[3] end
    else -- item's hash already exists in table, increase count
      roomstuff[itemhash].count=roomstuff[itemhash].count+1
    end
    DoAfterSpecial(0.3,'rstuff()',12)
  else
    styleNote(styles)
  end
end --function

function styleNote(styletable)
 for i, v in pairs(styletable) do
  ColourTell(RGBColourToName(v.textcolour), RGBColourToName(v.backcolour), v.text)
 end
 Tell("\n")
end

function update_config()
  -- This function is where you can automatically modify the config file
  -- Rename settings names, delete old ones, whatever
  -- gets run right after the settings are loaded, and right before all config options get checked for visibility
  if settings.necroondeath~=nil then
    if settings.necroondeath.status==true then
      settings.deathaction.status=true
    elseif settings.necroondeath==false then
      settings.deathaction.status=false
    end
  settings.necroondeath=nil -- get rid of it
  end -- old necro on death option exists
end -- function

function check_all_visible()
  -- This function should be called on startup
  -- It makes sure that all options that should be visible / invisible are set so.
  -- This allows devs to make config options visible / invisible depending on the status of another config option, and have such dependencies respected from startup
  -- must be run after settingtables
  for configname, tbl in pairs(settings) do
    check_visible(configname)
  end
end -- check_all_visible

function carve_rune(t, l, w)

 local r=w.rune

 if gs("runeinfo")==1 then -- extra rune info disabled
  Note(l)
  return nil
 elseif gs("runeinfo")==2 and rune[r]~=nil then -- show the rune plus affects
  r=string.format("%s \(%s\)", r, rune[r])
 elseif gs("runeinfo")==3 and rune[r]~=nil then -- Just show it's affects
  r=string.format("%s", rune[r])
 end

 if t=="carve_rune_1" then
  Note(string.format("You examine %s and start carving, and the knots and grain of the wood fall into line with the rune '%s'.", w.item, r))
  Sound(sdir.."druid/carveRuneWood"..math.random(1,3)..".ogg")
 elseif t=="carve_rune_2" then
  Note(string.format("You carve the rune '%s' into %s.", r, w.item))
  Sound(sdir.."druid/carveTotem"..math.random(1,6)..".ogg")
 elseif t=="carve_rune_3" then
  Note(string.format("You get out a pick and some other tiny enchanted tools and start chiseling on %s.  Gradually you shape the rune '%s'.", w.item, r))
  Sound(sdir.."druid/stone tiny rune.ogg")
 elseif t=="carve_rune_4" then
  Note(string.format("You get out your heavily enchanted tools and start chiseling on %s.  Gradually you shape the rune '%s'.", w.item, r))
  Sound(sdir.."druid/stone rune.ogg")
 elseif t=="carve_rune_5" then
  Note(string.format("You carefully heat a branding tool and start firebranding %s.  Gradually you shape the rune '%s'.", w.item, r))
  Sound(sdir.."druid/firebrand rune.ogg")
 elseif t=="carve_rune_6" then
  Note(string.format("You open your sewing kit and begin tailoring %s.  Following your instincts, you embroider the rune '%s'.", w.item, r))
  Sound(sdir.."druid/cloth rune.ogg")
 else
  Note(l)
 end
 --Sound(sdir.."items/get item.ogg") -- since people like the sound when carving
end

function look_runed_object(t, l, w)
 if gs("runeinfo")==1 then -- No extra rune info
  Note(l)
  return nil
 end


 local t = utils.split(w.runes, " ")
 local temp={}

 Tell("It has the following runes cut into it\: ")

 for k, r in pairs(t) do
  if rune[r] then
   if gs("runeinfo")==2 then -- Runes and affects
    table.insert(temp, string.format("%s \(%s\)", r, rune[r]))
   elseif gs("runeinfo")==3 then -- Just affects
    table.insert(temp, string.format("%s", rune[r]))
   end
  end
 end

if #temp >= 2 then -- 2 or more affects or runes, for proper structure, we need an "and"!
temp[#temp-1] = temp[#temp-1] .." and"
end
 Tell(table.concat(temp, ", "), "\r\n")
end

function rnd_left ()
  return math.random(-75, -25)
end

function rnd_offcenter ()
  offpan_val = math.random(25, 75)
  if math.random(1, 10) > 5 then
    offpan_val = offpan_val * -1
  end
  return offpan_val
end

function rnd_right ()
  return math.random(25, 75)
end

function sneakwalk(direction)
  if (gs("tts") == true) then
    if gs("imove")==true then Execute("tts_stop") end
  end
  if (map==1) then
    AppendToNotepad("map", direction .. ";")
  end
  if (stealth==1) then
    PSend("sneak " .. direction)
    return
  end
  PSend(direction)
end

function hGTimeHandle(n,m,w)
--The time value (wildcard 1) is in the unix style time. The only difference is that the epoch isn't 1 January 1970 00:00:00; the game time epoch is every day at midnight. Seconds are not counted either. so, for something like 13:00 (01:00 PM) their should be around 780 minutes. I wish there was a way to get the time and date by calculating that also. At least this system will never see the year 2038 problem any time soon if the total is added because it's calculating minutes, not seconds.
local total=tonumber(w[1])
if (total==0) then --reset to 00:00 (12:00 AM).
gTime.hours=0
gTime.minutes=0
end
gTime.hours=0
while (total>=60) do --find the hours
total=math.floor(total-60)

gTime.hours=math.floor(gTime.hours+1) -- add the hours to another variable every time this while loop cycles. May do for loops if they are like c style ones. I'll look into it later. We'll need this var later.
end
if (total<60 and total>0) then --get the minutes. if it's 0, that means that it has 0 minutes. 
gTime.minutes=math.floor(total)
else --it's hour:00, so put 0 minutes in.
gTime.minutes=0
end

--try to convert this 24 hour style time to something that most humans like to see:

if (gTime.hours>=12) then --Convert time 12> to PM or 0> to AM.

if (gTime.hours==12) then --leave as it is and set twelveHour to twelve or subtract 12 from the 24-hour time.
gTime.twelveHours=12
gTime.pm=true
else
gTime.twelveHours=math.floor(gTime.hours-12)
gTime.pm=true
end --leave as it is or subtract.
else

if(gTime.hours==0) then --make 12:00 AM, rather than 00:00
gTime.twelveHours=12
gTime.pm=false
end --leave at 12:00 AM
if (gTime.hours<=11 and gTime.hours) then --Make AM 12 hour time
gTime.twelveHours=gTime.hours
pm=false
end --Make AM twelve-hour time.
end --convert time 12> to PM
--call a function to run code when this function is called.
gameTime_external_code()
return 0
end --function

function k_level(n,m,w)
EnableGroup("show",1)
local micro=w[1]
local leveledStringHolder=w[3]

Sound(sdir .. "level/"..leveledStringHolder..".ogg")
if exm.status == true then
if (micro=="microlevel") then
hExpMarkHandle(nil,true,leveledStringHolder,false,true)
else
hExpMarkHandle(nil,true,leveledStringHolder,false,false)
end
end
PSend("show cost | prefix tnl")
PSend("level|prefix lvltbl:")
end --function

function hLvltbl(n,m,w)
if not expInfo.levelTBL[w[1]] then expInfo.levelTBL[w[1]] = {} end
if (w[1]=="Mage") then
expInfo.levelTBL.Mage.requirement=w[5]
elseif (w[1]=="Cleric") then
expInfo.levelTBL.Cleric.requirement=w[5]
elseif (w[1]=="Thief") then
expInfo.levelTBL.Thief.requirement=w[5]
elseif (w[1]=="Warrior") then
expInfo.levelTBL.Warrior.requirement=w[5]
elseif (w[1]=="Necromancer") then
expInfo.levelTBL.Necromancer.requirement=w[5]
elseif (w[1]=="Druid") then
expInfo.levelTBL.Druid.requirement=w[5]
end --adding required xp to level
--port exp cap:
if (tonumber(w[9])) then
k_cap=tonumber(w[9])
end
end --function

function hPracticeTbl(n,m,w)
--check to see if a practice count is defined:
if (expInfo.practices.count==nil) then
expInfo.practices.count=tonumber(w[1])
return 0
end
--now with the new value:
if (expInfo.practices.count>=0) then
--Pass the new practice count to verify.
practiceGain(tonumber(w[1]))
return 0
end

end

function practiceGain(newCount)
--check for it to be a real practice:

if(is_practice(expInfo.practices.count,newCount)==-1) then
return -1
end
expInfo.practices.count=expInfo.practices.newCount
classtnl="practice"
exptnl=praccost
Execute("tnp")
if (exm.status==true) then
hExpMarkHandle(nil,true,"pract")
  PSend("show cost practice|prefix praccost:")
end
end

function is_practice(oldCount,newCount)
if (oldCount==(newCount-1)) then
return 0
else
return -1
end
end


function hExpMarkHandle(bragTo,add,event,report,micro,shortReport,hourRefresh,quiet)
--check to see if the variables are set.
if not exm.status then
if not quiet then Note("You are not marking.") end
return -1
end
--if nothing is going to be tract.
if not add then
--set time variables
  local marksecs =os.difftime(os.time(), exm.starttime) -- calculate seconds since we started marking
  local totalsecs=marksecs--minimize rounding error by using the raw seconds.
 local markmins, marksecs = sec2min(marksecs)

 local markhours=math.floor(markmins/60) -- calculate how many hours total
--add the tracked lost xp:
local added=math.floor(exm.events.leveled.mageExp+exm.events.microleveled.mageExp+exm.events.leveled.clericExp+exm.events.microleveled.clericExp+exm.events.leveled.thiefExp+exm.events.microleveled.thiefExp+exm.events.leveled.warriorExp+exm.events.microleveled.warriorExp+exm.events.leveled.necromancerExp+exm.events.microleveled.necromancerExp+exm.events.leveled.druidExp+exm.events.microleveled.druidExp+exm.events.practExp+exm.events.deathExp+exm.events.giftExp)
--get a final sum of the calculated exp.
local total=math.floor(expInfo.exp-exm.markedTotal+added)
--The user requesting a detailed report
if (report==true) then

Note("Experience marked detailed report since started:")
Note ("You have gained a total of "..ntrunk(total).." experience this session.")
	if (exm.events.microleveled.mage) then Note("You have microleveled Mage "..ntrunk(exm.events.microleveled.mage).." times.") end
if (exm.events.leveled.mage) then Note("You have leveled Mage "..exm.events.leveled.mage.." times.") end
if (exm.events.microleveled.mage or exm.events.leveled.mage) then Note("You have spent a total of "..ntrunk(exm.events.leveled.mageExp+exm.events.microleveled.mageExp).." experience microleveling and/or leveling Mage this session.") end

if (exm.events.microleveled.cleric) then Note("You have microleveled Cleric "..ntrunk(exm.events.microleveled.cleric).." times.") end
if (exm.events.leveled.cleric) then Note("You have leveled Cleric "..exm.events.leveled.cleric.." times.") end
if (exm.events.microleveled.cleric or exm.events.leveled.cleric) then Note("You have spent a total of "..ntrunk(exm.events.leveled.clericExp+exm.events.microleveled.clericExp).." experience leveling and/or microleveling Cleric this session.") end

if (exm.events.leveled.thief) then Note("You have leveled Thief "..exm.events.leveled.thief.." times.") end
if (exm.events.microleveled.thief) then Note("You have microleveled Thief "..exm.events.microleveled.thief.." times.") end
if (exm.events.microleveled.thief or exm.events.leveled.thief) then Note("You have spent a total of "..ntrunk(exm.events.leveled.thiefExp+exm.events.microleveled.thiefExp).." experience leveling and/or microleveling Thief this session.") end

if (exm.events.leveled.warrior) then Note("You have leveled Warrior "..exm.events.leveled.warrior.." Times.") end
if (exm.events.microleveled.warrior) then Note("You have microleveled Warrior "..exm.events.microleveled.warrior.." times.") end
if (exm.events.microleveled.warrior or exm.events.leveled.warrior) then Note("You have spent a total of "..ntrunk(exm.events.leveled.warriorExp+exm.events.microleveled.warriorExp).." experience leveling and/or microleveling Warrior this session.") end

if (exm.events.leveled.necromancer) then Note("You have leveled Necromancer "..exm.events.leveled.necromancer.." times.") end
if (exm.events.microleveled.necromancer) then Note("You have microleveled Necromancer "..exm.events.microleveled.necromancer.." times.") end
if (exm.events.microleveled.necromancer or exm.events.leveled.necromancer) then Note("You have spent a total of "..ntrunk(exm.events.leveled.necromancerExp+exm.events.microleveled.necromancerExp).." experience leveling and/or microleveling Necromancer this session.") end

if (exm.events.leveled.druid) then Note("You have leveled Druid "..exm.events.leveled.druid.." times.") end
if (exm.events.microleveled.druid) then Note("You have microleveled Druid "..exm.events.microleveled.druid.." times.") end
if (exm.events.microleveled.druid or exm.events.leveled.druid) then Note("You have spent a total of "..ntrunk(exm.events.leveled.druidExp+exm.events.microleveled.druidExp).." experience leveling and/or microleveling Druid this session.") end
if (exm.events.pract) then Note("You have trained "..exm.events.pract.." practices.") end
if (exm.events.gift) then Note("You have gifted "..exm.events.gift.." newbies.") end
if (exm.events.death) then Note("You have died "..exm.events.death.." times this session, and you have lost a total of "..ntrunk(exm.events.deathExp).." experience do to deaths.") end
if (added>1) then Note("You have used and or lost a total of "..ntrunk(added).." experience this session.") end
if (added==0) then Note("You have not lost or spent experience since you started marking.") end

return 0
end --report
--calculate avg
  local exppermin = math.floor(total/(totalsecs/60)) -- calculate exp per minute
  if markhours >=1 then -- If we've been marking for 1 hour or more
    expperhour = math.floor(total/markhours) -- calculate average exp per hour
     markmins = markmins-(markhours*60) -- convert total minutes to minutes since last hour started
  end

--lock the exp avg per hour to prevent the exp avg per hour from going up if it is before two hours
if not exm.hourExp then exm.hourExp=0 end
--only execute if the timer is at one hour

if markhours==1 then
--only copy the variables if they have 0 xp set.
if exm.hourExp == 0 then
exm.hourExp = expperhour
end
end
--return if the hourRefresh arg is passed because we don't need the rest of the code.
if hourRefresh==true then return 0 end
--Someone uses the alt+a macro
if (shortReport) then
  if markmins == 0 and markhours == 0 then -- Haven't been marking for 1 minute or 1 hour
    Note("No average yet, marking for " ..marksecs.." seconds.")
  elseif tonumber(markhours) >= 1 then -- Have been marking for more than one hour
    Note(ntrunk(exppermin) .." per minute, ".. ntrunk(expperhour) .." per hour. Marking for ".. markhours.. " hours, ".. markmins.. " minutes, and ".. marksecs .." seconds.")
  elseif tonumber(markhours) == 1 then -- Have been marking for 1 hour only
    Note(ntrunk(exppermin) .." per minute, ".. ntrunk(expperhour) .." per hour. Marking for ".. markhours.. " hours, ".. markmins.. " minutes, and ".. marksecs .." seconds.")
  else --between 1 minute and 1 hour
    Note(ntrunk(exppermin).. " per minute. Marking for ".. markmins .." minutes and ".. marksecs.. " seconds.")
  end
return 0
end
--printing avg exp, but not using the alt+a macro
  if markmins == 0 and markhours == 0 then -- Haven't been marking for 1 minute or 1 hour
    if not bragTo then
--print lost exp.
if (added>0) then
Note("You've been marking for " ..marksecs.." seconds, gained " ..ntrunk(total).. " experience, but you haven't been marking long enough to determine your exp per minute rate. You have used and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
--do not print the lost exp sentence if the player hasn't lost xp
      Note("You've been marking for " ..marksecs.." seconds, gained " ..ntrunk(total).. " experience, but you haven't been marking long enough to determine your exp per minute rate.")
end
    else
--if someone wants to brag
if (added>0) then
--same pattern as above
      Send(bragTo.." I have been marking for " ..marksecs.." seconds, gained " ..num2fstr(total).. " experience, but I haven't been marking long enough to determine my exp per minute rate. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.") --I plan on adding a more detailed report only when the user doesn't brag. Imo we don't need that much spam when we brag. 
else
Send(bragTo.." I have been marking for " ..marksecs.." seconds, gained " ..num2fstr(total).. " experience, but I haven't been marking long enough to determine my exp per minute rate.")
end
    end -- Haven't been marking for 1 minute or 1 hour
elseif tonumber(markhours) == 1 then --only been marking for one hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(exm.hourExp).." per hour. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(exm.hourExp).." per hour.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(exm.hourExp).." per hour. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(exm.hourExp).." per hour.")
end
    end -- marking for one hour

  elseif tonumber(markhours) > 1 then -- Have been marking for more than one hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(expperhour).." per hour. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(expperhour).." per hour.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(expperhour).." per hour. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(expperhour).." per hour.")
end
    end -- have been bragging for an hour or more
  else --between 1 minute and 1 hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute.")
end
    end
  end -- main if
  markhours = nil
  markmins = nil
  exppermin = nil
  expperhour = nil
else
--track lost xp by importing the numbers into variables
--add mage levels
if (event=="mage" and micro==false) then
if not exm.events.leveled.mageExp then exm.events.leveled.mageExp=0 end
exm.events.leveled.mageExp=math.floor(expInfo.levelTBL.Mage.requirement+exm.events.leveled.mageExp)
if not exm.events.leveled.mage then exm.events.leveled.mage=0 end
exm.events.leveled.mage=math.floor(exm.events.leveled.mage+1)

elseif (event=="mage" and micro==true) then
if not exm.events.microleveled.mageExp then exm.events.microleveled.mageExp=0 end
exm.events.microleveled.mageExp=math.floor(expInfo.levelTBL.Mage.requirement+exm.events.microleveled.mageExp)
if not exm.events.microleveled.mage then exm.events.microleveled.mage=0 end
exm.events.microleveled.mage=math.floor(exm.events.microleveled.mage+1)

--add cleric levels
elseif (event=="cleric" and micro==false) then
if not exm.events.leveled.clericExp then exm.events.leveled.clericExp=0 end
exm.events.leveled.clericExp=math.floor(expInfo.levelTBL.Cleric.requirement+exm.events.leveled.clericExp)
if not exm.events.leveled.cleric then exm.events.leveled.cleric=0 end
exm.events.leveled.cleric=math.floor(exm.events.leveled.cleric+1)

elseif (event=="cleric" and micro==true) then
if not exm.events.microleveled.clericExp then exm.events.microleveled.clericExp=0 end
exm.events.microleveled.clericExp=math.floor(expInfo.levelTBL.Cleric.requirement+exm.events.microleveled.clericExp)
if not exm.events.microleveled.cleric then exm.events.microleveled.cleric=0 end
exm.events.microleveled.cleric=math.floor(exm.events.microleveled.cleric+1)

--add thief levels
elseif (event=="thief" and micro==false) then
if not exm.events.leveled.thiefExp then exm.events.leveled.thiefExp=0 end
exm.events.leveled.thiefExp=math.floor(expInfo.levelTBL.Thief.requirement+exm.events.leveled.thiefExp)
if not exm.events.leveled.thief then exm.events.leveled.thief=0 end
exm.events.leveled.thief=math.floor(exm.events.leveled.thief+1)

elseif (event=="thief" and micro==true) then
if not exm.events.microleveled.thiefExp then exm.events.microleveled.thiefExp=0 end
exm.events.microleveled.thiefExp=math.floor(expInfo.levelTBL.Thief.requirement+exm.events.microleveled.thiefExp)
if not exm.events.microleveled.thief then exm.events.microleveled.thief=0 end
exm.events.microleveled.thief=math.floor(exm.events.microleveled.thief+1)

--add warrior levels
elseif (event=="warrior" and micro==false) then
if not exm.events.leveled.warriorExp then exm.events.leveled.warriorExp=0 end
exm.events.leveled.warriorExp=math.floor(expInfo.levelTBL.Warrior.requirement+exm.events.leveled.warriorExp)
if not exm.events.leveled.warrior then exm.events.leveled.warrior=0 end
exm.events.leveled.warrior=math.floor(exm.events.leveled.warrior+1)

elseif (event=="warrior" and micro==true) then
if not exm.events.microleveled.warriorExp then exm.events.microleveled.warriorExp=0 end
exm.events.microleveled.warriorExp=math.floor(expInfo.levelTBL.Warrior.requirement+exm.events.microleveled.warriorExp)
if not exm.events.microleveled.warrior then exm.events.microleveled.warrior=0 end
exm.events.microleveled.warrior=math.floor(exm.events.microleveled.warrior+1)

--add necromancer levels
elseif (event=="necromancer" and micro==false) then
if not exm.events.leveled.necromancerExp then exm.events.leveled.necromancerExp=0 end
exm.events.leveled.necromancerExp=math.floor(expInfo.levelTBL.Necromancer.requirement+exm.events.leveled.necromancerExp)
if not exm.events.leveled.necromancer then exm.events.leveled.necromancer=0 end
exm.events.leveled.necromancer=math.floor(exm.events.leveled.necromancer+1)

elseif (event=="necromancer" and micro==true) then
if not exm.events.microleveled.necromancerExp then exm.events.microleveled.necromancerExp=0 end
exm.events.microleveled.necromancerExp=math.floor(expInfo.levelTBL.Necromancer.requirement+exm.events.microleveled.necromancerExp)
if not exm.events.microleveled.necromancer then exm.events.microleveled.necromancer=0 end
exm.events.microleveled.necromancer=math.floor(exm.events.microleveled.necromancer+1)

--add druid levels
elseif (event=="druid" and micro==false) then
if not exm.events.leveled.druidExp then exm.events.leveled.druidExp=0 end
exm.events.leveled.druidExp=math.floor(expInfo.levelTBL.Druid.requirement+exm.events.leveled.druidExp)
if not exm.events.leveled.druid then exm.events.leveled.druid=0 end
exm.events.leveled.druid=math.floor(exm.events.leveled.druid+1)

elseif (event=="druid" and micro==true) then
if not exm.events.microleveled.druidExp then exm.events.microleveled.druidExp=0 end
exm.events.microleveled.druidExp=math.floor(expInfo.levelTBL.Druid.requirement+exm.events.microleveled.druidExp)
if not exm.events.microleveled.druid then exm.events.microleveled.druid=0 end
exm.events.microleveled.druid=math.floor(exm.events.microleveled.druid+1)

--track practices
elseif (event=="pract") then
if not exm.events.practExp then exm.events.practExp=0 end
exm.events.practExp=math.floor(expInfo.practices.requirement+exm.events.practExp)
if not exm.events.pract then exm.events.pract=0 end
exm.events.pract=math.floor(exm.events.pract+1)
--track lost xp when you die
elseif (event=="death") then
if not exm.events.deathExp then exm.events.deathExp=0 end
exm.events.deathExp=math.floor(expInfo.death+exm.events.deathExp)
if not exm.events.death then exm.events.death=0 end
exm.events.death=math.floor(exm.events.death+1)
--track lost xp while giving players newbie gifts
elseif (event=="pgift") then
if not exm.events.giftExp then exm.events.giftExp=0 end
exm.events.giftExp=math.floor(expInfo.gift+exm.events.giftExp)
if not exm.events.gift then exm.events.gift=0 end
exm.events.gift=math.floor(exm.events.gift+1)
end 

end --adding
end--function


function process_recipe()
time=2000
sitems=ritems
for i=1,ritems do
restime=time/sitems
actualtime=restime/1000
sitems=sitems-1
DoAfterSpecial(actualtime,'Sound(sdir.."brewing/ing/"..math.random(1,3)..".ogg")',12)
end
end

function storecapture(n,l,w)
if filtering==true then
if IsInTable(storefilter,w[1])==0 then
Send("storage get "..w[1])
Send("put "..w[1].." "..gs("container"))
table.insert(storefilter,w[1])
end
else
Send("storage get "..w[1])
Send("put "..w[1].." "..gs("container"))
end
end

function itemfoundtime(n,l,w)
if ecnum==0 then ecnum=1 end
containers[w[1]]=ecnum.."."..containerstocheck[1]
end

function remove_nonexistant()
if eql[act[2]].head==nil then
remeqs(cup.head)
end
if eql[act[2]].neck1==nil then
remeqs(cup.neck1)
end
if (eql[act[2]].neck1==nil and eql[act[2]].neck2==nil) then
remeqs(cup.neck2)
end
if eql[act[2]].arms==nil then
remeqs(cup.arms)
end
if (eql[act[2]].wrist1==nil and eql[act[2]].wrist2==nil) then
remeqs(cup.wrist2)
end
if (eql[act[2]].neck1==nil and eql[act[2]].neck2==nil) then
remeqs(cup.wrist2)
end
if eql[act[2]].hands==nil then
remeqs(cup.hands)
end
if (eql[act[2]].finger1==nil and eql[act[2]].finger2==nil) then
remeqs(cup.finger1)
end
if (eql[act[2]].finger1==nil and eql[act[2]].finger2==nil) then
remeqs(cup.finger2)
end
if eql[act[2]].body==nil then
remeqs(cup.body)
end
if eql[act[2]].abody==nil then
remeqs(cup.abody)
end
if eql[act[2]].waist==nil then
remeqs(cup.waist)
end
if eql[act[2]].legs==nil then
remeqs(cup.legs)
end
if eql[act[2]].feet==nil then
remeqs(cup.feet)
end
if eql[act[2]].shield==nil then
remeqs(cup.shield)
end
if eql[act[2]].wielded==nil then
remeqs(cup.wielded)
end
if eql[act[2]].held==nil then
remeqs(cup.held)
end
end

function containertime(n,l,w)
ecnum=w[1]
Send("look in "..w[1].."."..containerstocheck[1].." -insult -wieldable -wearable | prefix cc")
end

function movetime()
eql[act[2]].container=act[3]
for i,v in pairs(eql[act[2]].pieces) do
if table.contains(cup,v) then
eql.pieces[v]=act[3]
else
moveeq(v)
end
end --for
end --func

function allpieces()
for i,v in pairs(cup) do
if eql.pieces[v]~=nil then
eql.pieces[v]=eql[eql.lastset].container
end --if
end --for
end --func

function table.size(t)
sizecount=0
for i in pairs(t) do sizecount=sizecount+1
end
return sizecount
end

function wearlight()
if table.size(cup)>0 then
Send("remove all")
allpieces()
Send("put all "..eql[eql.lastset].container.." | prefix mzc")
cup={}
end --cup
if eql[act[2]].wielded~=nil then
v=eql[act[2]].wielded
if eql.pieces[v]=="storage" then
str="storage get "..v.." | prefix mzc"
Send(str)
else
container=getcontainer(v)
str="get "..v.." "..container.." | prefix mzc"
Send(str)
end
Send("wield "..v.." -force")
end --wielded
for i,v in pairs(eql[act[2]].pieces) do
if eql.cancarry<1 then
Send("wear all")
eql.cancarry=eql.maxitems-eql.items
end
if eql.pieces[v]=="storage" then
str="storage get "..v.." | prefix mzc"
Send(str)
else
container=getcontainer(v)
str="get "..v.." "..container.." | prefix mzc"
Send(str)
end
eql.cancarry=eql.cancarry-1
end --for
eql.cancarry=eql.maxitems-eql.items
Send("wear all")
Send("lecho set_worn")
end

function prevadd(n,l,w)
prevweight=prevweight+w[1]
previtems=previtems+1
end

function prevdone(n,l,w)
Note("preview found "..previtems.." items, with a weight of "..prevweight.." pounds.")
end

function weartime()
eql.removing=false
eql.coincidecount=0
if eql[act[2]].mode==3 then
--Send("score | grep carrying | prefix icheck")
eql.cancarry=8
wearlight()
return
end --mode3
if eql[act[2]].mode==2 then
for i,v in pairs(eql[act[2]].pieces) do
if table.contains(cup,v) then
eql.coincidecount=eql.coincidecount+1
end --if
end --for
if eql.coincidecount<10 then
if table.size(cup)>0 then
Send("remove all")
allpieces()
Send("put all "..eql[eql.lastset].container.." | prefix mzc")
cup={}
end --length
end --coincide
meticulouswear()
end --if mode is 2
if eql[act[2]].mode==1 then
meticulouswear()
end
Send("lecho set_worn")
end --func

function meticulouswear()
--begin
remove_nonexistant()
for i,v in pairs(eql[act[2]]) do
if i=="head" then
uuid=eql[act[2]].head
if moving then moveeq(uuid) else
if cup.head==uuid then
else
remeqs(cup.head)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." head")
else
container=getcontainer(uuid)

str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." head")
end
end
end
end
if i=="neck1" then
uuid=eql[act[2]].neck1
if moving then moveeq(uuid) else
if (cup.neck1==uuid or cup.neck2==uuid) then
else
remeqs(cup.neck1)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." neck")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." neck")
end
end
end
end
if i=="neck2" then
uuid=eql[act[2]].neck2
if moving then moveeq(uuid) else
if (cup.neck1==uuid or cup.neck2==uuid) then
else
remeqs(cup.neck2)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." neck")
else
container=getcontainer(uuid)
str=
"get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." neck")
end
end
end
end
if i=="arms" then
uuid=eql[act[2]].arms
if moving then moveeq(uuid) else
if cup.arms==uuid then
else
remeqs(cup.arms)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." arms")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." arms")
end
end
end
end
if i=="wrist1" then
uuid=eql[act[2]].wrist1
if moving then moveeq(uuid) else
if (cup.wrist1==uuid or cup.wrist2==uuid) then
else
remeqs(cup.wrist1)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." wrist")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." wrist")
end
end
end
end
if i=="wrist2" then
uuid=eql[act[2]].wrist2
if moving then moveeq(uuid) else
if (cup.wrist1==uuid or cup.wrist2==uuid) then
else
remeqs(cup.wrist2)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." wrist")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." wrist")
end
end
end
end
if i=="hands" then
uuid=eql[act[2]].hands
if moving then moveeq(uuid) else
if cup.hands==uuid then
else
remeqs(cup.hands)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." hands")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." hands")
end
end
end
end
if i=="finger1" then
uuid=eql[act[2]].finger1
if moving then moveeq(uuid) else
if (cup.finger1==uuid or cup.finger2==uuid) then
else
remeqs(cup.finger1)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." finger")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." finger")
end
end
end
end
if i=="finger2" then
uuid=eql[act[2]].finger2

if moving then moveeq(uuid) else
if (cup.finger1==uuid or cup.finger2==uuid) then
else
remeqs(cup.finger2)

if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." finger")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." finger")
end
end
end
end
if i=="body" then
uuid=eql[act[2]].body

if moving then moveeq(uuid) else
if cup.body==uuid then
else
remeqs(cup.body)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." on")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." on")
end
end
end
end
if i=="abody" then
uuid=eql[act[2]].abody
if moving then moveeq(uuid) else
if cup.abody==uuid then
else
remeqs(cup.abody)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." about")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." about")
end
end
end
end
if i=="waist" then
uuid=eql[act[2]].waist
if moving then moveeq(uuid) else
if cup.waist==uuid then
else
remeqs(cup.waist)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." waist")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." waist")
end
end
end
end
if i=="legs" then
uuid=eql[act[2]].legs

if moving then moveeq(uuid) else
if cup.legs==uuid then
else
remeqs(cup.legs)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." legs")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." legs")
end
end
end
end
if i=="feet" then
uuid=eql[act[2]].feet

if moving then moveeq(uuid) else
if cup.feet==uuid then
else
remeqs(cup.feet)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." feet")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." feet")
end
end
end
end
if i=="shield" then
uuid=eql[act[2]].shield
if moving then moveeq(uuid) else
if cup.shield==uuid then
else
remeqs(cup.shield)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wear "..uuid.." shield")
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wear "..uuid.." shield")
end 
end
end
end
if i=="wielded" then
uuid=eql[act[2]].wielded
if moving then moveeq(uuid) else
if cup.wielded==uuid then
else
remeqs(cup.wielded)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("wield "..uuid.." -force") 
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("wield "..uuid.." -force")
end
end
end
end
if i=="held" then
uuid=eql[act[2]].held

if moving then moveeq(uuid) else
if cup.held==uuid then
else
remeqs(cup.held)
if eql.pieces[uuid]=="storage" then
str="storage get "..uuid.." | prefix mzc" Send(str) Send("hold "..uuid)
else
container=getcontainer(uuid)
str="get "..uuid.." "..container.." | prefix mzc" Send(str) Send("hold "..uuid)
end
end
end
end
end --for
cup={}
--end stop copying here
end

function itemfunc(n,l,w)
uuid=w[1]
name=w[2]
if IsInTable(f_uuids,uuid)==1 then
s_found=s_found+1
else
s_errors=s_errors+1
AppendToNotepad("errors",name..", "..uuid.."\r\n")
end
end

function moveeq(piece)
oldc=eql.pieces[piece]
if oldc==eql[act[2]].container then
return
end

if oldc=="storage" then
Send("storage get "..piece.."")
else
Send("get "..piece.." "..oldc.."")
end
if eql[act[2]].container=="storage" then
Send("storage put "..piece.."")
else
Send("put "..piece.." "..eql[act[2]].container.."")
end
eql.pieces[piece]=eql[act[2]].container
end

function weareq(moving)
if moving then
oldc=eql.pieces[piece]
eql[act[2]].container=act[3]
end
end --function

function remeq(uuid)
if not removedall then Send("remove all")
removedall=true
end
if eql.pieces[uuid]==nil then
if act[2].container=="storage" then
Send("storage put "..uuid.." | prefix mzc")
else
Send("put "..uuid.." "..eql[act[2]].container.." | prefix mzc")
end
else
if eql.pieces[uuid]=="storage" then
Send("storage put "..uuid.." | prefix mzc")
else
Send("put "..uuid.." "..eql.pieces[uuid].." | prefix mzc")
end
end
end

function remeqs (uuid)
if uuid==nil then return end
Send("remove "..uuid)
if eql.pieces[uuid]==nil then
if act[2].container=="storage" then
Send("storage put "..uuid.." | prefix mzc")
else
Send("put "..uuid.." "..eql[act[2]].container.." | prefix mzc")
end
eql.pieces[uuid]=eql[act[2]].container
else
if eql.pieces[uuid]=="storage" then
Send("storage put "..uuid.." | prefix mzc")
else
Send("put "..uuid.." "..eql.pieces[uuid].." | prefix mzc")
end
end
end

function getcontainer(uuid)
if containers[uuid]==nil then
return eql.pieces[uuid]
end
return containers[uuid]
end

function eqlwear(set)
if eql.wearing then
containers={}
containerstocheck={}
if eql[act[2]].mode==3 then
end
for i,v in pairs(eql[act[2]].pieces) do
if eql.pieces[v]==nil then
eql.pieces[v]=eql[act[2]].container
end
if (eql.pieces[v]~="storage" and IsInTable(containerstocheck,eql.pieces[v])==0) then
table.insert(containerstocheck,eql.pieces[v])
end --if
end --for
if eql[act[2]].mode==3 and eql[act[2]].container~="tensor" then
container=eql[act[2]].container
Send("insult -all | prefix eqlc")
Send("lecho wearing_time")
else
if #containerstocheck>0 then
Send("lecho container_check 1")
else
container=eql[act[2]].container
Send("insult -all | prefix eqlc")
Send("lecho wearing_time")
end
end
end
end

function table.value(t,v)
for i,value in pairs(t) do
if value==v then
return i
end
end
end

function zmap(n,l,w)
act=split(w[1]," ")
if act[1]=="help" then
Execute("zmap")
elseif act[1]=="undo" then
if #curmap>=3 then
Note("removed "..curmap[#curmap].." from map.")
curmap[#curmap]=nil
else
Note("We've got an empty map, can't remove anymore.")
end
elseif act[1]=="door" then
if not mtime then
Note("You aren't creating a map right now... use zmap start to create one.")
return
end
if act[2]==nil then
Note("sintax: zmap door name")
return
else
dstr=""
for i,v in pairs(act) do
if i>1 then
dstr=dstr.." "..v
end --number
end --for
table.insert(curmap,dstr)
Note(dstr.." added to map.")
end --act2 nil
elseif act[1]=="pause" then
mtime=false
mtimep=true
Note("direction recording paused. use zmr or zmap resume to continue logging directions.")
elseif act[1]=="resume" then
if not mvtime then
if mtimep then
Note("Now recording directions again.")
mtime=true
return
end
Note("You aren't currently moving to a map!")
return
end
Note("Resuming map.")
donemap=0
mvtime=true
EnableTimer("maptimer",false)
Send(curmap[1].." | tail 1 | prefix moving")
EnableTimer("maptimer",false)
elseif act[1]=="goback" then
mback=true
donemap=0
EnableTimer("maptimer",false)
c1=os.clock()
if pose~="stand" then
Send("stand")
end
mvtime=true
adir=0
maxdir=#curmap
movemapnow()
elseif act[1]=="list" then

c,e=utils.readdir(GetInfo(67).."/maps/*.mzmap")
if(e=="File specification could not be matched") then
Note("Sorry, but no maps are currently saved.\nCopy maps to the 'worlds/alteraeon/maps' folder, or use the 'zmap start' command to create a new map.")
return e
end
assert (c,e)
for i,v in pairs(c) do
Note(utils.split(i,".")[1])
end
elseif act[1]=="go" then
mtimep=false
mback=false
mapback={}
donemap=0
EnableTimer("maptimer",false)
c1=os.clock()
if act[2]==nil then
Note("sintax: zmap go mapname")
return
else
if (FileExists(GetInfo(67).."/maps/"..act[2]..".mzmap")==true) then
dentin_dofile(GetInfo(67).."/maps/"..act[2]..".mzmap")
Send("l | head 1 | prefix mapmove")
else
Note("Map "..act[2].." doesn't seem to exist.")
end --exists
end --act2 nil

elseif act[1]=="show" then
require "tprint"
tprint(curmap)
elseif act[1]=="start" then
mtimep=true
Send("look | head 1 | prefix mapstart")
elseif act[1]=="stop" then
if not mtime then
Note("You aren't currently mapping!")
return
end
Note("OK, map stopped.")
mtime=false
require "serialize"
exf = utils.filepicker ("Choose where to save your map", "map_", "mzmap", {mzmap="MUSH-Z maps"}, true)
if not exf then Note("cancelled.") return end
local exfw=assert(io.open(exf, "w"))
exfc=serialize.save_simple(curmap)
assert (exfw:write ("curmap="..exfc))
exfw:close()
Note("map saved.")
end --if
end --function

function eqlf(n,l,w)
  act=split(w[1]," ")

  if act[1]=="help" then
    Execute("eql")

  elseif act[1] =="create" then
    eql.wearing=false
    creatingset=true
    if #act<3 then
      Note("Sintax: eqlist create <name> <container> <mode>")
      Note("possible modes are: meticulous, fast, lightning")
      Note("Meticulous: Removes piece by piece, switches piece by piece. Slowest setting.")
      Note("fast: removes all if less than 9 pieces of the set you are trying to wear coincide with the currently wearing pieces. Otherwise remove all, put all and wear piece by piece to prevent pieces with multiple locations from doing weird things.")
      Note("Lightning: Remove all, check inventory to see how many more things you can carry, wield weapon, get as many as you can, wear all. Fastest, but unreliable for certain sets.")
      return
    else
      eql.cpieces=true
      eql.removing=false
      eql.lastset=act[2]
      if act[4]==nil then
        creatingmode=eql.mode
        Note("You can also specify a mode for this set by using the words: meticulous, fast or lightning after the container.")
      else
        if IsInTable(setmodes,act[4])==1 then
          Note("using mode "..act[4])
          creatingmode=table.value(setmodes,act[4])
        else
          Note("Unknown mode. Possible modes are: Meticulous, fast, lightning.")
          Note("Meticulous: Removes piece by piece, switches piece by piece. Slowest setting.")
          Note("fast: removes all if less than 9 pieces of the set you are trying to wear coincide with the currently wearing pieces. Otherwise remove all, put all and wear piece by piece to prevent pieces with multiple locations from doing weird things.")
          Note("Lightning: Remove all, check inventory to see how many more things you can carry, wield weapon, get as many as you can, wear all. Fastest, but unreliable for certain sets.")
          return
        end --unknown mode
      end --act4nil
      if IsInTable(eql.setnames,act[2])==1 then
        Note("overwriting")
      else
        table.insert(eql.setnames,act[2])
      end
      if act[3]~="storage" then
        print(pose)
        if pose~="stand" then
          Send("stand")
        end
        Send("insult "..act[3].." | prefix ccheck")
      else
        eql[act[2]]={}
        eql[act[2]].container=act[3]
        eql[act[2]].mode=creatingmode
        eql.wearing=false
        Execute("eqlt")
        Note("set created.")
      end
    end --create has 3 length or less

  elseif act[1]=="show" then
    require "tprint"
    if #act==1 then
      tprint(eql)
    else
      if eql[act[2]]==nil then
        Note("No set by the name "..act[2].." exists.")
      else
        Note("<container> "..eql[act[2]].container)
        Note("<mode> "..setmodes[eql[act[2]].mode])
        for i,v in pairs(eql[act[2]]) do
          if i=="head" then Note("<head>"..eql[act[2]].headn) end
          if i=="neck1" then Note("<neck1>"..eql[act[2]].neck1n) end
          if i=="neck2" then Note("<neck2>"..eql[act[2]].neck2n) end
          if i=="arms" then Note("<arms>"..eql[act[2]].armsn) end
          if i=="wrist1" then Note("<wrist1>"..eql[act[2]].wrist1n) end
          if i=="wrist2" then Note("<wrist2>"..eql[act[2]].wrist2n) end
          if i=="hands" then Note("<hands>"..eql[act[2]].handsn) end
          if i=="finger1" then Note("<finger1>"..eql[act[2]].finger1n) end
          if i=="finger2" then Note("<finger2>"..eql[act[2]].finger2n) end
          if i=="body" then Note("<body>"..eql[act[2]].bodyn) end
          if i=="abody" then Note("<about_body>"..eql[act[2]].abodyn) end
          if i=="waist" then Note("<waist>"..eql[act[2]].waistn) end
          if i=="legs" then Note("<legs>"..eql[act[2]].legsn) end
          if i=="feet" then Note("<feet>"..eql[act[2]].feetn) end
          if i=="shield" then Note("<shield>"..eql[act[2]].shieldn) end
          if i=="held" then Note("<held>"..eql[act[2]].heldn) end
          if i=="wielded" then Note("<wielded>"..eql[act[2]].wieldedn) end
        end
      end --exists
    end --show

  elseif act[1]=="list" then
    Note("Current sets:") 
    Note(table.concat(eql.setnames,"\\\r\\\n"))

  elseif act[1]=="change" then
    if #act~=3 then
      --Note("Sintax: eqlist update <name> <new_container>")
      return
    end --not 3.
    eql[act[2]].container=act[3]
    for i,v in pairs(eql[act[2]].pieces) do
      eql.pieces[v]=act[3]
    end --for

  elseif act[1]=="pieces" then
    tc=""
    for i,v in pairs(eql.pieces) do
      if v~=tc then
        Note(v)
      end
    end

  elseif act[1]=="export" then
    eql.wearing=false
    if eql==nil then
      Note("The sets table is empty...")
      return
    end
    require "serialize"
    exf = utils.filepicker ("Choose where to save the eq database", "sets", "mushz", {mushz="MUSH-Z sets files"}, true)
    if not exf then Note("cancelled.") return end
    local exfw=assert(io.open(exf, "w"))
    exfc=serialize.save_simple(eql)
    assert (exfw:write ("eql="..exfc))
    exfw:close()
    Note("set saved.")

  elseif act[1]=="import" then
    require "serialize"
    exf = utils.filepicker ("Choose where your eq database is saved", "sets", "mushz", {mushz="MUSH-Z sets files"}, false)
    if not exf then Note("cancelled.") return end
    clear_eqlist_vars()
    dentin_dofile(exf)
    Note("sets recovered.")
    SaveState()

  elseif act[1]=="move" then
    creatingset=false
    cup={}
    eql.moving=true
    eql.wearing=false
    if #act~=3 then
      Note("sintax: eqlist move <name> <container>")
    else
      if eql[act[2]]==nil then
        Note("Set "..act[2].." does not exist...")
      else
        moving=true
        Execute("insult -all | prefix eqlc")
        Send("lecho moving_time")
      end
    end

  elseif act[1]=="delete" then
    if #act~=2 then
      Note("sintax: eqlist delete <name>")
      return
    end
    if eql[act[2]]==nil then
      Note("Set "..act[2].." does not exist...")
    else
      eql[act[2]]=nil
      Note("set deleted.")
      for i,v in pairs(eql.setnames) do
        if v==act[2] then
          table.remove(eql.setnames,i)
        end
      end
    end

  elseif act[1]=="mode" then
    if act[3]~=nil then
      if act[2]=="all" then
        for i,v in pairs(eql.setnames) do
          eql[v].mode=table.value(setmodes,act[3])
          Note("ok")
          return
        end
      end
      if eql[act[2]]==nil then
        Note("Set "..act[2].." does not exist.")
        return
      end
      Note("Current mode for set "..act[2].." is: "..setmodes[eql[act[2]].mode])
      if IsInTable(setmodes,act[3])==1 then
        Note("changing to mode "..act[3])
        eql[act[2]].mode=table.value(setmodes,act[3])
      else
        Note("Unknown mode. Possible modes are: Meticulous, fast, lightning.")
        Note("Meticulous: Removes piece by piece, switches piece by piece. Slowest setting.")
        Note("fast: removes all if less than 9 pieces of the set you are trying to wear coincide with the currently wearing pieces. Otherwise remove all, put all and wear piece by piece to prevent pieces with multiple locations from doing weird things.")
        Note("Lightning: Remove all, check inventory to see how many more things you can carry, get as many as you can, wear all. Fastest, but unreliable for certain sets.")
        return
      end --unknown mode
    else
      Note("Current mode is: "..setmodes[eql.mode])
      if #act~=2 then
        Note("Possible modes are: Meticulous, fast, lightning.")
        Note("Meticulous: Removes piece by piece, switches piece by piece. Slowest setting.")
        Note("fast: removes all if less than 9 pieces of the set you are trying to wear coincide with the currently wearing pieces. Otherwise remove all, put all and wear piece by piece to prevent pieces with multiple locations from doing weird things.")
        Note("Lightning: Remove all, check inventory to see how many more things you can carry, wield weapon, get as many as you can, wear all. Fastest, but unreliable for certain sets.")
      else
        if IsInTable(setmodes,act[2])==1 then
          Note("changing to mode "..act[2])
          eql.mode=table.value(setmodes,act[2])
        else
          Note("Unknown mode. Possible modes are: Meticulous, fast, lightning.")
          Note("Meticulous: Removes piece by piece, switches piece by piece. Slowest setting.")
          Note("fast: removes all if less than 9 pieces of the set you are trying to wear coincide with the currently wearing pieces. Otherwise remove all, put all and wear piece by piece to prevent pieces with multiple locations from doing weird things.")
          Note("Lightning: Remove all, check inventory to see how many more things you can carry, get as many as you can, wear all. Fastest, but unreliable for certain sets.")
          return
        end --unknown mode
      end --act2nil
    end --set specific

  elseif act[1]=="wear" then
    c1 = os.clock()
    zapped={}
    creatingset=false
    if #act~=2 then
      Note("sintax: eqlist wear <name>")
    else
      if eql[act[2]]==nil then
        Note("Set "..act[2].." does not exist...")
      else
        if eql[act[2]].mode==nil then
          eql[act[2]].mode=eql.mode
        end
        cup={}
        ecnum=1
        eql.wearing=true
        eqlwear(act[2])
      end
    end

  elseif act[1]=="clear" then
    Note("Sets cleared.")
    clear_eqlist_vars()

  elseif act[1]=="clearsilent" then
    clear_eqlist_vars()

  elseif act[1]=="remove" then
    if (#act~=2 or eql.lastset==nil) then
      Note("sintax: eqlist remove <name>")
    else
      --if act[2]~=eql.lastset then
      --Note("You didn't wear this set last! The last set you wore was: "..eql.lastset)
      --return
      --end
      if eql[act[2]]==nil then
        Note("Set "..act[2].." does not exist...")
      else
        Note("removing set")
        eql.wearing=false
        eql.update_manual=false
        Execute("eql change "..act[2].." "..eql[act[2]].container)
        eql.removing=true
        removedall=false
        Send("insult -all | prefix eqlc")
      end
    end

  else
    Note("Unrecognized command - type eqlist help for options.")
  end --command if
end --function

function clear_eqlist_vars()
roomstuff={}
  eql=nil
  eql={}
  eql.setnames={}
  eql.pieces={}
  eql.mode=2
end

function sanity_check_eqlist_vars()
  if (eql == nil)          then eql = {}          end
  if (eql.setnames == nil) then eql.setnames = {} end
  if (eql.pieces == nil)   then eql.pieces = {}   end
  if (eql.mode == nil)     then eql.mode = 2      end
end

function dbn(text)
  if debugging==1 then Note(text) end
end

function inote(text)
Execute("tts_stop")
Note(text)
end

function eqltrig(n,l,w)
if eql.cpieces then
eql[act[2]].pieces={}
eql.cpieces=false
end
name=w[2]
uuid=w[3]
location=w[1]
if name=="shield bone twisted" then
uuid="bone shield twisted"
end
if name=="bloody bone armor" then
uuid="bloody bone armor"
end
if eql.removing then
remeq(uuid)
end
if eql.wearing then
moving=false
else
if creatingset then
eql.pieces[uuid]=act[3]
table.insert(eql[act[2]].pieces,uuid)
end
end
if location=="head" then
if creatingset then eql[act[2]].head=uuid eql[act[2]].headn=name end
if (eql.wearing or eql.moving) then cup.head=uuid end
elseif location=="neck" then
if neck==true then
if creatingset then eql[act[2]].neck2=uuid eql[act[2]].neck2n=name end
if (eql.wearing or eql.moving) then cup.neck2=uuid end
neck=false
else
neck=true
if (eql.wearing or eql.moving) then cup.neck1=uuid end
if creatingset then eql[act[2]].neck1=uuid eql[act[2]].neck1n=name end
end
elseif location=="finger" then
if finger==true then
if creatingset then eql[act[2]].finger2=uuid eql[act[2]].finger2n=name end
if (eql.wearing or eql.moving) then cup.finger2=uuid end
finger=false
else
finger=true
if creatingset then eql[act[2]].finger1=uuid eql[act[2]].finger1n=name end
if (eql.wearing or eql.moving) then cup.finger1=uuid end
end
elseif location=="wrist" then
if wrist==true then
if creatingset then eql[act[2]].wrist2=uuid eql[act[2]].wrist2n=name end
if (eql.wearing or eql.moving) then cup.wrist2=uuid end
wrist=false
else
wrist=true
if creatingset then eql[act[2]].wrist1=uuid eql[act[2]].wrist1n=name end
if (eql.wearing or eql.moving) then cup.wrist1=uuid end
end
elseif location=="arms" then
if creatingset then eql[act[2]].arms=uuid eql[act[2]].armsn=name end
if (eql.wearing or eql.moving) then cup.arms=uuid end
elseif location=="hands" then
if creatingset then eql[act[2]].hands=uuid eql[act[2]].handsn=name end
if (eql.wearing or eql.moving) then cup.hands=uuid end
elseif location=="held" then
if (eql.wearing or eql.moving) then cup.held=uuid end
if creatingset then eql[act[2]].held=uuid eql[act[2]].heldn=name end
elseif location=="weapon" then
if creatingset then eql[act[2]].wielded=uuid eql[act[2]].wieldedn=name end
if (eql.wearing or eql.moving) then cup.wielded=uuid end
elseif location=="feet" then
if creatingset then eql[act[2]].feet=uuid eql[act[2]].feetn=name end
if (eql.wearing or eql.moving) then cup.feet=uuid end
elseif location=="legs" then
if (eql.wearing or eql.moving) then cup.legs=uuid end
if creatingset then eql[act[2]].legs=uuid eql[act[2]].legsn=name end
elseif location=="waist" then
if creatingset then eql[act[2]].waist=uuid eql[act[2]].waistn=name end
if (eql.wearing or eql.moving) then cup.waist=uuid end
elseif location=="on body" then
if (eql.wearing or eql.moving) then cup.body=uuid end
if creatingset then eql[act[2]].body=uuid eql[act[2]].bodyn=name end
elseif location=="about body" then
if creatingset then eql[act[2]].abody=uuid eql[act[2]].abodyn=name end
if (eql.wearing or eql.moving) then cup.abody=uuid end
elseif location=="shield" then
if (eql.wearing or eql.moving) then cup.shield=uuid end
if creatingset then eql[act[2]].shield=uuid eql[act[2]].shieldn=name end
end
--creatingset=false
if eql.wearing then
weareq(moving)
end
end

function md5f(name)
f= io.open (name, "rb")
 if f then
md5=string.lower (utils.tohex (utils.md5 (f:read ("*a"))))
 f:close () 
return md5
else
return "nofile"
end
end

function yspell(s)
myspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/"..s..".ogg",0,50)
theygrunt()
end)
end

function tspell(s)
theyspecial()
require "wait"
wait.make(function()
if gs("grunts") == true then wait.time(0.4) end
ppi.play(sdir.."spells/"..s..".ogg",0,-50)
yougrunt()
end)
end

function friends(n,l,w)
  EnableGroup("friendsnotify",false)
  DoAfterSpecial(3,'EnableGroup("friendsnotify",true)',12)
  tfriends=split(w[1],", ")
  tfriendscount=#tfriends
  if tfriendscount==1 then 
    -- this only runs because when one friend is online, alter sends a differently formatted string. Hense, when our number of friends (via tfriends) is 1, we know it's wrong and needs to be increased
    -- This happens because the table's contents is being split by commas in the string
    tfriendscount=tfriendscount+1
  end
  display=tonumber(tfriendscount).." are online: " 
  x=1
  for i in pairs(tfriends) do
    display=display..tfriends[i]
    if (x~=#tfriends) then display=display..", " end
    if (x==#tfriends) then display=display .."." end
    x=x+1
  end
  Note(display)
end -- func

function scan_dir (path, f)
 -- find all files in that directory
 local t = assert (utils.readdir (path .. "\\*"))

 for k, v in pairs (t) do
 
 -- recurse to process subdirectory
 if v.directory then

 if k ~= "." and k ~= ".." then
 scan_dir (path .. "\\" .. k, f)
 end -- not current or owner directory

 else -- call supplied function
 f (path .. "\\" .. k, v) 
 end -- if 
 
 end -- for
end -- scan_dir 

function countfunc(name,stats)
counter=counter+1
end

function count_files(path)
scan_dir(path,countfunc)
retcount=counter
counter=0
return retcount
end

function better_at()
Sound(sdir.."notifications/betterat/"..math.random(1,betterat)..".ogg")
end

function OnPluginTabComplete(s)
while (string.sub(s,-1)==":"
or string.sub(s,-1)=="!"
or string.sub(s,-1)=="@"
or string.sub(s,-1)=="#"
or string.sub(s,-1)=="$"
or string.sub(s,-1)=="%"
or string.sub(s,-1)=="^"
or string.sub(s,-1)=="&"
or string.sub(s,-1)=="*"
or string.sub(s,-1)=="("
or string.sub(s,-1)==")"
or string.sub(s,-1)=="_"
or string.sub(s,-1)=="-"
or string.sub(s,-1)=="="
or string.sub(s,-1)=="+"
or string.sub(s,-1)=="~"
or string.sub(s,-1)=="`"
or string.sub(s,-1)=="["
or string.sub(s,-1)=="]"
or string.sub(s,-1)=="{"
or string.sub(s,-1)=="}"
or string.sub(s,-1)=="'"
or string.sub(s,-1)=="."
or string.sub(s,-1)=="?"
or string.sub(s,-1)==",")
--add any more unwanted chars to the pattern.
 do 
s=string.sub(s,1,-2)
Execute("tts_interrupt "..s)
end
return s
end

function OnPluginSaveState()
require "serialize"
if not (gag==nil) then
local vars=GetInfo(67).."/settings/filters.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(gag)
assert (exfw:write ("gag="..exfc))
exfw:close()
end
if not (settings==nil) then
local vars=GetInfo(67).."/settings/settings.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(settings)
assert (exfw:write ("settings="..exfc))
exfw:close()
end
if not (storefilter==nil) then
local vars=GetInfo(67).."/settings/storefilter.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(storefilter)
assert (exfw:write ("storefilter="..exfc))
exfw:close()
end
if not (recast==nil) then
local vars=GetInfo(67).."/settings/recast.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(recast)
assert (exfw:write ("recast="..exfc))
exfw:close()
end
if not (counters==nil) then
local vars=GetInfo(67).."/settings/counters.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(counters)
assert (exfw:write ("counters="..exfc))
exfw:close()
end
if not (eql==nil) then
local vars=GetInfo(67).."/settings/eqlists.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(eql)
assert (exfw:write ("eql="..exfc))
exfw:close()
end
if not (charlist==nil) then
local vars=GetInfo(67).."/settings/charlist.mushz"
local exfw=assert(io.open(vars, "w"))
exfc=serialize.save_simple(charlist)
assert (exfw:write ("charlist="..exfc))
exfw:close()
end
end

function rc(spelltocast)
Execute("history_add spells="..spelltocast.." fell.")
  if gs("spellsfall") == 2 or gs("spellsfall") == 4 then
  Execute("history_add all="..spelltocast.." fell.")
  end
end

function FileExists(filename)
 local file = io.open(filename)
 if file then
 io.close(file)
 return true
 else
 return false
 end
end

function PSend(s)
if (afk==0 and context.current.name=="none") then -- context check
SendNoEcho(s)
else -- either afk or in different context:
if afk==1 then -- block commands passed if afk.
return 0
end
if (context.current.name=="free spirit") then--block all commands passed if the context is Free Spirit, except for the walk dirs:
if (s=="n" -- walkdirs:
or s=="ne"
or s=="e"
or s=="se"
or s=="s"
or s=="sw"
or s=="w"
or s=="nw"
or s=="u"
or s=="d") then
SendNoEcho(s)
end -- Walkdirs
return
end -- free spirit
SendNoEcho("\\"..s) -- Escape it.
end -- context check
end --func

function ESend(s)
if (context.current.name=="none") then
SendNoEcho(s)
else
SendNoEcho("\\"..s) -- Escape it.
end
end --func

function move(exits)
texits={}
for w in string.gmatch(exits, "%a+") do
table.insert(texits,w)
end --for
if #texits==1 then
Send(texits[1])
else
exr=math.random(1,#texits)
Send(texits[exr])
end --texits1
end

function sec2minz(secs)
if secs > 59 then
myMinutes=math.floor(secs/60);
mySeconds=secs-(math.floor(secs/60)*60);
if myMinutes==1 then minword="minute"
elseif myMinutes>1 then minword="minutes"
end --minutes
if mySeconds==0 then
myTime=myMinutes.." "..minword.." "
else --not 0
secstring=tostring(mySeconds)
if (string.sub(1,mySeconds,#secstring)=="1") then
myTime=myMinutes.." "..minword.." and "..mySeconds.." second"
else
myTime=myMinutes.." "..minword.." and "..mySeconds.." seconds"
end --if its 1
end --if0 seconds
else --if its less then 59
secstring=tostring(secs)
if (string.sub(secs,1,#secstring)=="1") then
mySeconds=secs.." second"
else
mySeconds=secs.." seconds"
end --not 1
myTime=mySeconds
end --less then59
return myTime
end --func

function ambtimer()
  if (gs("randomambience")==true) then
    if (amb2[terrain]~=nil) then
      Sound(sdir.."ambience/random/"..terrain.."/"..math.random(1,amb2[terrain])..".ogg")
    end --nil
  end --if randomambience
end --func

function split(str, pat)
local t = {}
local fpat = "(.-)" .. pat
local last_end = 1
local s, e, cap = str:find(fpat, 1)
while s do
if s ~= 1 or cap ~= "" then
table.insert(t,cap)
end
last_end = e+1
s, e, cap = str:find(fpat, last_end)
end
if last_end <= #str then
cap = str:sub(last_end)
table.insert(t, cap)
end
return t
end


---------------------------------------------------------------------------------
-- trip and other combat related sounds
---------------------------------------------------------------------------------

function yougrunt()
if gs("grunts") == true then
if (gender=="male") then
ssrandom=math.random(1,mgrunt[3])
elseif (gender=="female") then
ssrandom=math.random(1,fgrunt[3])
elseif (gender=="neuter") then
ssrandom=math.random(1,ngrunt)
end
ppi.play(sdir.."combat/grunts/3/"..gender.."/"..ssrandom..".ogg",0,-50)
end
end

function yougrunt2()
if gs("grunts") == true then
if (gender=="male") then
ssrandom=math.random(1,mgrunt[gtype])
elseif (gender=="female") then
ssrandom=math.random(1,fgrunt[gtype])
elseif (gender=="neuter") then
ssrandom=math.random(1,ngrunt)
end
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/grunts/"..gtype.."/"..gender.."/"..ssrandom..".ogg",0,-50)',12)
end
end

function theygrunt()
if gs("grunts") == true then
if (mg=="male") then
ssrandom=math.random(1,mgrunt[3])
elseif (mg=="female") then
ssrandom=math.random(1,fgrunt[3])
elseif (mg=="neuter") then
ssrandom=math.random(1,ngrunt)
end
ppi.play(sdir.."combat/grunts/3/"..mg.."/"..ssrandom..".ogg",0,50)
end
end


function theygrunt2()
if gs("grunts") == true then
if (mg=="male") then
ssrandom=math.random(1,mgrunt[gtype])
elseif (mg=="female") then
ssrandom=math.random(1,fgrunt[gtype])
elseif (mg=="neuter") then
ssrandom=math.random(1,ngrunt)
end
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/grunts/"..gtype.."/"..mg.."/"..ssrandom..".ogg",0,50)',12)
end
end

function myspecial()
if gs("grunts") == true then
if (gender=="male") then
ssrandom=math.random(1,mspecial)
elseif (gender=="female") then
ssrandom=math.random(1,fspecial)
elseif (gender=="neuter") then
ssrandom=math.random(1,nspecial)
end
ppi.play(sdir.."combat/special/"..gender.."/"..ssrandom..".ogg",0,-50)
end
end

function theyspecial()
if gs("grunts") == true then
if (mg=="male") then
ssrandom=math.random(1,mspecial)
elseif (mg=="female") then
ssrandom=math.random(1,fspecial)
elseif (mg=="neuter") then
ssrandom=math.random(1,nspecial)
end
ppi.play(sdir.."combat/special/"..mg.."/"..ssrandom..".ogg",0,-50)
end
end

function play_trip_sound(pan_amount)
  if (trip[terrain] ~= nil) then
    ppi.play(sdir.."skills/trip/"..terrain.."/"..math.random(1,trip[terrain])..".ogg", 0, pan_amount)
  else
    ppi.play(sdir.."skills/you trip.ogg", 0, pan_amount)
  end
  if (pan_amount < 0) then
    yougrunt()
  elseif (pan_amount > 0) then
    theygrunt()
  end
end

function play_trip_sound_delayed(pan_amount)
  require "wait"
  wait.make(function()
    wait.time(0.3)
    play_trip_sound(pan_amount)
  end)
end


---------------------------------------------------------------------------------
-- misc
---------------------------------------------------------------------------------

function percent(v1,v2)
return math.floor(v1 / v2 * 100 + 0.5)
end

function percentage(v1,v2)
return math.floor(v1 / v2 * 100)
end

function monitor(n,l,w)
name=w[1]
gmhp[name]=tonumber(w[4])
gmmhp[name]=w[5]
gmmn[name]=w[6]
gmmmn[name]=w[7]
gmmv[name]=w[8]
gmmmv[name]=w[9]
if (gmhp[name]/gmmhp[name]*100 < 80) then
Note(name.." "..math.floor(percent(gmhp[name],gmmhp[name])).."percent hp.")
issues=1
end
if (gmmn[name]/gmmmn[name]*100 < 70) then
Note(name.." mana. "..math.floor(percent(gmmn[name],gmmmn[name])).."percent left.")
issues=1
 end
if (gmmv[name]/gmmmv[name]*100 < 40) then
Note(name.." is growing tired. "..math.floor(percent(gmmv[name],gmmmv[name])).."percent move.")
issues=1
end
end

function refresh_context(n,m,w)
--Handles the refreshing of context information in the client.
--This is not meant to be called when there is no context or when the context command isn't accessible; e.g: free spirit. Doing so will result in the game sending an invalid command message.
--Send the string '/show |prefix getContext:' to check the current context properly

--setting current context
--This works by sending the context command escaped and prefixed by 'getCurrentContext:'
--The firing trigger then calls this function again with the standard script call from mush client.
--It can tell the difference by looking if 'w' is present.
if not w then -- stage 1 of this command
SendNoEcho("\\context | prefix getCurrentContext:| grep current")
return
end -- if

if w then -- If we've made it this far, we should be loading info from the matched trigger:
set_current_context_variables(w[2],w[1])
   -- finish reloading if we need to. E.g: person is reconnecting when writing an e-mail.
   login()
   -- Play any sounds based on the context type.
   play_context_sound(context.current.name,context.current.previous_name)
end -- if

end -- function

function set_current_context_variables(contextName,contextId)
--only sets the new current context variables. This is so code isn't duplicated.
   --Update the variables:
   -- Set up some previous variables to check state for sounds for example:
context.current.previous_id=context.current.id
   context.current.previous_name=context.current.name

-- Reset the current variables to realtime:
context.current.id=tonumber(contextId)
   context.current.name=contextName
end -- function

function play_context_sound(currentContextName,previousContextName)
--So code doesn't get repeated, this function handles any sounds that play when a context changes.
--First let's check to see that the context recorded isn't the same one.
--This is a problem only when loading at startup.
if (context.current.name==context.current.previous_name) then return -1 end
--sounds for entering a writing context:
play_writing_sound_context(currentContextName,previousContextName) -- Play sounds when the user enters and leaves  a writing context such as an e-mail.

end -- function

function play_writing_sound_context(currentContextName,previousContextName) -- handles playing sounds if a player enters a writing context.
-- Play sound if player enters a writing context.
if (check_writing_context(currentContextName)==true) then
Sound(sdir.."notifications/context/enter_write.ogg")
elseif (check_writing_context(previousContextName)==true and context.current.name=="none") then -- play the leaving writinc context sound only if the player is in a writing context:
Sound(sdir.."notifications/context/leave_write.ogg")
end-- sounds
end -- function

function is_matching_string(strings,stringSearched)
-- Checks a list of strings to see if it matches on a string.
-- This also returns false if an invalid arg is passed (e.g. number for table).
local matches=false
if (strings~=nil and stringSearched~=nil) then
if(type(strings)=="table") then
if(type(stringSearched)=="string") then
for i,v in pairs(strings) do
local matchingStart, matchingEnd = string.find(stringSearched, v) -- see if this returns nil to see if it matches.
if (matchingStart~=nil and matchingEnd~=nil) then
matches=true
end -- if string matches
end -- loop
end -- stringSearched type checking
end -- strings table type checking.
end -- nil checking
return matches
end

function check_writing_context(contextName) -- determines if a context is a writing type.
local contextStrings = {}
contextStrings[1]="%swrite" -- find write in the context name.
contextStrings[2]="%sdescription" -- find description in the context name.
local is_writing_context=false -- false until otherwise changed.
if (is_matching_string(contextStrings,contextName)==true) then
is_writing_context=true -- valid context
else
is_writing_context=false -- Not valid context
end
return is_writing_context
end -- function

function k_context(n,m,w)
--handles various situations when the mud changes context.
--id is an integer that is shown when you type the context command in the mud, and name is the name of the current context.
--This is a multistep process because an id is not sent with kxwt_context, so we have to send the command to load it into the table.
--This function is called when kxwt_context is sent to the client.
if (context_with_no_id(w[1])==true) then -- call this to see if we can't use the context command.
--Update the variables:
set_current_context_variables(w[1],no_context_id())
login() -- In case the client reloaded in a context where it couldn't load itself.
play_context_sound(context.current.name,context.current.previous_name) -- play any sounds if we've configured them
return
end

-- Now if we're in a new context:
refresh_context()
end -- func

function no_context_id()
--This returns a constant value to be used when specifying that there isn't an id for the current context. E.g: when there isn't one.
return -99
end

function context_with_no_id(contextName)
--So code doesn't get duplicated, this function reports true for a context that should not be checked for using the context command, or false if it should continue.
if (contextName == "none"
or contextName=="free spirit") then
return true
else
return false
end
end -- function

function login()
if(alreadyExecutedLogin==true) then -- let's finish loading everything only if needed. If not, return:
return -1
end
alreadyExecutedLogin=true -- Prevent login from running twice or more.

initialized=true -- run startup/init from the top if reconnect now.
PSend("set ctrigger off|prefix mzc") --reloading while in game.
  loggedin=1

PSend("channel|prefix zchnInfo:")
PSend("level|prefix lvltbl:")

  PSend("set cprefix zchn:|grep nospam")
  DoAfterSpecial(15,'EnableTimer("rctimer",true)',12)
  PSend("set kprefix kxft | prefix mzc")
  PSend("set ctrigger on | prefix mzc")
  PSend("whoami|grep clan|prefix zclan:")
  EnableTimer("aminutes",true)
  EnableTimer("tipsTimer",true)
  EnableTimer("pingtimer",true)
  ESend("lecho _mushz " .. GetVariable("version") .. " " .. Version() .. " " .. "|grep nospam")

  if GetVariable("oldversion")==GetVariable("version") then
  else
    -- utils.msgbox("You are now updated to mush-z "..GetVariable("version")..". If you like mush-z, please consider donating by clicking the PayPal button found on www.mush-z.com. This message will only be displayed once.")
    utils.msgbox("You are now updated to mush-z "..GetVariable("version")..".")
    SetVariable("oldversion",GetVariable("version"))
    update_recastsets(false) -- Check to make sure all possible recastable spells are in all sets
  end
  PSend("version | grep mushz-stable | prefix mzu")
  EnableGroup("show",1)
  if (gs("praccing") == true) then
    classtnl="practice"
    Execute("tnp")
end
      EnableGroup("show",1)
    DoAfterSpecial(3,'PSend("show cost | prefix tnl")',12)
    DoAfterSpecial(20,'EnableGroup("show",0)',12)
  
PSend("show practices|prefix practiceTbl:")
  PSend("show cost practice|prefix praccost:")
  if praccost == nil then praccost = 10000000 end
  PSend("spell | prefix zknow")
  PSend("autotick | prefix mzscr")
  PSend("skill | prefix knw")
  --PSend("way | prefix setway")
  PSend("set echo on | prefix mzscr") -- Gag this from displaying text.
  PSend("whoam | grep feet | prefix gend")
  jli=1
  DoAfterSpecial(12, 'jli=0', 12)
  PSend("stats | prefix mzstat")
end -- login function

function zchnInfoCheck()
-- here's where channels the client needs will be checked to see if they are enabled or if this character needs to connect.
-- Let's start with zt:
if (chnInfo.zt==nil) then --not connected; reconnecting
 PSend("channel listen zt | prefix mzc")
end

if (chnInfo.mushznews==nil) then --not connected; reconnecting
  PSend("channel listen mushznews mznews|prefix mzc")
chnInfo.mushznews={}
end
-- let's check to see it's not turned off:
--fixing nil variable if it disconnects:
if not chnInfo.mushznews.disabled then chnInfo.mushznews.disabled=false end --channel connected; already on.
if (chnInfo.mushznews.disabled==true) then --channel is off
PSend("mushznews|prefix mzc")
end

if (chnInfo.dm==nil) then --not connected; reconnecting
  PSend("channel listen dm |prefix mzc")
end

end

function postInit(n,m,w)
-- This is for stuff you need to do after runtime variables have been set from the mud.
-- Will be called from the trigger matching on the string 'kxwt_myname %s'
--first thing's first: set the character name from the string:
ss("me", w[1])
--see if we need to listen or turn on channels used by the client
zchnInfoCheck()
--let's initialize charlist information:
--moved from the login function

  if (charlist~=nil) then -- the charlist table exists
    if (#charlist>=1) then -- we have at least one entry in the charllist table
      if (charlist[1]~=nil) then -- we have an oldstyle charlist table, convert it
        convert_charlist()
      end -- if oldstyle charlist table
    end -- if table has one value
    if (charlist[gs("me")]==nil) then
      charlist[gs("me")]={}
      Execute("config mud")
    end
  else
    charlist={}
    charlist[gs("me")]={}
    Execute("config mud")
  end

  if gs("me")=="new" then
    return
  end


  if gs("clannotify")==true then -- clan notify is enabled, se what suboptions are enabled and collect data
    if (gs("clanfame")==true or gs("clanactive")==true or gs("Clansize")==true or gs("clanpk")==true) then
      if charlist[gs("me")].clan==nil then -- this char isn't in a clan
      else -- we do have a clan string, show it's ranking
        DoAfterSpecial(6,'PSend("clan list|grep " ..charlist[gs("me")].clan .."|prefix zclan:")', 12)
      end -- if there is a clan string
    end -- if one or more of the clan notify settings is enabled
  end -- if clan notify is enabled

end
function play(snd,pan)
ppi.play(sdir..""..snd..".ogg",0,50)
end

function checkstats()
if (gs("autostat")==true) then
require "wait"
wait.make(function()
if (statcount~=1) then
statcount=1
wait.time(3)
statcount=0
PSend("stat | prefix mzstat")

end --if
end) --wait
end --if
end --func

function ntrunk(n)
n=tostring(n)
if not (gs("ntrunk") == true) then
return n
end
if (#n< 5) then
return n
elseif (#n == 5) then
return string.sub(n, 1, 2).."k"
elseif (#n == 6) then
return string.sub(n, 1, 3).."k"
elseif (#n == 7) then
if (string.sub(n, 2, 2) == "0") then
return string.sub(n, 1,1).." mill"
else
return string.sub(n, 1, 1).."."..string.sub(n, 2,2).."mill"
end
elseif (#n == 8) then
if (string.sub(n, 3, 3) == "0") then
return string.sub(n, 1,2).." mill"
else
return string.sub(n, 1, 2).."."..string.sub(n, 3,3).."mill"
end
elseif (#n == 9) then
if (string.sub(n, 4, 4) == "0") then
return string.sub(n, 1,3).." mill"
else
return string.sub(n, 1, 3).."."..string.sub(n, 4,4).."mill"
end
elseif (#n == 10) then
if (string.sub(n, 2, 2) == "0") then
return string.sub(n, 1,1).." bill"
else
return string.sub(n, 1, 1).."."..string.sub(n, 2,2).."bill"
end
elseif (#n == 11) then
if (string.sub(n, 3, 3) == "0") then
return string.sub(n, 1,2).." bill"
else
return string.sub(n, 1, 2).."."..string.sub(n, 3,3).."bill"
end
elseif (#n == 12) then
if (string.sub(n, 4, 4) == "0") then
return string.sub(n, 1,3).." bill"
else
return string.sub(n, 1, 3).."."..string.sub(n, 4,4).."bill"
end
end --main if
end --func

function processid()
require "wait"
wait.make(function()
wait.time(0.3)
Note(idstring)
if not vflags=="" then
Note(vflags)
end
if (affects~=nil) then
Note(table.concat(affects," "))
else
Note("No affects.")
end
affects={}
flags={}
idstring=""
end)
end

function sgag(n,line,w)
if not gag.spells then Note(line) end
end

function cngag(n,line,w)
if not gag.condition then Note(line) end
end

function skgag(n,line,w)
if not gag.skills then Note(line) end
end
function mgag(n,line,w)
if not gag.misc then Note(line) end
end

function cgag(n,line,w)
if not gag.combat then Note(line) end
end

function crgag(n,line,w)
if not gag.crafting then Note(line) end
end

function ngag(n,line,w)
if not gag.minions then Note(line) end
end

function OnPluginScreendraw(t,l,line)
if cmi~=1 then return end
cmistr=cmistr..line.."\r\n"
end

function PanSnd(c,m,f,v)
  if tonumber(c)<1 then c = 1 end
if tonumber(m) < 1 then m = 1 end
  if v==nil then
    v=ppi.getVolume()
  end
  if gs("bars")==1 then
    fid=ppi.play(f,0,0,v)
    ppi.setPan((c*200/m)-100,fid)
  end
  if gs("bars")==2 then
    fid=ppi.play(f,0,0,v)
    ppi.setPitch((c*200/m)-100,fid)
  end
end

function voltoggle()
  if voltype==1 then
    voltype=2
  elseif voltype==2 then
    voltype=3
  else
    voltype=1
  end

  if voltype==1 then
    Note("Changing global volume: Current value "..gs("vol_global"))

  elseif voltype==2 then
    if (gs("areamusic")==false) then
      Note("Area music is currently disabled.")
      return
    end
    if (areamusic_playout_device_id==11) then
      Note("No area music for this location.")
      return
    end
    Note("Changing area music volume: Current value "..gs("vol_areaid"))

  elseif voltype==3 then
    if (gs("ambience")==false) then
      Note("Ambience is currently disabled.")
      return
    end
    if (ambience_playout_device_id==11) then
      Note("There are no ambience sounds for this location.")
      return
    end
    Note("Changing ambience volume: Current value "..gs("vol_ambid"))
  end
end

function volup()
  if voltype==1 then
    if change_volume("vol_global", 5) == 0 then
      Note("Global volume can't go any higher.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/up.ogg",0)
    end
  end

  if voltype==2 then
    if (gs("areamusic")==false) then
      ss("areamusic", true)
      set_areamusic()
      Note("Note - enabling area music.")
    elseif (areamusic_playout_device_id==11) then
      Note("Note - no area music for this location.")
    end
    if change_volume("vol_areaid", 3) == 0 then
      Note("Area music volume can't go any higher.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/up.ogg",0)
    end
  end

  if voltype==3 then
    if (gs("ambience")==false) then
      ss("ambience", true)
      play_time_ambience()
      Note("Note - enabling ambience sounds.")
    elseif (ambience_playout_device_id==11) then
      Note("Note - no ambience sounds for this location.")
    end
    if change_volume("vol_ambid", 5) == 0 then
      Note("Ambience volume can't go any higher.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/up.ogg",0)
    end
  end
end

function voldown()
  if voltype==1 then
    if change_volume("vol_global", -5) == 0 then
      Note("Master volume is currently muted.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/down.ogg",0)
    end
  end

  if voltype==2 then
    if (gs("areamusic")==false) then
      ss("areamusic", true)
      set_areamusic()
      Note("Note - enabling area music.")
    elseif (areamusic_playout_device_id==11) then
      Note("Note - no area music for this location.")
    end
    if change_volume("vol_areaid", -3) == 0 then
      Note("Area music is currently muted.  To disable it completely, use 'config areamusic'.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/down.ogg",0)
    end
  end

  if voltype==3 then
    if (gs("ambience")==false) then
      ss("ambience", true)
      play_time_ambience()
      Note("Note - enabling ambience sounds.")
    elseif (ambience_playout_device_id==11) then
      Note("Note - no ambience sounds for this location.")
    end
    if change_volume("vol_ambid", -5) == 0 then
      Note("Ambience sounds are currently muted.  To disable them completely, use 'config ambience'.")
      ppi.play(sdir.."luaaudio/error.ogg",0)
    else
      ppi.play(sdir.."luaaudio/down.ogg",0)
    end
  end

end

function change_volume(parm, amount)
  local v = gs(parm) + amount
  local ret = 1
  if (v >= 100) then
    v = 100
    ret = 0
  end
  if (v <= 0) then
    v = 0
    ret = 0
  end
  ss(parm,v)
  resetvol()
  return ret
end

function resetvol()
  ppi.setVol(tonumber(gs("vol_global")),0)
  ppi.setVol(tonumber(gs("vol_areaid")),areamusic_playout_device_id)
  ppi.setVol(tonumber(gs("vol_ambid")),ambience_playout_device_id)
end

function k_prompt(n,l,w)
for i = 1, 6 do
if tonumber(w[i]) < 1 then w[i] = 1 end
  end
  k_hp=tonumber(w[1])
  k_maxhp=tonumber(w[2])
  k_mana=tonumber(w[3])
  k_maxmana=tonumber(w[4])
  k_move=tonumber(w[5])
  k_maxmove=tonumber(w[6])
    thp=percent(k_hp,k_maxhp)
  tmn=percent(k_mana,k_maxmana)
  tmv=percent(k_move,k_maxmove)
if mpl[gs("me")]==nil then mpl[gs("me")]={} gme=gs("me") end
mpl[gme].php=percent(k_hp,k_maxhp)
mpl[gme].dhp=k_maxhp-k_hp
mpl[gme].pmv=percent(k_move,k_maxmove)
mpl[gme].dmv=k_maxmove-k_move
  if (thp < 100) and (hpr ~= 0) then
    hpr = 0
  elseif (thp == 100) and (hpr ~= 1) then
    hpr = 1
    if (nfight ~= 1) and (pose ~= "stand") then
      Note("hp is full.")
      Sound(sdir.."notifications/hpfull.ogg")
    end
  end
  if (tmn < 100) and (mnr ~= 0) then
    mnr = 0
  elseif (tmn == 100) and (mnr ~= 1) then
    mnr = 1
    if (nfight ~= 1) and (pose ~= "stand") then
      Note("mana is full.")
      Sound(sdir.."notifications/manafull.ogg")
    end
  end
  if (tmv < 100) and (mvr ~= 0) then
    mvr = 0
  elseif (tmv == 100) and (mvr ~= 1) then
    mvr = 1
    if (nfight ~= 1) and (pose ~= "stand") then
      Note("movement is full.")
      Sound(sdir.."notifications/movefull.ogg")
    end
  end

  if thp >= 99 then
  k_cond="excellent"
  elseif thp >= 90 then
  k_cond="scratches"
  elseif thp >= 70 then
  k_cond="small wounds"
  elseif thp >= 50 then
  k_cond="quite a few"
  elseif thp >= 30 then
  k_cond="big nasty"
  elseif thp >= 10 then
  k_cond="pretty hurt"
  elseif thp >= 0 then
  k_cond="awful"
  else
  k_cond="awful"
  end
  if (lastcn == k_cond) then
  else
    if nfight==1 then
      if (gs("battlemusic") == true) then
        if (gs("musictype")==1) then
          ppi.fadeout(battleid,500)
          battleid=ppi.play(sdir.."music/"..gs("musictype").."/"..k_cond..".ogg",1)
          battleplaying=1
        end --musictype
      end --music
    end --fighting
    Sound(sdir.."condition/"..gs("scheme").."/"..k_cond..".ogg")
  end
  lastcn =k_cond
  if (k_move<=prevmv-15) or (k_move>prevmv+15) then
    if announce_move==true then
      announce_move=false
      if k_move>prevmv then
        Note("+"..k_move-prevmv.." movement.")
      end --prevmv
    end --anounce
    if nfight==1 then
      if (k_move<50) then
        if (berserk==1) and (mvalarm==0) then
          Sound(sdir.."notifications/omv alarm.ogg")
          mvalarm=1
          if (grouped==1) and (gs("swarn")==true) then
            PSend("gt area")
          else
            Note("You're running out of move.")
          end --group
        end --berserk
      end --50 move
    end --nfight
    PanSnd(k_move,k_maxmove,sdir.."pm/move.ogg")
    prevmv=k_move
    if (gs("bars")==3) then
      Note(math.floor(k_move/k_maxmove*100) .."percent move.")
    end
  end
  if (k_mana<=prevmn-15) or (k_mana>prevmn+15) then
    if (math.floor(k_mana/k_maxmana*100) < 25) then
      if k_mana<prevmn then
        Sound(sdir.."notifications/mana alarm.ogg")
      end
    end
    prevmn=k_mana
    PanSnd(k_mana,k_maxmana,sdir.."pm/mana.ogg")
    if (gs("bars")==3) then
      Note(math.floor(k_mana/k_maxmana*100) .."percent mana.")
    end
  end
end

function removespaces(s)
  local n = 1
  while true do
    while true do -- removes spaces
      local _, ne, np = s:find("^[^%s%%]*()%s*", n)
      n = np
      if np - 1 ~= ne then s = s:sub(1, np - 1) .. s:sub(ne + 1)
      else break end
    end
    local m = s:match("%%(.?)", n) -- skip magic chars
    if m == "b" then n = n + 4
    elseif m then n = n + 2
    else break end
  end
  return s
end



----------------------------------------------------------------
-- various recast code
----------------------------------------------------------------

function update_recastsets(verbose)
  -- This function makes sure all spells that *can* be recasted are in all recast sets
  local addcount=0
  local addplural
  local addplural2
  for spellname, manaRequired in pairs(rmt) do -- iterate through the possible spells table
    for set, v in pairs(recast) do -- iterate through the recast sets
      if type(recast[set])=="table" then
        if recast[set][spellname]==nil then -- We've found a spell that is available, but isn't in this set
          recast[set][spellname]=false -- Add it to the current set
          addcount=addcount+1
        end -- if spell doesn't exist in set
      end -- if item is table
    end -- set table iteration
  end -- possible spell table iteration

  for set, t in pairs(recast) do -- iterate through the recast sets
    if type(t)=="table" then
      for spellname, v in pairs(t) do -- iterate through the set
        if rmt[spellname] == nil then -- We've found a spell that is is in this set but should not be
          recast[set][spellname] = nil
        end -- if spell shouldn't exist in set
      end -- set table iteration
    end -- if item is table
  end -- possible spell table iteration

  if verbose==true then
    if addcount>0 then
      if addcount==1 then
        addplural="spell"
        addplural2="was"
      elseif addcount>1 then
        addplural="spells"
        addplural2="were"
      end -- plural stuff (yes, I know i'm ADHD about this)
      Note(addcount .." " ..addplural .." " ..addplural2 .." added to all recast sets.")
    else
      Note("All possible recastable spells are already in each set.")
    end -- addcount is greater than 0
  end -- if verbose
end -- function

function sanity_check_recast_vars()
  if (recast == nil) then recast = {} end
  if (recast.active == nil) then recast.active = "default" end
  if (recast.default == nil) then
    recastdefaults("default")
  end
end

function recastparse(n,l,w)
  sanity_check_recast_vars()
  act=split(w[1]," ")

  if act[1]=="help" then
    Note("Possible commands are:")
    Note("zrecast create <name> create a new recast set")
    Note("zrecast create <name> from <name> create a new recast set with spell configurations from another set")
    Note("zrecast remove - remove a set entirely")
    Note("zrecast list - show the list of sets")
    Note("zrecast switch <name> - to switch between sets.")
    Note("zrecast on,off - to toggle recasting on and off.")
    Note("zrecast check - Makes sure all spells that can be recasted are in each set.")
    Note("zrecast spl <partial spellname> - Quickly toggle spesific spells in you're current set without opening the zrecast dialog to find it.")
    Note([[Not all spells can be toggled this way, for example you may have trouble with the different spells with "shield" in the name, but it's a nice, quick way to stop a spell from recasting if you're in a group or need you're full attention on the game.]])
    Note("The zrecast command, typed by itself, shows a list of spells in the current active set that you can enable or disable by clicking ok on a spell. when you hit cancel, your changes are saved.")

  elseif act[1]=="list" then
    Note("List of recast sets:")
    for k,v in pairs(recast) do
      if type(v)=="table" then
        if k == recast.active then
          Note("*"..k)
        else
          Note(k)
        end
      end
    end

  elseif act[1]=="switch" then
    if #act~=2 then
      Note("Sintax: recast switch <name>")
      Execute("recast list")
      return
    else
      if recast[act[2]]~=nil then
        recast.active=act[2]
        Note("Switched to set "..act[2])
      else
        Note("set "..act[2].." does not exist. You'll need to create it first.")
        return
      end --recast is nil
    end --act[2] valid

  elseif act[1]=="remove" then
    if #act~=2 then
      Note("Sintax: recast remove <name>")
      Execute("recast list")
      return
    else
      if act[2]=="default" then
        Note("You cannot remove the default set.")
        return
      end
      if recast[act[2]]~=nil then
        recast[act[2]]=nil
        recast.active="default"
        Note("removed set "..act[2].." and switched to default.")
      else
        Note("set "..act[2].." does not exist.")
        return
      end --recast is nil
    end --act[2] not valid

  elseif act[1]=="create" then
    if #act<2 then
      Note("Sintax: recast create <name>")
      return
    else
      recast.active=act[2]
      recastdefaults(recast.active)
      Note("Set "..act[2].." created successfully!")
      if act[3]=="from" and act[4]~=nil then
        if recast[act[4]]~=nil then
          recast[act[2]] = table_shallow_copy(recast[act[4]])
          Note("inherited spells from "..act[4])
        else
          Note("set "..act[4].." does not exist, creation aborted.")
          Execute("recast remove "..act[2])
        end --is not nil
      end --act 4 from
    end --create has 2 items

  elseif act[1]=="on" then
    Note("Recast enabled")
    rct={}
    DoAfterSpecial(0.2,'ss("recast",true)',12)
    return

  elseif act[1]=="off" then
    Note("Recast disabled")
    ss("recast",false)
    rct={}
    return
  elseif act[1] == string.lower("spell") or act[1] == string.lower("spl") then
    spellstring = table.concat(act, " ", 2) -- concatonate everything after 1 to a string
    -- Gotta be a better way of doing this...
    for k, v in pairs(recast[recast.active]) do
      if multiword_is_abbrev(spellstring, k, 4) then
        match = k
      end
    end
    if match or recast[recast.active][spellstring] ~= nil then
      if match == nil then
        match = spellstring
      end
      if recast[recast.active][match] == false then
        recast[recast.active][match] = true
        Note("Recasting of " ..match.. " enabled for the " ..recast.active.. " set.")
      elseif recast[recast.active][match] == true then
        recast[recast.active][match] = false
        Note("Recasting of " ..match.. " disabled for the " ..recast.active.. " set.")
      end
    else
      Note("Sorry, no recast spell by that name found.")
    end -- if string matches spell
    spellstring=nil
    match=nil

  elseif act[1]==string.lower("check") then
    update_recastsets(true)
  else
    Note("Unrecognized command.")
    Execute("recast help")
  end --main if
end --func

function filterparse(n, l, w)
  if string.lower(w[1])=="release" or string.lower(w[1])=="default" or string.lower(w[1])=="clear" then
    Note("Filters set to defaults.")
    set_default_filters()
    return

  elseif string.lower(w[1])=="all" then
    Note("All filters enabled.")
    enable_all_filters()
    return

  elseif string.lower(w[1])=="none" then
    Note("All filters disabled.")
    disable_all_filters()
    return
  end

  filtername=string.lower(table.concat(w, " ", 1))
  for k, v in pairs(gag) do
    if multiword_is_abbrev(filtername, k, 3) then
      match=k
    end -- if provided string matches existing filter
  end -- filter table iteration

  if match or gag[filtername]~=nil then
    if match==nil then
      match=filtername
    end
    if gag[match]==false then
      gag[match]=true
      Note("Filter " ..match.. " enabled.")
    elseif gag[match]==true then
      gag[match]=false
      Note("Filter " ..match.. " disabled.")
    end -- toggle the option
  else
    Note("Sorry, no filter with that name exists.")
  end -- if match exists or filtername is a direct table key

end -- function

function table_shallow_copy(t1)
  local t2 = {}
  for k,v in pairs(t1) do
    t2[k] = v
  end
  return t2
end

function recastdefault_single_spell(setname, spellname)
  if recast[setname][spellname] == nil then
    recast[setname][spellname]=false
  end
end

function recastdefaults(setname)
 recast[setname] = nil
 recast[setname] = {}

 recastdefault_single_spell(setname, "strength")
 recastdefault_single_spell(setname, "dexterity")
 recastdefault_single_spell(setname, "presence")
 recastdefault_single_spell(setname, "detect evil")
 recastdefault_single_spell(setname, "detect undead")
 recastdefault_single_spell(setname, "curse ward")
 recastdefault_single_spell(setname, "still air")
 recastdefault_single_spell(setname, "feather fall")
 recastdefault_single_spell(setname, "dying breath")
 recastdefault_single_spell(setname, "sanctuary")
 recastdefault_single_spell(setname, "faith shield")
 recastdefault_single_spell(setname, "water breathing")
 recastdefault_single_spell(setname, "detect poison")
 recastdefault_single_spell(setname, "crystal coat")
 recastdefault_single_spell(setname, "foulblood")
 recastdefault_single_spell(setname, "rancid flesh")
 recastdefault_single_spell(setname, "ironblood")
 recastdefault_single_spell(setname, "dread portent")
 recastdefault_single_spell(setname, "dying breath")
 recastdefault_single_spell(setname, "bless")
 recastdefault_single_spell(setname, "ground")
 recastdefault_single_spell(setname, "fire shield")
 recastdefault_single_spell(setname, "ice shield")
 recastdefault_single_spell(setname, "protection from evil")
 recastdefault_single_spell(setname, "armor")
 recastdefault_single_spell(setname, "infravision")
 recastdefault_single_spell(setname, "detect invisibility")
 recastdefault_single_spell(setname, "sense life")
 recastdefault_single_spell(setname, "invisibility")
 recastdefault_single_spell(setname, "shield")
 recastdefault_single_spell(setname, "displacement")
 recastdefault_single_spell(setname, "fly")
 recastdefault_single_spell(setname, "darken")
 recastdefault_single_spell(setname, "conceal alignment")
 recastdefault_single_spell(setname, "thorn armor")
 recastdefault_single_spell(setname, "thorn armor")
 recastdefault_single_spell(setname, "mana shield")
 recastdefault_single_spell(setname, "diffraction")
 recastdefault_single_spell(setname, "vigor")
 recastdefault_single_spell(setname, "fortitude")
 recastdefault_single_spell("walk on water")
end

function recast_options(name, line, wildcards)
  sanity_check_recast_vars()
  choices={}
  if recast.active=="none" then
    Note("There is no active recast set! A default one will be created for you.")
    recast.active="default"
    recastdefaults(recast.active)
  end --no active set

  repeat

    for k, v in pairs (recast[recast.active]) do
      local val =v
      if val==true then
        cstr=k.." - enabled"
      end --value true
      if val==false then
        cstr=k.." - ".."disabled"
      end --false
      choices[k]=cstr
    end --loop

    result = utils.choose("Choose a spell to change its setting. all changes will be applied once you click cancel", "Spells for the "..recast.active.." set",choices,result)
    -- if not cancelled, go to appropriate handler
    if result then
      edit_recast(result)
    end -- if they chose something

  until not result -- loop until dialog cancelled
  Note("Changes saved.")
end -- function recast_options

function edit_recast(name)
  confname=name
  val=recast[recast.active][name]
  if val==true then
    default = 1 -- default to "Yes" button
  elseif val==false then
    default = 2 -- default is "No" button
  end
  if default~=0 then
    response =utils.msgbox(name.."?", "Change option", "yesnocancel", "?", default)
    if response == "cancel" then
      return
    end -- if cancelled
    if response == "yes" then
      recast[recast.active][name]=true
    elseif response=="no" then
      recast[recast.active][name]=false
    end
  end
end


-------------------------------------------------------------
-- string processing
-------------------------------------------------------------

function is_abbrev(test_string, reference_string, minimum_length)
  test_string = string.lower(test_string)
  reference_string = string.lower(reference_string)
  minimum_length = minimum_length + 1

  local i = 1

  while true do
    local t = string.sub(test_string, i, i)
    local r = string.sub(reference_string, i, i)

    -- we've reached the end of our test string, or the end of the first word
    if (t == nil or t == "" or t == " ") then
      if (i >= minimum_length) then
        return true
      end
      -- we've also reached the end of the reference string, so we're good
      if (r == nil or r == "" or r == " ") then
        return true
      end
      return false
    end

    -- mismatch/fail
	if (t ~= r) then
      return false
    end

    i = i + 1
  end
  return false
end

function next_arg(string)
  if string == nil then
    return nil
  end

  local i = 1

  -- nuke spaces at start of the string
  while true do
    local ch = string.sub(string, i, i)
    if (ch == nil or ch == "") then
      return nil
    end
    if (ch ~= " " and ch ~= "\t") then
      break
    end
    i = i + 1
  end

  -- skip forward until we hit a space or termination
  while true do
    local ch = string.sub(string, i, i)
    if (ch == nil or ch == "") then
      return nil
    end
    if (ch == " " or ch == "\t") then
      break
    end
    i = i + 1
  end

  -- skip spaces at end of the string
  while true do
    local ch = string.sub(string, i, i)
    if (ch == nil or ch == "") then
      return nil
    end
    if (ch ~= " " and ch ~= "\t") then
      break
    end
    i = i + 1
  end

  -- return trailing part of the string
  return string.sub(string, i)
end


function multiword_is_abbrev(input_string, reference_string, length)
  while (reference_string ~= nil) do
    if (is_abbrev(input_string, reference_string, length)) then
      return true
    end
    reference_string = next_arg(reference_string)
  end
  return false
end


-------------------------------------------------------------
-- config menu
-------------------------------------------------------------

function config_update_sync(string)
  if settings[string].status==false then

    if string=="areamusic" then
      ppi.slideVol(0,areamusic_playout_device_id,500)
      DoAfterSpecial(0.5,'set_areamusic()',12)
    end
    if string=="ambience" then
      ppi.slideVol(0,ambience_playout_device_id,500)
      DoAfterSpecial(0.5,'play_time_ambience()',12)
    end

    if string=="praccing" then
EnableGroup("show",1)
expInfo.practices.showCostNoEcho=true--set variable to gag  the trigger 'show cost | prefix tnl'
PSend("show cost | prefix tnl")
end

    return
  end

  if settings[string].status == true then
    if string=="praccing" then
      classtnl="none"
      exptnl=0
      k_exp()
    end

    if string=="areamusic" then
      set_areamusic()
    end
    if string=="ambience" then
      play_time_ambience()
    end

    return
  end
end

function check_visible(confname)
  -- This is where code to enable or disable the visibility of config options should go.
  -- This gets called with the name of the setting every time one is toggled
  -- Config options that depend on the status of other options for visibility are automatically set at startup with check_all_visible
  -- FIXME: This method probably gets called twice, once for the config functions changing values, once when low-level ss is called... Should rip out all calls that config makes, check that they all use ss, then let that do it's job... Later...
  if confname=="clannotify" then
    if settings[confname].status==false then
      settings.clanfame.visible=false
      settings.clanactive.visible=false
      settings.clansize.visible=false
      settings.clanpk.visible=false
    elseif settings[confname].status==true then
      settings.clanfame.visible=true
      settings.clanactive.visible=true
      settings.clansize.visible=true
      settings.clanpk.visible=true
    end -- toggle subsetting visibility
  end -- if string is clannotify
  -- comlog
  if confname=="comlog" then
    if settings[confname].status==true then
      settings.comlogchans.visible=true
      settings.comlogclan.visible=true
      settings.comlogtells.visible=true
      settings.comlogfriends.visible=true
    elseif settings[confname].status==false then
      settings.comlogchans.visible=false
      settings.comlogclan.visible=false
      settings.comlogtells.visible=false
      settings.comlogfriends.visible=false
    end -- enable / disable
  end -- comlog
  if confname=="soulsteal" then
    if settings[confname].status==true then
      settings.soulaction.visible=true
      if settings.soulaction.status==3 then settings.sellstruggle.visible=true end
    elseif settings[confname].status==false then
      settings.soulaction.visible=false
      if settings.sellstruggle.visible==true then settings.sellstruggle.visible=false end
    end
  end -- soulsteal
  if confname=="soulaction" then
    if settings[confname].status==3 then
      settings.sellstruggle.visible=true
    elseif settings[confname].status~=3 then
      settings.sellstruggle.visible=false
    end -- show / hide
  end -- soul action
  if confname=="deathaction" then
    if settings[confname].status==true then
      settings.deathactionbloodsac.visible=true
      settings.deathactionharvestteeth.visible=true
      settings.deathactionconsume.visible=true
      settings.deathactionspellcomp.visible=true
      settings.deathactionsalvage.visible=true
    elseif settings[confname].status==false then
      settings.deathactionbloodsac.visible=false
      settings.deathactionharvestteeth.visible=false
      settings.deathactionconsume.visible=false
      settings.deathactionspellcomp.visible=false
      settings.deathactionsalvage.visible=false
    end
  end -- death action
end -- function


-------------------------
function edit_option(name)
  confname=name
  val=settings[name].status
  info = args[name]

  if type(val)=="string" then
    response = utils.inputbox(config_menu_data[name].desc.."?", "Input", "")
    if not response then
      return
    end -- if cancelled
    settings[name].status=response
    Note(name.." changed.")
    check_visible(name)
    config_update_sync(name)
    return
  end

  if type(val)=="boolean" then
    if val==true then
      default = 1 -- default to "Yes" button
    elseif val==false then
      default = 2 -- default is "No" button
    end
  else
    default=0
  end

  if default ~= 0 then
    response =utils.msgbox(config_menu_data[name].desc.."?", "Change option", "yesnocancel", "?", default)
    if response == "cancel" then
      return
    end -- if cancelled

    if response == "yes" then
      settings[name].status=true
      Note(name.." enabled.")
      check_visible(name)
      config_update_sync(name)
    end
    if response=="no" then
      settings[name].status=false
      Note(name.." disabled.")
      check_visible(name)
      config_update_sync(name)
    end
    return
  end

  response=utils.choose(config_menu_data[name].desc,"Change option",args[name],val)
  if response == nil then
    return
  end -- if cancelled
  settings[name].status=response
  Note(name.." changed.")
  check_visible(name)
  config_update_sync(name)
end


-------------------------
function config_options()
  repeat
    choices={} -- put this inside the loop so config options that are invisible get properly omitted, it's rerunning the iteration, anyways
    for k, v in pairs (settings) do
      --print(k,v)
      if config_menu_data[k] ~= nil and config_menu_data[k].desc~= nil and settings[k].visible~=false then -- if this option has a name, a description, and isn't set to be invisible
        local sname = config_menu_data[k].desc
        local val = gs(k)

        if type(val) ~= "boolean" then
          if type(val) == "string" then
            choices[k] = sname.." - "..val
          else
            choices[k] = sname.." - "..args[k][val]
          end

        else
          if val == true then
            str = "enabled"
          else 
            str = "disabled"
          end --false
          choices[k] = sname.." - "..str
        end --not boolean

      end --has a name
    end --for loop

    result = utils.choose (
      "To change an option, navigate to it in the list, then press enter (or click OK).\r\n\r\nTo quickly change an option without using the configuration list,\r\ntype config [option name] in the world window.\r\n\r\nPress escape (or click cancel) when done to save your settings.", "Options",choices,result)

    -- if not cancelled, go to appropriate handler
    if result then
      edit_option(result)
    end -- if they chose something
 
  until not result -- loop until dialog cancelled
  Note("Changes saved.")
end -- function config_options


-------------------------
function config_option_parse(string)
  if (multiword_is_abbrev(string, "release default clear", 5)) then
    configure_default_settings()
    return
  end
  if (multiword_is_abbrev(string, "help list", 4)) then
    config_options()
    return
  end

  if (multiword_is_abbrev(string, "minimal", 3)) then
    configure_minimal_settings()
    return
  end

  if string=="mud" then
Note("Configuring the mud for Mush-Z:")
    Send("autosize | prefix mzscr")
    Send("autosplit | prefix mzscr")
    Send("autotick | prefix mzscr")
    Send("notify | prefix mzscr")
    Send("set prompt off")
    Send("autodoor | prefix mzscr")
    Send("set blind on | prefix mzc")
    Send("set pageb none | prefix mzc")
    return
  end

  if string == "" then
    config_options()
    return
  end

  -- Check if string exactly matches a setting
  if settings[string] ~= nil then
    config_toggle_single_setting(string)
    return
  end

  -- look up the setting based on its keywords
  for k, v in pairs (config_menu_data) do
    -- Note("K "..k..", vx "..v.keywords..", vy "..v.desc)
    if (multiword_is_abbrev(string, v.keywords, 4)) then
      config_toggle_single_setting(k)
      return
    end
  end

  Note("Unrecognized setting - Type config for a list.")
  return
end


-------------------------
function config_toggle_single_setting(string)
  if settings[string].visible==false then
    Note("This option appears to be disabled, it won't take affect until it's enabled by another config option.")
  end
  if settings[string].status == true then
    settings[string].status=false
    check_visible(string)
    Note(string.." disabled.")
    config_update_sync(string)
    return
  end

  if settings[string].status==false then
    settings[string].status=true
    check_visible(string)
    Note(string.." enabled.")
    config_update_sync(string)
    return
  end

  edit_option(string)

end


-------------------------
function edit_additional(pbranch,pname,pq)
  if confname==pbranch then
    val=settings[pname].status
    if val==true then
      default = 1 -- default to "Yes" button
    elseif val==false then
      default = 2 -- default is "No" button
    else
      default=0
    end --default
    response =utils.msgbox(pq, "Additional settings", "yesnocancel", "?", default)
    if response == "cancel" then
      return
    end -- if cancelled
    if response == "yes" then
      settings[pname].status=true
      check_visible(name)
    elseif response=="no" then
      settings[pname].status=false
      check_visible(name)
    end --response
  end --if confname
end


-------------------------------------------------------------
-- miscellaneous
-------------------------------------------------------------

function convert_charlist()
  -- Function to convert an old, number-style charlist table to the newstyle, subtable system and keep the resulting playernames
  if charlist==nil then -- This function shouldn't even be running
    charlist={}
    return
  end 
  newcharlist={}
  for k, v in pairs(charlist) do
    newcharlist[v]={}
  end
charlist=newcharlist
end --function

function resetspells()
  rct={}
  rmt={}
  rmt["ironblood"]=18
  rmt["faith shield"]=23
  rmt["darken"]=42
  rmt["slow poison"]=35
  rmt["water breathing"]=20
  rmt["strength"]=16
  rmt["dexterity"]=20
  rmt["presence"]=18
  rmt["detect evil"]=12
  rmt["detect poison"]=12
  rmt["detect undead"]=18
  rmt["curse ward"]=35
  rmt["still air"]=29
  rmt["feather fall"]=12
  rmt["crystal coat"]=35
  rmt["foulblood"]=21
  rmt["rancid flesh"]=30
  rmt["dread portent"]=15
  rmt["dying breath"]=47
  rmt["bless"]=20
  rmt["protection from evil"]=15
  rmt["armor"]=8
  rmt["invisibility"]=45
  rmt["shield"]=18
  rmt["sanctuary"]=75
  rmt["fly"]=25
  rmt["ground"]=35
  rmt["fire shield"]=35
  rmt["ice shield"]=35
  rmt["displacement"]=30
  rmt["infravision"]=12
  rmt["detect invisibility"]=12
  rmt["sense life"]=15
  rmt["conceal alignment"]=37
  rmt["thorn armor"]=35
  rmt["mana shield"]=8
  rmt["diffraction"]=38
  rmt["vigor"]=13
  rmt["fortitude"]=19
  rmt["walk on water"] = 15
end

function rectimer()
  if not gs("recast") then
    return
  end
  if not gs("recastsleeping") and pose == "sleep" then
    return
  end
  if nocastdeathly == 1 or kxwt_action == 1 then
    return
  end
  if nfight==1 or nocastroom==true then return end
  if afk == 1 then
    rct = {}
    return
  end
  for i,v in pairs(rct) do
    if rct[i]==2 then
      know=""
      for w in string.gmatch(i, "%S+") do
        know=know..w
      end --for word
      if kspells[know]==1 then
        if k_mana>=rmt[i] then
          rcspell(i)
          break
        else
          if(prevpose~="stand" and pose~=prevpose) then
            Send(prevpose)
            prevpose="stand"
          end --prevpose
          return
        end --k_mana
      end --know spells
    end --if it's true
  end --for
  if table.size(rct)>1 then
    castlast=false
  elseif table.size(rct)==1 then
    castlast=true
  elseif table.size(rct)<1 then
    if castlast then
      if(prevpose~="stand" and pose~=prevpose) then
        Send(prevpose)
        prevpose="stand"
      end --prevpose
      castlast=false
    end --castlast
  end --if table size
end --function

function rcspell(wtc)
  if recast.active~=nil then
    if recast[recast.active][wtc]~=true then
      if recast[recast.active][wtc]==nil then
        if IsInTable(truespells,wtc)==1 then
          recast[recast.active][wtc]=true
        else
          recast[recast.active][wtc]=false
        end
      end
      rct[wtc]=nil
      return
    end
  end
  if gs("recast")==true then
    if pose~="stand" then
      prevpose=pose
      ESend("stand")
    end --prevpose
    rct[wtc]=1
    ESend("c "..wtc)
    ESend("lecho mz_spelltest ("..wtc..")")
  else
    rct[wtc]=nil
  end
end -- function

function table.contains(table, element)
for _, value in pairs(table) do
    if value == element then
      return true
    end
  end
  return false
end

function table.haskey(table, element)
for k, _ in pairs(table) do
    if k == element then
      return true
    end
  end
  return false
end

function procmap(n,l,w)
if mvtime then
if k_move>65 and pose~="stand" then
Send("stand")
Send(curmap[1].." | tail 1 | prefix moving")
EnableTimer("maptimer",false)
return
end --move
if fight==0 then
Send(curmap[1].." | tail 1 | prefix moving")
EnableTimer("maptimer",false)
return
end --fight
end --mapping
end --func

function pmap()
if backtrack==nil then backtrack={}
end
if rooms[k_lastroom]~=nil then
toinsert=false
if table.contains(backtrack,k_room) then
toinsert=true
end
if (#backtrack<1 or toinsert) then
table.insert(backtrack,1,{k_room,ldir[lastdir]})
end
if rooms[k_lastroom]==nil then
else
rooms[k_lastroom][dirs[lastdir]]=k_room
rooms[k_room][dirs[ldir[lastdir]]]=k_lastroom
end
end
if mtime then
table.insert(curmap,lastdir)
end

end

function idtime(n,l,w)
if idlevel~=nil then
idlevel=string.gsub(idlevel,"(you can't use this yet)"," ")
else
idlevel=""
end
if iidflags==nil then
iidflags=""
end
if type(iworn)=="nil" then
iworn=""
end
if not iquality then iquality="" end
toprint=idlevel.." "..iquality.." "..iworn..", "..iidflags..""
if iacapply~=nil then
if not gs("shortidcomma") then toprint=toprint.." ac "..iacapply.." "
end
if gs("shortidcomma") then toprint=toprint..", ac "..iacapply..", "
end
end
if iaffects~=nil then
for k, v in ipairs(iaffects) do
if not gs("shortidcomma") then
toprint=toprint.." "..iaffects[k]
end
if gs("shortidcomma") then
toprint=toprint..", "..iaffects[k]
end
end
end
if settings.shortid.status==2 then
print(toprint)
end
if (gs("shortid")==3 or gs("shortid")==2) then
Execute("history_add shortID="..toprint)
if gs("shortall") then
Execute("history_add all="..toprint)
end
end
iidflags=nil
iacapply=nil
iworn=nil
idname=nil
idlevel=nil
iaffects=nil
iquality=nil
end

function movemapnow()
if #curmap<=0 then
Note("You have reached your destination!")
Note('that took ',os.clock()-c1..'s')
mvtime=false
mapnow=false

insertqueue=""
if not mback then
curmap=mapback
end
mback=false
return
end
if IsInTable(validdirs,curmap[1])==1 then
if not mback then table.insert(mapback,1,ldir[curmap[1]])
if insertqueue~="" then
table.insert(mapback,1,insertqueue)
insertqueue=""
end
end
Send(curmap[1].." | tail 1 | prefix moving")
else
mapnow=true
Send(curmap[1].." | tail 1")
if (string.find(curmap[1],"enter") or string.find(curmap[1],"climb")) then
if not mback then table.insert(mapback,1,curmap[1]) end
table.remove(curmap,1)
if not mback then
if insertqueue~="" then
table.insert(mapback,1,insertqueue)
insertqueue=""
end
end
else
insertqueue=curmap[1]
table.remove(curmap,1)
movemapnow()
end--stringfind
end--stringtype
end --move function

function idnote(n,l,w)
if (gs("shortid")==3 or gs("shortid")==1) then
Note(l)
end
end

function nearest()
udirs={}
unexplored={}
for k,v in pairs(backtrack) do
if v[1]~=k_room then
for kk,vv in pairs(rooms[v[1]]) do
if vv=="unexplored" then
table.insert(unexplored,walkdirs[kk])
break
elseif vv=="door" then
table.insert(unexplored,walkdirs[kk])
break
end --unexplored
end --for
if #unexplored==0 then
table.insert(udirs,v[2])
end --#unexplored
else
table.insert(udirs,v[2])
end --not k_room
end --for
Note(table.concat(udirs," "))
Note(unexplored[1])
end --function

--------------------------------------------------------------------
-- miscellaneous
--------------------------------------------------------------------

function t_disarm(n,l,w)
  if not gag.combat then Note(l) end
  Sound(sdir.."combat/parry/" .. math.random(1, tparry) .. ".ogg")
end

function wayadd(n,l,w)
n=tonumber(w[2])
way=w[4]
if (way=="A tranquil shrine") then
ways["tranq"]=n
table.insert(ways2, "tranq")
elseif (way=="A vine covered temple") then
ways["vine"]=n
table.insert(ways2, "vine")
elseif (way=="The inside of a small cabin") then
ways["cabin"]=n
table.insert(ways2, "cabin")

elseif (way=="A small meditation room") then
ways["small med"]=n
table.insert(ways2, "small med")
elseif (way=="The Unholy Temple of Dentin") then
ways["unholy"]=n
table.insert(ways2, "unholy")
elseif (way=="Recall") then
ways["mudschool"]=n
table.insert(ways2, "mudschool")

elseif (way=="The Temple of Zin") then
ways["zin"]=n
table.insert(ways2, "zin")
elseif (way=="Inside the Chapel") then
ways["chapel"]=n
table.insert(ways2, "chapel")
elseif (way=="A shrine to Dentin") then
ways["std"]=n
ways["s2d"]=n
ways["shrine"]=n
table.insert(ways2, "s2d")
elseif (way=="On the steps of Aomizu Temple") then
ways["aomizu"]=n
table.insert(ways2, "aomizu")
elseif (way=="The temple to Morpheus") then
ways["morph"]=n
table.insert(ways2, "morph")
elseif (way=="Warming before the hearth") then
ways["hearth"]=n
table.insert(ways2, "hearth")
elseif (way=="City of Airam, Town Square") then
ways["airam"]=n
table.insert(ways2, "airam")
else
Sound(sdir.."grouping/beckon.ogg")
ways[way]=n
table.insert(ways2, way)
end
end

function spellfall(spell, person)
if kxwt_players[person] ~= nil then
if gs("spellsfall") == 3 or gs("spellsfall") == 4 then -- log group member spellfall messages to all buffer
Execute("history_add all="..person.."'s "..spell.." fell.")
end
Execute("history_add spells="..person.."'s "..spell.." fell.")
if(gs("grecast")==true) then
if (pose~="stand") then
prevpose=pose
PSend("stand")
end
Execute("c "..spell.." "..person)
if(prevpose~="stand") then
PSend(prevpose)
prevpose="stand"
end
end
end
end

function death_exp(nowexp)
 if deadmob ~= 1 then
  return
 end
 Execute("history_add experience="..ntrunk(nowexp).." xp from "..deadmobname)
 if gs("expall") then
  Execute("history_add all="..ntrunk(nowexp).." xp from "..deadmobname)
 end
 gclear()
 if k_cap then
  nowexp = tonumber(nowexp)
  if (kskills["cryofvictory"] == 1) then
   _vic_state = 1
   Send("victory")
  end --if cry of victory
  if nowexp>k_cap then
   ppi.play(sdir.."notifications/overcap.ogg",0,0,ppi.getVolume()+25)
  elseif nowexp==k_cap then
   Sound(sdir.."notifications/cap.ogg")
  elseif nowexp < k_cap and nowexp >= k_cap/2 then
   ppi.play(sdir.."notifications/halfcap.ogg",0,0,ppi.getVolume()+100)
  elseif nowexp < k_cap/2 then
   ppi.play(sdir.."notifications/crapexp.ogg",0,0,ppi.getVolume()+50)
  end --cap sounds
 end --if cap is nil
end --function

function gclear()
gfighting=0
assisting=0
restime=0
hitting="trip"
EnableTimer("grtimer", false)
end

function exitstd(n,l,wildcs)
exitst(n,l,wildcs)
Sound(sdir.."notifications/doors.ogg")
if (gs("exitcomma") == true) then
 doors_msg = Replace(wildcs[2], " ", ", ", true)
else
 doors_msg = wildcs[2]
end
Note("Doors "..doors_msg)
if rooms[k_room]~=nil then
for w in string.gmatch(wildcs[2], "%S+") do
if dirs[w] ~= nil and rooms[k_room][dirs[w]]==nil then
rooms[k_room][dirs[w]]="door"
end --rooms w
end
end
end

function exitsm(n,l,w)
  if mapnow then mapnow=false end
  EnableTimer("maptimer",false)
  adir=adir+1
  PanSnd(adir,maxdir,sdir.."pm/map.ogg")
  if (amb1[terrain] == nil) then
    ssrandom=math.random(1,9)
  else
    ssrandom=math.random(1,amb1[terrain])
  end
  Sound(sdir.."steps/"..terrain.."/"..ssrandom..".ogg")
  table.remove(curmap,1)
  if #curmap<=0 then
    Note("You have reached your destination!")
    Note('that took ',os.clock()-c1..'s')
    Send("look")
    mapnow=false
    mvtime=false
    insertqueue=""
    if not mback then
      curmap=mapback
    end
    mback=false
    return
  else
    if k_move<20 then
      EnableTimer("maptimer",true)
      if kspells["refresh"]~=1 then
        Send("rest")
        return
      end
      if grouped==1 then
        if kspells["arearefresh"]==1 then
          Execute("c area refresh")
        elseif kspells["refresh"]==1 then
          Execute("c refresh")
        else
          Send("rest")
        end --area
      else
        if kspells["refresh"]==1 then
          Execute("c refresh")
        end --know refresh
      end --grouped
      return
    end --move
    movemapnow()
  end --curmap length
end --func

function movemore(pos)
table.remove(curmap,1)
Send(curmap[1].." | tail 1 | prefix moving")
if pos~=0 then
table.insert(mapback,pos,ldir[curmap[1]])
end
end

function rstuff()
  if gs("antigroundstringspam")==true then
    for item in pairs(roomstuff) do
if (gs("showsize")==true) then
      if (roomstuff[item].count==1) then
        styleNote(roomstuff[item].styles)
      elseif roomstuff[item].count>1 then
        Tell("x"..roomstuff[item].count..":")
        styleNote(roomstuff[item].styles)
      end --if
elseif (gs("showsize")==false) then
      if (roomstuff[item].count==1) then
Note(roomstuff[item].styles)
      elseif roomstuff[item].count>1 then
Note("x"..roomstuff[item].count.." "..roomstuff[item].styles)
      end --if
end --showsize false
    end --for
    roomstuff={}
  end
end -- function

function exitst(n, l, wildcs)
  --[[FIXME
THIS SHIT NEEDS AN EXPLINATION!
I understand it but shouldn't have to hunt around.
- Dernan]]
  rstuff()
  if (gs("exitcomma") == true) then
    exits_msg = Replace(wildcs[1], " ", ", ", true)
  else
    exits_msg = wildcs[1]
  end
  for w in string.gmatch(wildcs[1], "%S+") do
    if dirs[lastdir]==nil then
      
    else
      if rooms[k_room]==nil then
        
      else
        if dirs[w]~=nil then
          if rooms[k_room][dirs[w]]==nil then
            rooms[k_room][dirs[w]]="unexplored"
          end --rooms w
        end
      end
      k_lastroom=k_room
    end
  end
  if mapnow then
    mapnow=false
    movemapnow()
  end
  if mtime then
    if ldir[curmap[#curmap-1]]==lastdir then
      Note("Last direction removed.")
      table.remove(curmap)
      table.remove(curmap)
    end
  end
  if newchar==1 then
    newchar=0
    Execute("config mud")
    login()
    PSend("channel listen zt | prefix mzc")
    Note("Configuring new character...")
  end
  afk=0
  gfighting=0
  if (dispelling==1) then
    dispelling=0
  end
  if (grouped==1) then
    gclear()
  end
  if (#players>1) then
    count=#players-1
    if #players>0 then
      Note(table.concat(players, ", ", 1, count)..", and "..players[#players]..".")
    end
  else
    Note(table.concat(players, ", "))
  end
  players = {}
  if (gs("speedwalk") == true) then
    require "wait"
    wait.make(function()
      wait.time(0.2)
      Execute("tts_stop")
      Execute ("tts_note "..exits_msg)
    end)
  end
  if (gs("exits") == 1) then
    Note(exits_msg)
  elseif (gs("exits") == 2) then
    require "wait"
    wait.make(function()
      exits = wildcs[1]
      for w in string.gmatch(exits, "%a+") do
        wait.time(0.2)
        Sound(sdir.."exits/"..w..".ogg")
      end
    end)
  end
  if (amb1[terrain] == nil) then
    ssrandom=math.random(1,9)
  else
    ssrandom=math.random(1,amb1[terrain])
  end
  Sound(sdir.."steps/"..terrain.."/"..ssrandom..".ogg")
  if autogo==1 then
    ext=split(wildcs[1]," ")
    if #ext>2 then
      autogo=0
      Execute("tts_interrupt reached intersection. "..wildcs[1])
      return
    end --exits more than 2.
    if #ext==1 then
      autogo=0
      Execute("tts_interrupt dead end.")
    end --one exit
    if #ext==2 then
      if (ext[1]~=ldir[lastdir]) then Send(ext[1]) lastdir=ext[1]
        if mtime then
          table.insert(curmap,ext[1])
        end
      elseif (ext[2]~=ldir[lastdir]) then Send(ext[2]) lastdir=ext[2] 
        if mtime then
          table.insert(curmap,ext[2])
        end
        --elseif ext[1]==lastdir and ext[1]==ldir.lastdir then Send(ext[1]) lastdir=ext[1]
        --elseif ext[2]==lastdir and ext[2]==ldir.lastdir then Send(ext[2]) lastdir=ext[2]
        --elseif ext[1]~=ldir.lastdir then Send(ext[1]) lastdir=ext[1] 
        --elseif ext[2]~=ldir.lastdir then Send(ext[2]) lastdir=ext[2]
      end
    end --2 exits
  end --autogo
end --function


---------------------------------------------------------------------------------
-- global remapping table for sound files
---------------------------------------------------------------------------------

function soundfile_init()
  areaname = "global"
  areanumber = -1
  last_area_sound_filename = "none"
  last_background_ambience_filename = "none"
end

function initialize_soundfile_aliases()
  soundfile_init()

  areamusic_map_table = {}

  areamusic_map_table[1910] = "Ethereal plane of fire"
  areamusic_map_table[1070] = "Ethereal plane of fire"
  areamusic_map_table[6130] = "Ethereal plane of fire"
  areamusic_map_table[6180] = "Ethereal plane of fire"
  -- I like this audio for the noob cave on sloe as well
  areamusic_map_table[5010] = "Ethereal plane of fire"

  areamusic_map_table[1220] = "death knights"
  areamusic_map_table[6060] = "Dark Forest East"
  areamusic_map_table[ 520] = "dark forest"
  areamusic_map_table[5020] = "In a crypt"
  areamusic_map_table[6470] = "In a crypt"
  areamusic_map_table[ 980] = "You are in a graveyard on the island of Kordan."

  areamusic_map_table[3430] = "cornia"
  areamusic_map_table[3960] = "malitad"
  areamusic_map_table[ 210] = "The Fishing Village"
  areamusic_map_table[5004] = "The Druid's Sanctuary"
  areamusic_map_table[2580] = "Svirfneblin Colony"
  areamusic_map_table[ 660] = "Caves and Forest south of Old Thalos"
  areamusic_map_table[6510] = "Caves and Forest south of Old Thalos"
  areamusic_map_table[4110] = "beh'rzok"
  areamusic_map_table[4120] = "beh'rzok"

  areamusic_map_table[1320] = "Leprechauns"
  areamusic_map_table[1710] = "milano"
  areamusic_map_table[ 930] = "samurais"
  areamusic_map_table[1820] = "Mob Factory"
  areamusic_map_table[ 110] = "The Southern Desert"
  areamusic_map_table[3860] = "The Southern Desert"
areamusic_map_table[2140] = "Iron Sea"
areamusic_map_table[3970] = "Salt Flats"
areamusic_map_table[2250] = "Wind Tunnels"
areamusic_map_table[6530] = "West Thalenwood Forest"
--NM plane music strings
  areamusic_map_table[5090] = "The Obsidian Fortress & Dark Moon Forest"
  -- map vemarken, indira, and dragon tooth to the general area music
  areamusic_map_table[5310] = "You are on the island of Sloe."
  areamusic_map_table[5320] = "You are on the island of Kordan."
  areamusic_map_table[5370] = "You are on the island of Archais."
areamusic_map_table[6830] = "Idlewood"
--Area music strings for changed areas:
  areamusic_map_table[1380] = "You are in the precinct of an ancient crypt on the island of Kordan."
  areamusic_map_table[370] = "You are in the Pit, on the island of Kordan"
  areamusic_map_table[5160] = "Dragon Tooth graveyard & port village"
-- Archais various strings
  areamusic_map_table[5350] = "Naphtali and Gad's Landing"
  areamusic_map_table[5340] = "Naphtali and Gad's Landing"
  areamusic_map_table[460]  = "Archais Cave System"
  areamusic_map_table[70]   = "Archais Cave System"
  areamusic_map_table[6070]   = "Archais Cave System"
--Arcadia
areamusic_map_table[5460] = "Arcadia"

  background_ambience_map_table = {}

  background_ambience_map_table["stream/day"]        = "water/day"
  background_ambience_map_table["beach/day"]         = "ocean/day"
  background_ambience_map_table["cave/day"]          = "cave/night"

  background_ambience_map_table["city/day"]          = "town/day"

  background_ambience_map_table["city/night"]        = "town/night"
  background_ambience_map_table["building/night"]    = "town/night"
  background_ambience_map_table["underground/night"] = "town/night"
end


---------------------------------------------------------------------------------
-- areamusic handlers
---------------------------------------------------------------------------------

function get_areamusic_filename()
  -- look up area number in our mapping table first
  local temp = areamusic_map_table[areanumber]
  if (temp ~= nil) then
    local area_sound_filename = sdir.."music/area/"..temp..".ogg"
    if (FileExists(area_sound_filename)) then
      return area_sound_filename
    end
  end

  -- look up filename directly from incoming area name
  if (areaname ~= nil) then
    local area_sound_filename = sdir.."music/area/"..areaname..".ogg"
    if (FileExists(area_sound_filename)) then
      return area_sound_filename
    end
  end

  if gs("globalareamusic") then
    local area_sound_filename = sdir.."music/area/global.ogg"
    return area_sound_filename
  end

  return nil
end


function set_areamusic()
  -- check to see if areamusic is shut off
  if gs("areamusic")~=true then
    if areamusic_playout_device_id~=11 then
      ppi.stop(areamusic_playout_device_id)
      last_area_sound_filename = nil
    end
    return
  end

  -- start or stop playout if we have a filename
  local area_sound_filename = get_areamusic_filename()
  if (area_sound_filename == nil) then
    if areamusic_playout_device_id~=11 then
      ppi.stop(areamusic_playout_device_id)
      last_area_sound_filename = nil
    end
  else
    -- Note("Got area sound filename '"..area_sound_filename.."'")
    if (last_area_sound_filename ~= area_sound_filename) then
      if areamusic_playout_device_id~=11 then
        ppi.stop(areamusic_playout_device_id)
        last_area_sound_filename = nil
      end
      areamusic_playout_device_id=ppi.playLooped(area_sound_filename)
    end
  end

  last_area_sound_filename = area_sound_filename
  resetvol()
end


---------------------------------------------------------------------------------
-- background ambience audio
---------------------------------------------------------------------------------

function get_background_ambience_filename()
  local fname_root = terrain.."/"..daynight

  -- try to find a file on disk first
  local fname = sdir.."ambience/"..fname_root..".ogg"
  if (FileExists(fname)) then
     --Note("Got existing background sound filename '"..fname.."'")
     return fname
  end

  -- look up the terrain/time in the mapping table
  local temp = background_ambience_map_table[fname_root]
  if (temp ~= nil) then
    fname = sdir.."ambience/"..temp..".ogg"
    if (FileExists(fname)) then
       --Note("Got map table background sound filename '"..fname.."'")
       return fname
    end
  end

  -- no file, and no valid entry in mapping table
  -- generate and return the default
  fname = sdir.."ambience/default_wilderness_"..daynight..".ogg"
  --Note("Using default background sound filename '"..fname.."'")
  return fname
end

function play_time_ambience()
  -- check for config disable
  if (gs("ambience") ~= true) then
    last_background_ambience_filename = "none"
    ppi.stop(ambience_playout_device_id)
    return
  end

  -- grab filename and check to see if its different
  local fname = get_background_ambience_filename()
  --Note("Got ambient background sound filename '"..fname.."'")
  if (last_background_ambience_filename == fname) then
    return
  end
  last_background_ambience_filename = fname

  ppi.stop(ambience_playout_device_id)
  ambience_playout_device_id=ppi.playLooped(fname)
  resetvol()
end

function k_time(n,l,w)
  timenum=tonumber(w[1])
  timestr=w[3]
  if (timenum>360 and timenum<1199) then
    daynight="day"
  else
    daynight="night"
  end
  if daynight~=prev_daynight then
    play_time_ambience()
  end
  prev_daynight=daynight
end --func

function k_terrain(n,l,w)
  tnum=tonumber(w[1])
  if (terrain == terrain_lookup_table[tnum]) then
    -- only update terrain if it's different
    return
  end
  terrain=terrain_lookup_table[tnum]
  if (terrain == nil) then
    terrain="town"
  end
  play_time_ambience()
end


---------------------------------------------------------------------------------
-- kxwt_area handler
---------------------------------------------------------------------------------

function k_killarea(n,l,w)
  if areanumber ~= -1 then
    areanumber = -1
    Sound(sdir.."notifications/change area.ogg")
  end

  areaname="arenas"
  set_areamusic()
end


function k_area(n,l,w)
  if (areanumber ~= tonumber(w[1])) or (areaname ~= w[2]) then
    areanumber = tonumber(w[1])
    Sound(sdir.."notifications/change area.ogg")
  end

  -- we only ever key off the area name, not the number
  if not (areaname == w[2]) then
--[[  --entire xplog block commented out
    if gs("lyday")==nil then
      ss("lyday",os.date("%j"))
    end

    if (exp-areaxp>1000) then
      xplog=io.open(GetInfo(67).."/xp_log.mushz","a+")
      if gs("lyday")~=gs("yday") then
        xplog:write("\\\\r\\\\n")
        xplog:write(os.date("%B %d"),"\\\\r\\\\n")
        xplog:write("\\\\r\\\\n")
      end
      xplog:write("At "..os.date("%H:%M")..": "..areaname..", stayed for "..amins.." minutes and got "..exp-areaxp.." xp.","\\\\r\\\\n")
      xplog:close()
    end
--]]

    EnableTimer("aminutes",false)
    amins=0
    EnableTimer("aminutes",true)

    areaxp=exp

    areaname=w[2]
    set_areamusic()

    backtrack={}
    directions={}
    Note(w[2])
if (gs("unexplored") and not gag.expert) then
Note("use alt z to clear the unexplored map.")
end
  end
end

function k_exp(n,l,w)
if (not w) then
  exp = 0
else
  exp=tonumber(w[1])
  expInfo.exp=tonumber(w[1])
end
if areaxp==0 then areaxp=exp end
if (exp<prevexp) or (exp>prevexp) then
if (tonumber(exptnl)==0 and gs("praccing")==true) then
exptnl=praccost
classtnl="practice"
end
if (gs("bars")~=3) then
if (exp~=0) and (exptnl~=0) then
if not (math.floor(exp/exptnl*100)==prevxpc) then
PanSnd(exp,exptnl,sdir.."pm/xp.ogg")
end
end
prevxpc=math.floor(exp/exptnl*100)
if (exp / exptnl * 100 > 100) then
if not (classtnl=="none") then
if (gs("praccing") == true) then
r="yes"
if (r=="yes") then
play("notifications/millxp",0)
PSend("train prac")
else
Execute("config praccing")
end
else
if classtnl == "practice" then
Note("You can now train a practice!")
else
Note("You can now level "..classtnl.."!")
end
play("notifications/millxp",0)
end
classtnl="none"
end
end
else
if not (classtnl=="none") then
if not (math.floor(exp/exptnl*100)==prevxpc) then
Note("xp "..math.floor(exp/exptnl*100).." percent")
end
prevxpc=math.floor(exp/exptnl*100)
if (exp / exptnl * 100 > 100) then
if (gs("praccing") == true) then
r="yes"
if (r=="yes") then
play("notifications/millxp",0)
PSend("train prac")
else
Execute("config praccing")

end

else
Note("You can now level "..classtnl.." to "..levtnl.."!")
play("notifications/millxp",0)
end
classtnl="none"
end
end
end --exp
prevexp=exp
end --prevexp
end

function fprompt(n, l, w)
k_target=w[3]
k_fp=tonumber(w[1])
if (gs("battlemusic") == true) then

if (gs("musictype")==1) then
if battleplaying~=1 then
ppi.fadeout(battleid,500)
battleid=ppi.play(sdir.."music/"..gs("musictype").."/"..k_cond..".ogg",1)
battleplaying=1
end --battle playing
end --musictype
end --music
if afk==1 then afk=0 end
if (gs("battlemusic")==true) then
if gs("areamusic")==true then
ppi.slideVol(0,areamusic_playout_device_id)
end
end
nfight=1
EnableGroup("combat",1)
if not (k_fp==nil) then
fwp=k_fp
else
Note("debug: fwp failed!")
end
if fwp~=999 then
if not (prevfp == fwp) then
if (gs("bars")~=3) then
PanSnd(fwp,100,sdir.."pm/fp.ogg")
else
Note("mob "..fwp.."percent")
end
end
else
fwp=100
end
prevfp=fwp
--if (IsInTable(fnames,w[11])~=1) then
--table.insert(fnames,w[11])
--if (#fnames>1) then
--if (#fnames~=prevfnames) then
--Note("Now fighting "..#fnames.." oponents.")
--end --prevfnames
--prevfnames=#fnames
--end --1 or more.
--prevfnames=#fnames
--end --multiple oponents
mg=w[2]
if mg=="plural" then mg="neuter" end
fight = 1
getcond(k_fp)
if not k_mcond~=nil then
fc=k_mcond
end
if not (prevfc == fc) then
ppi.play(sdir.."mobcond/"..fc..".ogg",0,50)
Note(fc)
end
if (gs("battlemusic") == true) then
if (gs("musictype")==2) then
if not (prevfc==fc) then
ppi.fadeout(battleid,500)
battleid=ppi.play(sdir.."music/"..gs("musictype").."/"..k_mcond..".ogg",1)
end --prevfc
end --musictype
end --music
prevfc=k_mcond
EnableGroup("combat", 1)
prevhp=tonumber(prevhp)
if (k_hp<prevhp) then
dmg=prevhp-k_hp
--Note(dmg)
end
prevhp=k_hp
end

function getcond(thp)
if thp==999 then
k_mcond="unknown"
return
end
if thp >= 99 then
k_mcond="excellent"
elseif thp >= 90 then
k_mcond="scratches"
elseif thp >= 70 then
k_mcond="small wounds"
elseif thp >= 50 then
k_mcond="quite a few"
elseif thp >= 30 then
k_mcond="big nasty"
elseif thp >= 10 then
k_mcond="pretty hurt"
elseif thp >= 0 then
k_mcond="awful"
else
k_mcond="awful"
end
end

function regenscr()
if not k_maxhp or not k_maxmana or not k_maxmove then return -1 end
 hprsecs = math.floor((k_maxhp - k_hp)/(hpregen/29))
 mnrsecs = math.floor((k_maxmana - k_mana)/(mnregen/29))
 mvrsecs = math.floor((k_maxmove - k_move)/(mvregen/29))
 hpnote = 0
 mnnote = 0
 mvnote = 0
 if (thp >= 100) and (tmn >= 100) and (tmv >= 100) then
  if not gag.misc then
   Note("You are full.")
  end
  Sound(sdir.."notifications/allfull.ogg")
 elseif (thp >= 100) and (tmn >= 100) then
  if not gag.misc then
   Note("hp and mana are full.")
  end
  Sound(sdir.."notifications/hpfull.ogg")
  Sound(sdir.."notifications/manafull.ogg")
  mvnote = 1
 elseif (thp >= 100) and (tmv >= 100) then
  if not gag.misc then
   Note("hp and movement are full.")
  end
  Sound(sdir.."notifications/hpfull.ogg")
  Sound(sdir.."notifications/movefull.ogg")
  mnnote = 1
 elseif (tmn >= 100) and (tmv >= 100) then
  if not gag.misc then
   Note("mana and movement are full.")
  end
  Sound(sdir.."notifications/manafull.ogg")
  Sound(sdir.."notifications/movefull.ogg")
  hpnote = 1
 elseif thp >= 100 then
  if not gag.misc then
   Note("hp is full.")
  end
  Sound(sdir.."notifications/hpfull.ogg")
  mnnote = 1
  mvnote = 1
 elseif tmn >= 100 then
  if not gag.misc then
   Note("mana is full.")
  end
  Sound(sdir.."notifications/manafull.ogg")
  hpnote = 1
  mvnote = 1
 elseif tmv >= 100 then
  if not gag.misc then
   Note("movement is full.")
  end
  Sound(sdir.."notifications/movefull.ogg")
  hpnote = 1
  mnnote = 1
 else
  hpnote = 1
  mnnote = 1
  mvnote = 1
 end
 if mnnote == 1 then
  if mnrsecs < 0 then
   Note("Warning! Your mana regen is negative (" .. mnregen .. ").")
  else
   mnrtime = sec2minz(mnrsecs)
   Note("You'll need about " .. mnrtime .. " to regen mana.")
  end
 end
 if hpnote == 1 then
  if hprsecs < 0 then
   Note("Warning! Your hp regen is negative (" .. hpregen .. ").")
  else
   hprtime = sec2minz(hprsecs)
   Note("You'll need about " .. hprtime .. " to regen hp.")
  end
 end
 if mvnote == 1 then
  if mvrsecs < 0 then
   Note("Warning! Your movement regen is negative (" .. mvregen .. ").")
  else
   mvrtime = sec2minz(mvrsecs)
   Note("You'll need about " .. mvrtime .. " to regen movement.")
  end
 end
end

function IsInTable(t, s)
  --Case insensitive search
  for i, result in pairs (t) do
    if (result == true) then
      Note("Warning - ignoring boolean entry in table for '" .. s .. "'.")
    elseif (result == false) then
      Note("Warning - ignoring boolean entry in table for '" .. s .. "'.")
    elseif string.match(string.lower(result), string.lower(s)) then
      return 1
    end
  end
  return 0
end

--[[
Group KXWT explination
The start block trigger wipes kplayer, kminion, and kotherminion tables.
These are temporary working tables that only exist to be filled while a block is being received, the next start block erases them.
The group endblock trigger calls the kxwt_group_end function, which takes all the players, minions, and otherminions (minions you don't care about since they're not yours) and dumps them into kxwt_name tables. (E.G. kxwt_players, kxwt_minions, kxwt_otherminions)
Use these kxwt tables to do checks on players, minions, etc. DON'T USE THE K TABLES! As stated above they are temporary and won't ever have complete data accept for like... a second.
]]

function fillstats(name, hp, mhp, mn, mmn, mv, mmv)
 name.hp = hp
 name.mhp = mhp
 name.php = percent(hp, mhp)
 name.dhp = mhp - hp
 name.mn = mn
 name.mmn = mmn
 name.pmn = percent(mn, mmn)
 name.dmn = mmn - mn
 name.mv = mv
 name.mmv = mmv
 name.pmv = percent(mv, mmv)
 name.dmv = mmv - mv
end

function grsf(n,l,w)
 name = w.name
 hp = tonumber(w.hp)
 mhp = tonumber(w.mhp)
 mn = tonumber(w.mn)
 mmn = tonumber(w.mmn)
 mv = tonumber(w.mv)
 mmv = tonumber(w.mmv)
 tag=w.tag
 for tagchar in tag:gmatch(".") do
  if tagchar == "P" then
   kplayers[name]={}
   fillstats(kplayers[name], hp, mhp, mn, mmn, mv, mmn)
   kpcount = kpcount + 1
  elseif tagchar == "M" then
   -- Minions can have the same name, so we need to have their table keyed by number, not name.
   -- Sadly this means that we can't use each value in the table as a subtable with values for stats
   name = string.lower(name)
   table.insert(kminions, name)
   if (gs("minionmonitor") == true) and (IsInTable(tomonitor,name) == 1) and (hp < mhp) then
    if mmon[name] == nil then
     mmon[name] = {}
     mmon[name].hp = 0
     mmon[name].php = 0
    end
    if hp ~= mmon[name].hp then
     PanSnd(hp, mhp, sdir.."pm/"..name..".ogg")
     mmon[name].hp = hp
     mmon[name].php = percent(hp, mhp)
    end
   end
  elseif tagchar == "O" then
   -- same situation as above
   name = string.lower(name)
   table.insert(kotherminions, name)
  elseif tagchar == "L" then
   leader = name
  end
 end
end

function kxwt_group_end()
  -- Gets called when a group block ends and all entries have been processed.
  kxwt_players=kplayers
  kxwt_minions=kminions
  kxwt_otherminions=kotherminions
  kxwt_playercount=kpcount
  tempgroup = {}
  for k, v in pairs(kxwt_players) do
    table.insert(tempgroup, k)
  end
  -- No table counters for these, they're numerically keyed
  for k, v in pairs(kminions) do
    table.insert(tempgroup, v)
  end
  for k, v in pairs(kotherminions) do
    table.insert(tempgroup, v)
  end
  group = tempgroup
  if kxwt_playercount==0 and grouped == 1 then -- You don't show up on group display, only others...
    grouped = 0
    gclear()
    EnableGroup("group", 0)
    EnableGroup("cgroup", 0)
  elseif kxwt_playercount>0 and grouped == 0 then
    grouped = 1
    EnableGroup("group", 1)
    EnableGroup("cgroup", 1)
  end
end -- function

function grtimer()
if (job=="hitter") then
if not (nohit==1) then
nohit=1
SendNoEcho(hitting)
require "wait"
wait.make(function()
wait.time(2.8)
nohit=0
end) --wait
end --nohit
end --hit
if (job=="blaster") then
if not (noblast==1) then
PSend("c "..blasting)
noblast=1
require "wait"
wait.make(function()
wait.time(2.8)
noblast=0
casting=blasting
end) --wait
end --nohit
end --blaster
if (job=="healer") then
PSend("gr | prefix heal")
elseif (job=="healblast") then
PSend("gr | prefix heal")
elseif (job=="areaman") then
PSend("gr | prefix heal")
end
end --func

function healer(n,l,w)
if (tonumber(mana)<50) then
if (pose~="rest") then
PSend("rest")
end
return
end --mana
--gname=w[1]
--glvl=w[2]
ghp=tonumber(w[3])
gk_maxhp=tonumber(w[4])
--gmn=w[5]
--gk_maxmana=w[6]
gmv=tonumber(w[7])
gk_maxmove=tonumber(w[8])
require "wait"
wait.make(function()
if (gmv/gk_maxmove*100 < 30) then
if (kspells["arearefresh"]==1) then
if (pose~="stand") then
PSend("stand")
end
PSend("c area")
PSend("rest")
end --know area
end --max move
if(job=="healer") then
if not (nohealing==1) then
if (ghp/gk_maxhp*100 <75) then
gname=w[1]
if (pose=="rest") then
PSend("stand")
end --rest
PSend("cast "..spells["heal"].." "..gname)
casting=spells["heal"].." "..gname
PSend("rest")
nohealing=1
wait.time(2)
nohealing=0
end
else
if (job=="healblast") then
if (assisting==0) then
assisting=1
PSend("assist")
end
PSend("c "..blasting)
casting=blasting
else
if (pose~="rest") then
PSend("rest")
end
end
end --hp check
end --nohealing
end) --wait
end --func


----------------------------------------------------------------------
-- miscellaneous
----------------------------------------------------------------------

-- FIXME this function isnt used?
function psnd(c,m,f)
fid=ppi.play(f,0)
-- FIXME warning possible divide by zero
ppi.setPitch((c*200/m)-100,fid)
end

function sf(v,f)
-- FIXME wtf does this do?
CallPlugin("aedf0cb0be5bf045860d54b7", "sfreq", ""..v.."="..f)
end

function channels()
name=string.lower(w[2])
cname=string.lower(w[1])
if (name == gs("me")) then
if (gs("chist") == true) then
Execute("history_add all="..w[1].." "..w[2]..": "..w[3])
Execute("history_add channels="..w[1].." "..w[2]..": "..w[3])
end
if (gs("chans") ==1) then
Sound(sdir.."channels/"..cname..".ogg")
Note(w[1].." "..w[2]..": "..w[3])
elseif (gs("chans") ==2) then
Sound(sdir.."channels/"..cname..".ogg")
Execute("tts_note "..w[1].." "..w[2]..": "..w[3])
elseif (gs("chans") ==3) then
Sound(sdir.."channels/"..cname..".ogg")
end
else
Note(w[1].." "..w[2]..": "..w[3])
Execute("history_add all="..w[1].." "..w[2]..": "..w[3])
Execute("history_add channels="..w[1].." "..w[2]..": "..w[3])
Sound(sdir.."channels/"..cname..".ogg")
end
end

function castalias(n, l, w)
--if(pose~="stand") then
--prevpose=pose
--PSend("stand")
--end
counters.cast=counters.cast+1
Send("cast "..w[1])
if(nfight==0) then
casting=w[1]
end
end

function bfight(n)
gfighting=1
if (grouped==0) then
return
end
if kxwt_players[n] ~= nil then
if (job=="tank") then
if (restime==1) or (notank==1) then
PSend("rescue "..n)
res=n
end
elseif (job=="hitter") then
if (hitting==nil) then
if (kskills["disarm"]==1) then
hitting="disarm"
else
if (kskills["trip"]==1) then
hitting="trip"
else
if (kskills["bash"]==1) then
hitting="bash"
end --bash
end --no disarm
end --skills
end --nil hit
if (assisting==0) then
PSend("assist")
assisting=1
EnableTimer("grtimer", true)
end --assist
elseif (job=="healer") then
EnableTimer("grtimer", true)
elseif (job=="healblast") then
EnableTimer("grtimer", true)
elseif (job=="areaman") then
EnableTimer("grtimer", true)
elseif (job=="blaster") then
if (assisting==0) then
PSend("assist")
assisting=1
EnableTimer("grtimer", true)
end --assist
end --jobs
end --in group
end --function

function follow(n,l,w)
if kxwt_players[w[1]] ~= nil then
Sound(sdir.."grouping/follow.ogg")
if (map==1) then
AppendToNotepad("map", w[2]..";")
end
if (gs("ifollow")==true) then
Execute("tts_interrupt "..w[2])
else
Note(w[2])
end
else
Note(l)
end
end --func

function fightfunc(who,wtype,weapon,damtype,towho)
if(who=="Your") then
counters.enemyhits=counters.enemyhits+1
fight_swing(weapon)
else--if I was not the one to hit
if(towho=="you") then--if attack is directed at you
counters.hits=counters.hits+1--counter
fight_attack()--scream
 
else--if neither
if kxwt_players[towho] == nil then
return
end
gfighting=1
if (gs("gdamage")==true) then
if (swings[weapon] == nil) then
else
  ssrandom=math.random(1,swings[weapon])
  Sound(sdir.."combat/weapon swings/"..weapon.."/"..ssrandom..".ogg")
end
end
end --if at you
end--main hit condition
fight_damtype(damtype,who,towho)
if wtype~= none then
fight_weapon(weapon,who,towho,wtype)
else
fight_weapon(weapon,who,towho,"none")
end
--grunt
if(who=="Your") then
theygrunt2()
else
if(towho=="you") then
yougrunt2()
end
end
end--func

function fight_attack()
if (mg=="male") then
ssrandom=math.random(1,mattack)
elseif (mg=="female") then
ssrandom=math.random(1,fattack)
elseif (mg=="neuter") then
ssrandom=math.random(1,nattack)
end
ppi.play(sdir.."combat/attack/"..mg.."/"..ssrandom..".ogg",0,50)
end

function fight_weapon(weapon,who,towho,wtype)
  if not (who=="Your") and not (towho=="you") then
    if kxwt_players[towho] ~= nil then
      if(gs("gdamage")==false) then
        --Note("return")
        return
      end
    end
  end
  --Note("new wtype is "..wtype)
  if(wtype~="none") then
    ppi.play(sdir.."combat/weapon sounds/elemental/"..wtype..".ogg",0)
  end
  if (weapons[weapon] == nil) then
    return
  end
  if (who=="Your") then
    localrandom = math.random(1,weapons[weapon])
    DoAfterSpecial(0.2,'ppi.play(sdir.."combat/weapon sounds/"..weapon.."/"..localrandom..".ogg",0,50)',12)
  else
    if(towho=="you") then
      localrandom = math.random(1,weapons[weapon])
      DoAfterSpecial(0.2,'ppi.play(sdir.."combat/weapon sounds/"..weapon.."/"..localrandom..".ogg",0,-50)',12)
    end
  end
end

function fight_swing(weapon)
  if (swings[weapon] == nil) then
  else
    ssrandom=math.random(1,swings[weapon])
    ppi.play(sdir.."combat/weapon swings/"..weapon.."/"..ssrandom..".ogg",0,-50)
  end
end

function fight_damtype(damtype,who,towho)
if not (who=="Your") or not (towho=="you") then
if(gs("gdamage")==false) then
--Note("return")
return
end
end
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/"..damtype..".ogg",0)',12)
if (damtype=="scratches") or (damtype=="hits") or (damtype=="injures") or (damtype=="wounds") or (damtype=="mauls") then
gtype=1
elseif (damtype=="decimates") or (damtype=="devastates") or (damtype=="maims") then
gtype=2
elseif (damtype=="MUTILATES") or (damtype=="DISMEMBERS") or (damtype=="DISEMBOWELS") or (damtype=="MASSACRES") then
gtype=3
elseif (damtype=="*** DEVASTATES ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/devastates2.ogg",0)',12)
gtype=4
elseif (damtype=="*** MASSACRES ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/massacres2.ogg",0)',12)
gtype=4
elseif (damtype=="*** OBLITERATES ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/obliterates.ogg",0)',12)
gtype=4
elseif (damtype=="*** DEMOLISHES ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/demolishes.ogg",0)',12)
gtype=4
elseif (damtype=="*** ANNIHILATES ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/annihilates.ogg",0)',12)
gtype=4
elseif (damtype=="*** DESTROYS ***") then
DoAfterSpecial(0.2,'ppi.play(sdir.."combat/damage/destroys.ogg",0)',12)
gtype=4
end
end

function fighting(n,l,wl)
if not gag.fights then Note(wl[1]) end
w={}
for wr in string.gmatch(wl[1], "%S*") do
if not (wr=="") then
table.insert(w,wr)
end--empty string
end--for
verb=0
for i, result in pairs (w) do
if verbs[w[i]] then
verb=i
end--if
end --for
if verb == 0 then return end
if(w[verb-1]=="***") then
str="*** "..w[verb].." ***"
damtype=str
--Fote("damage "..damtype)
str=""
weapon=""
if nouns[w[verb-2]] then
weapon=w[verb-2]
wpos=verb-2
else
wpos=verb-1
end
--fote("weapon "..weapon)
npos=verb+2
else --if without stars
npos=verb+1
damtype=w[verb]
--fote("damage "..damtype)
str=""
weapon=""
if nouns[w[verb-1]] then
--fote("weapon yes")
weapon=w[verb-1]
wpos=verb-1
else
--fote("weapon no")
wpos=verb
end
--fote("weapon "..weapon)
end--no stars
wtype=none
text=w[wpos-1]
if adjectives[text] then
wtype=text
whopos=wpos-2
else
whopos=wpos-1
end
for i=1, whopos do
str=str..w[i].." "
end--for h
who=str
who=string.sub(who,1,#who-1)
str=""
if (string.sub(who,#who-1,#who)=="'s") then
who=string.sub(who,1,#who-2)
end
--Note("who "..who)
for i=npos, #w do
str=str..w[i].." "
end--for h
towho=string.sub(str,1,#str-2)
--fote("to who "..towho)
--fighting separator
if weapon=="" then
weapon="punch"
fightfunc(who,"none",weapon,damtype,towho)
return
end
if not (wtype==nil) then
--Note("works up to here")
elemental=true
fightfunc(who,wtype,weapon,damtype,towho)
return
else
elemental=false
fightfunc(who,"none",weapon,damtype,towho)
return
end--weapon
end--func


-------------------------------------------------------------
-- filter init and schemes
-------------------------------------------------------------

function enable_all_filters()
  gag.expert   =true
  gag.misc     =true
  gag.fights   =true
  gag.minions  =true
  gag.skills   =true
  gag.spells   =true
  gag.combat   =true
  gag.condition=true
  gag.sounds=true
  gag.crafting=true
end

function disable_all_filters()
  gag.expert   =false
  gag.misc     =false
  gag.fights   =false
  gag.minions  =false
  gag.skills   =false
  gag.spells   =false
  gag.combat   =false
  gag.condition=false
  gag.sounds=false
  gag.crafting=false
end

function set_default_filters()
  gag.expert   =false
  gag.misc     =false
  gag.fights   =true
  gag.minions  =false
  gag.skills   =false
  gag.spells   =false
  gag.combat   =true
  gag.condition=false
  gag.sounds=false
  gag.crafting=false
end

function sanity_check_filter_setting(v, arg)
  if gag[v] ~= true and gag[v] ~= false then
    gag[v] = arg
  end
end

function sanity_check_filter_settings()
  if not gag then gag={} end
  sanity_check_filter_setting("expert",   false)
  sanity_check_filter_setting("misc",     false)
  sanity_check_filter_setting("fights",   true)
  sanity_check_filter_setting("minions",  false)
  sanity_check_filter_setting("skills",   false)
  sanity_check_filter_setting("spells",   false)
  sanity_check_filter_setting("combat",   true)
  sanity_check_filter_setting("condition",false)
  sanity_check_filter_setting("sounds",false)
  sanity_check_filter_setting("crafting",false)
end

function display_filters()
  for i in pairs(gag) do
    if gag[i]==true then status="enabled" end
    if gag[i]==false then status="disabled" end
    Note(i.." - "..status)
  end
end

-------------------------------------------------------------
-- various functions for default configuration types
-------------------------------------------------------------

function sanity_check_bool_config_setting(v, arg, visible)
  if not settings[v] then
    settings[v] = {}
  end
  if settings[v].status ~= true and settings[v].status ~= false then
    settings[v].status = arg
  end
  if visible==nil then visible=true end
  if settings[v].visible==nil then
    settings[v].visible=visible
  end
end

function sanity_check_int_config_setting(v, arg, visible)
  if not settings[v] then
    settings[v] = {}
  end
  if visible==nil then visible=true end
  if settings[v].visible==nil then
    settings[v].visible=visible
  end
  -- check for nil loaded setting
  if settings[v].status == nil then
    settings[v].status = arg
    return
  end
  -- convert loaded bool settings to integer
  if settings[v].status == true or settings[v].status == false then
    settings[v].status = arg
    return
  end
end

function configure_minimal_settings() 
  Note("Using minimal configuration. Most sounds and music have been disabled, as well as all filters.")
  disable_all_filters()

  settings.ambience.status=false
  settings.antigroundstringspam.status=false
  settings.areamusic.status=false
  settings.showsize.status=true
  settings.unexplored.status=false
  settings.autoopen.status=false
  settings.automark.status = 1
  settings.automove.status=false
  settings.autopick.status=true
  settings.autoregen.status=false

  settings.autosleep.status=false
  settings.autostat.status=true
  settings.autotime.status        = 1
  settings.bars.status=3             -- give enemy hp in text
  settings.battlemusic.status=false

  settings.brewlog.status=true
  settings.comlog.status=false
  settings.comlogchans.status=false
  settings.comlogtells.status=false
  settings.comlogclan.status=false
  settings.comlogfriends.status=false
  settings.chans.status=1
  settings.chist.status=false

  settings.clannotify.status=false
  settings.clanfame.status=false
  settings.clanactive.status=false
  settings.clansize.status=false
  settings.clanpk.status=false

  settings.clanwar.status=false
  settings.dcomps.status=1
  settings.randomsaction.status=2
  settings.deathaction.status=true
  settings.deathactionbloodsac.status=1
  settings.deathactionharvestteeth.status=1
  settings.deathactionconsume.status=1
  settings.deathactionspellcomp.status=1
  settings.deathactionsalvage.status=1
  settings.donfish.status=false
  settings.exitcomma.status=false
  settings.dteeth.status=false

  settings.enterinterrupt.status=false
  settings.elderBuffer.status=false
  settings.exits.status=1
  settings.expall.status=true
  settings.gdamage.status=false

  settings.globalareamusic.status=false
  settings.grecast.status=false
settings.groupdice.status=1
  settings.grunts.status=false
    settings.ifollow.status=false
  settings.imove.status=false

  settings.items.status=3
  settings.logarena.status=true
  settings.logpk.status=false
  settings.musictype.status=1
  settings.ntrunk.status=false

  settings.playquotes.status=false
  settings.praccing.status=false
  settings.randomambience.status=false
  settings.randoms.status=2

  settings.rebootsounds.status=1
  settings.recast.status=false
  settings.recastsleeping.status=true
  settings.reclay.status=false
  settings.minionmonitor.status=true
  settings.regen.status=3
  settings.runeinfo.status = 1
  settings.sacsplit.status=false

  settings.scheme.status=2
  settings.shortall.status=false
  settings.shortid.status=1
  settings.showtips.status=false

  settings.soulsteal.status=false
  settings.soulaction.status=false
  settings.sellstruggle.status=false
  settings.speedwalk.status=false
  settings.spellsfall.status=2
  settings.sunsounds.status = false

  settings.swarn.status=false
  settings.ticksounds.status=false

  settings.tts.status=true
  settings.warn.status=false
end

function configure_default_settings()
  Note("OK, configured for default settings, default filters.")
  set_default_filters()

  -- NOTE - these settings should match the sanity check config settings below
  settings.ambience.status        = true
  settings.antigroundstringspam.status=false
settings.showsize.status=true
  settings.unexplored.status=false
  settings.areamusic.status       = false   -- this is too busy with ambience also enabled
  settings.autoopen.status      = false

  settings.automark.status = 1
  settings.automove.status        = true
  settings.autopick.status        = true
  settings.autoregen.status       = false

  settings.autosleep.status       = false
  settings.autostat.status        = true
  settings.autotime.status        = 3
  settings.bars.status            = 2             -- give enemy hp via pitch change
  settings.battlemusic.status     = true

  settings.brewlog.status         = true
  settings.comlog.status=false
  settings.comlogchans.status=false
  settings.comlogtells.status=false
  settings.comlogclan.status=false
  settings.comlogfriends.status=false
  settings.chans.status           = 1
  settings.chist.status           = false

  settings.clannotify.status=false
  settings.clanfame.status=false
  settings.clanactive.status=false
  settings.clansize.status=false
  settings.clanpk.status=false

  settings.clanwar.status         = true
  settings.dcomps.status          = 1
  settings.randomsaction.status          = 2
  settings.deathaction.status=false
  settings.deathactionbloodsac.status=1
  settings.deathactionharvestteeth.status=1
  settings.deathactionconsume.status=1
  settings.deathactionspellcomp.status=1
  settings.deathactionsalvage.status=1
  settings.donfish.status         = false
  settings.exitcomma.status         = false
  settings.dteeth.status          = false

  settings.enterinterrupt.status  = false
  settings.elderBuffer.status=false
  settings.exits.status           = 1
  settings.expall.status          = true
  settings.gdamage.status         = true

  settings.globalareamusic.status = true
  settings.grecast.status         = false
settings.groupdice.status=2
  settings.grunts.status         = true
  settings.ifollow.status         = false
  settings.imove.status           = true

  settings.items.status           = 3
  settings.logarena.status=true
  settings.logpk.status           = false
  settings.musictype.status       = 1
  settings.ntrunk.status          = true

  settings.playquotes.status      = false
  settings.praccing.status        = false

  settings.randomambience.status  = false
  settings.randoms.status         = 2

  settings.rebootsounds.status=1
  settings.recast.status          = false
  settings.recastsleeping.status  = true
  settings.reclay.status          = false
  settings.minionmonitor.status   = true
  settings.regen.status           = 3
  settings.runeinfo.status = 1

  settings.sacsplit.status        = false

  settings.scheme.status          = 2
  settings.shortall.status        = true
  settings.shortid.status         = 2
  settings.showtips.status        = true

  settings.soulsteal.status       = true
  settings.soulaction.status=false
  settings.sellstruggle.status=false
  settings.speedwalk.status       = false
  settings.spellsfall.status=2
  settings.sunsounds.status = false
  settings.swarn.status           = false
  settings.ticksounds.status      = false

  settings.tts.status             = true
  settings.warn.status            = true
end

function sanity_check_config_settings()
  if not settings then settings={} end

  sanity_check_bool_config_setting("ambience",        true)
  sanity_check_bool_config_setting("antigroundstringspam", false)
  sanity_check_bool_config_setting("areamusic",       false)    -- this is too busy with ambience also enabled
  sanity_check_bool_config_setting("autoopen",      false)
  sanity_check_bool_config_setting("showsize",        true)
  sanity_check_bool_config_setting("unexplored",false)
  sanity_check_int_config_setting("automark", 1)
  sanity_check_bool_config_setting("automove",        true)
  sanity_check_bool_config_setting("autopick",        true)
  sanity_check_bool_config_setting("autoregen",       false)

  sanity_check_bool_config_setting("autosleep",       false)
  sanity_check_bool_config_setting("autostat",        true)
  sanity_check_int_config_setting("autotime",        3)
  sanity_check_int_config_setting ("bars",            2)        -- give enemy pitch via pitch change
  sanity_check_int_config_setting ("dcomps",          1)
  sanity_check_int_config_setting ("randomsaction",          2)
  sanity_check_bool_config_setting("battlemusic",     true)
  sanity_check_bool_config_setting("brewlog",         true)
  sanity_check_bool_config_setting("comlog", false)
  sanity_check_bool_config_setting("comlogchans", true, false)
  sanity_check_bool_config_setting("comlogclan", false, false)
  sanity_check_bool_config_setting("comlogtells", true, false)
  sanity_check_bool_config_setting("comlogfriends", false, false)
  sanity_check_int_config_setting ("chans",           1)
  sanity_check_bool_config_setting("chist",           false)

  sanity_check_bool_config_setting("clannotify",           false)
  sanity_check_bool_config_setting("clanfame",           false, false)
  sanity_check_bool_config_setting("clanactive",           false, false)
  sanity_check_bool_config_setting("clansize",           false, false)
  sanity_check_bool_config_setting("clanpk",           false, false)

  sanity_check_bool_config_setting("clanwar",         true)
  sanity_check_bool_config_setting("deathaction",      false)
  sanity_check_int_config_setting("deathactionbloodsac", 1, false)
  sanity_check_int_config_setting("deathactionharvestteeth", 1, false)
  sanity_check_int_config_setting("deathactionconsume", 1, false)
  sanity_check_int_config_setting("deathactionspellcomp", 1, false)
  sanity_check_int_config_setting("deathactionsalvage", 1, false)
  sanity_check_bool_config_setting("donfish",         false)
  sanity_check_bool_config_setting("exitcomma", false)
  sanity_check_bool_config_setting("dteeth",          false)

  sanity_check_bool_config_setting("enterinterrupt",  false)
  sanity_check_bool_config_setting("elderBuffer",         false)
  sanity_check_int_config_setting ("exits",           1)
  sanity_check_bool_config_setting("expall",          true)
  sanity_check_bool_config_setting("gdamage",         true)

  sanity_check_bool_config_setting("globalareamusic", true)
  sanity_check_bool_config_setting("grecast",         false)
  sanity_check_int_config_setting("groupdice", 2)
  sanity_check_bool_config_setting("grunts",         true)
  sanity_check_bool_config_setting("ifollow",         false)
  sanity_check_bool_config_setting("imove",           true)

  sanity_check_int_config_setting ("items",           3)
  sanity_check_bool_config_setting("logarena",           true)
  sanity_check_bool_config_setting("logpk",           false)
  sanity_check_int_config_setting ("musictype",       1)
  sanity_check_bool_config_setting("ntrunk",          true)

  sanity_check_bool_config_setting("playquotes",      false)
  sanity_check_bool_config_setting("praccing",        false)
  sanity_check_bool_config_setting("randomambience",  false)
  sanity_check_int_config_setting("randoms",         2)

  sanity_check_int_config_setting("rebootsounds",         1)
  sanity_check_bool_config_setting("recast",          false)
  sanity_check_bool_config_setting("recastsleeping",  true)
  sanity_check_bool_config_setting("reclay",          false)
  sanity_check_bool_config_setting("minionmonitor",   true)
  sanity_check_int_config_setting ("regen",           3)
  sanity_check_int_config_setting("runeinfo", 1)
  sanity_check_bool_config_setting("sacsplit",        false)

  sanity_check_int_config_setting ("scheme",          2)
  sanity_check_bool_config_setting("shortall",        true)
  sanity_check_int_config_setting ("shortid",         2)  
  sanity_check_bool_config_setting("showtips",        true)
  sanity_check_bool_config_setting("shortidcomma",    false)
  sanity_check_bool_config_setting("soulsteal",       true)
  sanity_check_int_config_setting("soulaction", 2, false)
  sanity_check_bool_config_setting("sellstruggle", false, false)
  sanity_check_bool_config_setting("speedwalk",       false)
  sanity_check_int_config_setting("spellsfall",       2)
  sanity_check_bool_config_setting("sunsounds",     false)
  sanity_check_bool_config_setting("swarn",           false)
  sanity_check_bool_config_setting("ticksounds",      false)

  sanity_check_bool_config_setting("tts",             true)
  sanity_check_bool_config_setting("warn",            true)

  -- various containers should get special parms
  if not settings.brewcontainer then settings.brewcontainer={} ss("brewcontainer","") end
  if not settings.container then settings.container={} ss("container","bag") end
  if not settings.sscontainer then settings.sscontainer={} ss("sscontainer",gs("container")) end

  -- volume control should be initialized and set
  sanity_check_int_config_setting ("vol_ambid",    50)
  sanity_check_int_config_setting ("vol_areaid",   50)
  sanity_check_int_config_setting ("vol_global",   50)
  resetvol()

  -- special variable to store our name
  if not settings.me then settings.me={} ss("me","new") end

  -- this clears an old save file case where the setting was being saved boolean
  if settings.me.status == true  then ss("me","new") end
  if settings.me.status == false then ss("me","new") end

  -- create an iuid if necessary
  if not settings.iuid then
    settings.iuid={}
    local temp_iuid = ""..math.random(1000, 9999)..math.random(1000, 9999)..""
    ss("iuid",temp_iuid)
  end
end

function sanity_check_charlist()
  if (charlist == nil) then
    charlist = {}
  end

  -- if we find any boolean values, just crater and be done
  for i, result in pairs (charlist) do
    if (result == true) then
      -- Note("Clearing corrupt charlist table.")
      charlist = {}
      return
    elseif (result == false) then
      -- Note("Clearing corrupt charlist table.")
      charlist = {}
      return
    end
  end
  if (#charlist>=1) then
    if charlist[1]~=nil then --we've got an oldstyle charlist table, convert it
      convert_charlist()
    end -- if we've got an oldstyle charlist
  end -- if 1 or more entries in table
end

-------------------------------------------------------------
-- table that contains various setting related strings
-------------------------------------------------------------

function setup_config_menu_entry(configname, keywords, description)
  if not config_menu_data then
    config_menu_data = {}
  end
  if not config_menu_data[configname] then
    config_menu_data[configname] = {}
  end
  config_menu_data[configname].keywords = keywords
  config_menu_data[configname].desc     = description
end

function settingtables()
  args={}
  args.autotime = {"disabled", "Every hour with text and a small sound", "Every hour with text and a small sound, as well as every 6 hours with an audio announcement"}
  args.automark = {"disabled", "only in groups where I am the leader", "Only in groups where I am not the leader", "in all groups"}
  args.bars={"Pan sounds from left (lowest) to right (highest)", "Sounds that change pitch","Just display the values in text"}
  args.regen={"Never", "Sleeping", "Both sleeping and resting"}
  args.dcomps={"Do nothing", "Store in container", "Discard"}
  args.randomsaction={"Do nothing", "Store in container", "Donate", "Discard"}
  args.deathactionspellcomp={"Disabled", "50% of the time", "Always"}
  args.deathactionconsume={"Disabled", "50% of the times", "Always"}
  args.deathactionbloodsac={"Disabled", "50% of the time", "Always"}
  args.deathactionsalvage={"Disabled", "50% of the time", "Always"}
  args.deathactionharvestteeth={"Disabled", "50% of the time", "Always"}
  args.groupdice={"Disabled", "Group only", "All and Group"}
  args.shortid={"Disabled","Output and history","History only"}
  args.musictype={"Your health", "Target's health"}
  args.randoms={"disabled", "Only when soloing", "Only when leading", "When soloing or leading"}
  args.rebootsounds = {"Play a warning sound", "Play audio announcements"}
  args.scheme={"Heartbeats", "Speech"}
  args.soulaction={"Do nothing with it", "Put it in my container", "Sell it on the soulmarket"}
  args.spellsfall = {"none", "only mine", "only group members", "mine and group members"}
  args.chans={"Play the channel sound and display your message", "Speak your message without displaying it", "Only play the channel sound"}
  args.exits={"Text", "Directional Sounds"}
  args.items={"Put it in a container","Discard it","Do nothing","Donate it","Put it in your locker"}
  args.runeinfo = {"Just show the rune", "Show the rune and it's affects", "Just show the affects"}

  setup_config_menu_entry("ambience",        "ambience",    "Ambience: Area-specific ambient sounds:")
  setup_config_menu_entry("antigroundstringspam", "groundspam spamground stringspam itemspam antigroundstringspam", "Antigroundstring spam: condense many items with the same groundstring into one line:")
  setup_config_menu_entry("areamusic",       "areamusic",   "AreaMusic: Play area-specific background music:")
  setup_config_menu_entry("autoopen",      "autoopen",  "AutoOpen: Automatically open doors after unlocking or picking:")
  setup_config_menu_entry("showsize",      "showsize size",  "show size information when displaying items and people in rooms:")
  setup_config_menu_entry("unexplored",      "unexplored near exits nearexits",  "show nearest unexplored exits (if any) when entering a room")
  setup_config_menu_entry("automark", "automark groupmark mark", "Automark: automatically start marking when I join a group: ")
  setup_config_menu_entry("automove",        "automove",    "AutoMove: Obey leader's climb and look commands:")
  setup_config_menu_entry("autopick",        "autopick",    "AutoPick: Retry lockpicking when it fails:")
  setup_config_menu_entry("autoregen",       "autoregen",   "AutoRegen: Obey leader's regen and sleep commands:")

  setup_config_menu_entry("autosleep",       "autosleep",   "AutoSleep: Sleep when group leader sleeps:")
  setup_config_menu_entry("autostat",        "autostat",    "AutoStat: Display statistics when they change:")
  setup_config_menu_entry("bars",            "bars",        "Bars: Represent the prompt using:")
  setup_config_menu_entry("battlemusic",     "battlemusic", "BattleMusic: Play condition-specific music when fighting:")
  setup_config_menu_entry("brewcontainer",   "brewcontainer vessel", "Vessel: Liquid container used for brewing:")
  setup_config_menu_entry("brewlog",         "brewlog",              "BrewLog: Write brewed recipes to a separate window:")

  setup_config_menu_entry("chans",           "chans chanecho",       "ChanEcho: When you talk on a channel, Mush-Z should:")
  setup_config_menu_entry("chist",           "chist chanhist",       "ChanHist: Write what you say on channels to a separate window:")

  setup_config_menu_entry("clannotify", "clannotify ranknotify", "Clan notify: alert me upon login of changes to my clan's rank (enables other options) ")
  setup_config_menu_entry("clanfame", "clanfame famerank rankfame", "Clan fame: notify me at login when my clan's fame rank changes ")
  setup_config_menu_entry("clanactive", "clanactive clanactivity activerank", "Clan Activity: Notify me at login when my clan's activity rank changes ")
  setup_config_menu_entry("clansize", "clansize sizerank", "Clan Size: Notify me at login when my clan's size changes ")
  setup_config_menu_entry("clanpk", "clanpk clanpkrank clanpk", "Clan PK: Notify me at login when my clan's PK rank rises or falls ")

  setup_config_menu_entry("clanwar",         "clanwar",            "ClanWar: Display clan war notifications and sounds:")
  setup_config_menu_entry("container",       "container",          "Container: Container used for storing various items:")
  setup_config_menu_entry("comlog", "chanlog channellog logchannel comlog logcom", "Comlog: Log all communications you choose to a separate notepad (enables other options):")
  setup_config_menu_entry("comlogtells", "telllog logtells", "com log tells: Log tells to the comlog:")
  setup_config_menu_entry("comlogchans", "logchan", "comlog channels: log channel sends to the com log:")
  setup_config_menu_entry("comlogclan", "logclan comlogclan", "comlog clan: log clantells to the comlog:")
  setup_config_menu_entry("comlogfriends", "logfriends friendslog", "comlog friends: log friend posts to the com log:")
  setup_config_menu_entry("dcomps",          "dcomps",             "DComps: Perform the following action on corpsecutter spell components:")
  setup_config_menu_entry("randomsaction",          "randomsaction",             "RandomsAction: Perform the following action on automatically retrieved random/unique items:")
  setup_config_menu_entry("deathaction",     "deathaction necroaction", "Death action: Automatically perform common tasks on corpses (enables other options):")
  setup_config_menu_entry("deathactionbloodsac",         "autobloodsac bloodsacondeath", "Death action, bloodsac: Automatically bloodsac corpses:")
  setup_config_menu_entry("deathactionharvestteeth", "autoteeth deathactionharvestteeth", "Death action, harvest teeth: Automatically harvest teeth:")
  setup_config_menu_entry("deathactionconsume", "autoconsume deathactionconsume", "Death action, consume: Automatically controll all minions to consume corpses:")
  setup_config_menu_entry("deathactionspellcomp", "autospellcomp deathactionspellcomp", "Death action, spellcomp: Automatically harvest spellcomps from corpses:")
  setup_config_menu_entry("deathactionsalvage", "autosalvage deathactionsalvage", "Death action, salvage: Automatically salvage mechanical parts when possible:")
  setup_config_menu_entry("donfish",         "donfish donatefish", "DonateFish: Automatically donate caught fish:")
  setup_config_menu_entry("exitcomma", "exitcomma", "ExitComma: Use a comma to separate options when displaying room exits:")
  setup_config_menu_entry("dteeth",          "dteeth",             "DTeeth: Automatically discard harvested teeth:")
  setup_config_menu_entry("autotime",          "autotime hour time",             "Time: Automatically announce game time: ")

  setup_config_menu_entry("enterinterrupt",  "enterinterrupt",     "EnterInterrupt: Pressing the enter key interrupts speach:")
  setup_config_menu_entry("elderBuffer",         "elderBuffer",                     "ElderBuffer: Send elder tells to an elders history buffer instead:")
  setup_config_menu_entry("exits",           "exits",              "Exits: Room exits should be conveyed using:")
  setup_config_menu_entry("expall",          "expall",             "ExpAll: Experience from mob deaths reviewable in 'all history' buffer:")
  setup_config_menu_entry("gdamage",         "gdamage weapons",    "Weapons: Play weapon swing and damage sounds:")

  setup_config_menu_entry("globalareamusic", "globalareamusic globalmusic", "GlobalMusic: Play default music for areas without specific tracks:")
  setup_config_menu_entry("grecast",         "grecast",                     "GRecast: Recast certain spells on group members:")
  setup_config_menu_entry("groupdice",         "groupdice",                     "groupdice: Add group dice results to history:")
  setup_config_menu_entry("grunts",         "grunts",    "grunts: Play grunts and other vocal sounds while fighting:")
  setup_config_menu_entry("ifollow",         "ifollow",                     "IFollow: Interrupt screen reader when following someone:")
  setup_config_menu_entry("imove",           "imove",                       "IMove: Interrupt speech when moving:")

  setup_config_menu_entry("items",           "items",                "Items: When you get an item, Mush-Z should:")
  setup_config_menu_entry("logarena",           "logarena arenalog",            "Log Arena: arena enter / leave messages reviewable in the all buffer:")
  setup_config_menu_entry("logpk",           "logpk",                "LogPK: pk fights are reviewable in channel history:")
  setup_config_menu_entry("musictype",       "musictype battletype", "BattleType: The severity of battle music is based on:")
  setup_config_menu_entry("ntrunk",          "ntrunk",               "NTrunk: Truncate large numbers:")

  setup_config_menu_entry("playquotes",      "playquotes",         "PlayQuotes: Play death quote voiceovers:")
  setup_config_menu_entry("praccing",        "praccing practice",  "Practice: Automatically gain a practice when possible:")
  setup_config_menu_entry("randomambience",  "randomambience",     "RandomAmbience: Occasionally play random ambience-enhancing sounds:")
  setup_config_menu_entry("randoms",         "randoms autorandom",            "Randoms: Automatically get random/unique items from corpses:")

  setup_config_menu_entry("rebootsounds",     "rebootsounds",     "Reboot sounds: When notifying you of reboots, Mush-Z should: ")
  setup_config_menu_entry("recastsleeping",  "recastsleeping",     "RecastSleeping: If recast is enabled, cast fallen spells even while sleeping:")
  setup_config_menu_entry("recast",          "recast",             "Recast: Cast certain spells on yourself when they fall:")
  setup_config_menu_entry("reclay",          "reclay",             "Reclay: Automatically cast clay man when the current one dies:")
  setup_config_menu_entry("minionmonitor",          "minionmonitor",             "Minion monitor: Monitor tanking minion health by the use of sounds:")
  setup_config_menu_entry("regen",           "regen",              "Regen: Automatically report regeneration times when:")
  setup_config_menu_entry("runeinfo", "runeinfo runemeanings runes", "Rune Info: when carving or looking at an item with runes, Mush-z should:")
  setup_config_menu_entry("sacsplit",        "sacsplit",           "SacSplit: Split gold obtained from sacrificing corpses:")
  setup_config_menu_entry("scheme",          "scheme",             "Scheme: Mush-Z should convey your health condition using:")
  setup_config_menu_entry("shortall",        "shortall",           "ShortAll: ShortID reviewable in 'all history' buffer:")
  setup_config_menu_entry("shortid",         "shortid",            "ShortID: When identifying an object, simplify the information:")  
  setup_config_menu_entry("shortidcomma",    "shortidcomma comma shortcomma",    "ShortIDComma: Pause between various item effects for easier understandability")
  setup_config_menu_entry("showtips",        "showtips tips autotips",           "ShowTips: Show Mush-Z newbie tips:")

  setup_config_menu_entry("soulsteal",       "soulsteal",          "Soulsteal: Automatically try to cast soulsteal when affected by dread portent:")
  setup_config_menu_entry("soulaction", "soulaction soulstoneaction stoneaction autosell", "Soul action: When Mush-Z automatically steals a soul: ")
  setup_config_menu_entry("sellstruggle", "sellstruggle", "Sell struggle: Sell souls that you struggle to steal: ")
  setup_config_menu_entry("speedwalk",       "speedwalk",          "Speedwalk: Interrupt room description with exits for quick walking:")
  setup_config_menu_entry("spellsfall",           "spellsfall spellsfallinall",          "Spells fall in all: spell fall messages reviewable in all buffer:")
  setup_config_menu_entry("sscontainer",     "sscontainer stones", "Stones: Container used for soulstones:")
  setup_config_menu_entry("sunsounds", "sunsounds dawn dusk", "Sun sounds: Play a sound when the sun rises and sets:")
  setup_config_menu_entry("swarn",           "swarn",              "SWarn: Warn subgroup of falling spells")
  setup_config_menu_entry("ticksounds",      "ticksounds",         "Ticks: Indicate the passage of game time (a mud tick) with sounds:")

  -- WARNING -- settings.tts -- this appears to be a core, mandatory setting.  Do not disable/modify. --

  setup_config_menu_entry("warn",            "warn",               "Warn: Display warnings when spells are near falling")


end

-------------------------------------------------------------
-- get and set functions for global config
-------------------------------------------------------------

function gs(v)
  if settings[v]==nil then
    Note("WARNING - referencing uninitialized config variable '"..v.."'.")
    settings[v]={}
  end
  return settings[v].status
end

function ss(v,val)
  if settings[v]==nil then
    -- Note("DEBUG - creating new config variable '"..v.."'.")
    settings[v]={}
  end
  if (settings[v].status ~= val) then
    -- only save if necessary
    settings[v].status=val
    SaveState()
  end
  check_visible(v)
end


--------------------------------------------------------------------
-- startup clear/system init
--------------------------------------------------------------------

function startup_do_mandatory_var_init()
  -- this is low level startup init that has to be done prior to clear working vars
  -- on first initialization
  SetVariable("version","180929-01")
  if not settings then settings={} end
  if not settings.me then
    settings.me = {}
    settings.me.status = "new"
  end
  if not settings.version then
    settings.version = {}
    settings.version.status = GetVariable("version")
  end
end
function gameTime_external_code()
--This function will run code when the kxwt_time trigger is sent to the client.
--To keep things clean, please try to only include function calls here.

--refresh the exp marker to check for an hour of marking:
hExpMarkHandle(nil,nil,nil,nil,nil,nil,true,true)
end



function startup_clear_working_vars() 
  -- this function can be called at various points in time, including from
  -- the manual control-l reload command.  It's convenient for initialization
  -- and startup as well.
  leader=gs("me")

afk=0
editing=0
if not context then context = { } end
if not context.current then context.current = { } end
if not context.current.name then
context = { }
context.current = { }
context.current.name="none"
context.current.id=no_context_id()
else
if context.current.name~="login screen" then
context = { }
context.current = { }
context.current.name="none"
context.current.id=no_context_id()
end--login screen check
end--context check
alreadyExecutedLogin=false
  reclayed=false
  mmon={}
  grst={}
  rooms={}
  k_room=""
  k_lastroom=""
  walkdirs={}
  walkdirs["0"]="north"
  walkdirs["2"]="south"
  walkdirs["1"]="east"
  walkdirs["3"]="west"
  walkdirs["20"]="up"
  walkdirs["30"]="down"
  walkdirs["4"]="northeast"
  walkdirs["7"]="northwest"
  walkdirs["5"]="southeast"
  walkdirs["6"]="southwest"
  dirs={}
  dirs["north"]="0"
  dirs["south"]="2"
  dirs["up"]="20"
  dirs["down"]="30"
  dirs["east"]="1"
  dirs["west"]="3"
  dirs["northeast"]="4"
  dirs["northwest"]="7"
  dirs["southeast"]="5"
  dirs["southwest"]="6"
  brewing=0
  swheel=0
  affs={}
  affs["SAVING_ZAP"]="zapsave"
  affs["SAVING_SPELL"]="spellsave"
  affs["DAMROLL"]="dr"
  affs["HITROLL"]="hr"
  affs["SAVING_FIRE"]="firesave"
  affs["SAVING_COLD"]="coldsave"
  affs["MANA_REGEN"]="manaregen"
  affs["MOV_REGEN"]="mv regen"
  affs["HIT_POINTS"]="hp"
  affs["NECR_CAST_LEVEL"]="necrocast"
  affs["MAGE_CAST_LEVEL"]="magecast"
  affs["CLER_CAST_LEVEL"]="clericcast"
  affs["DRUID_CAST_LEVEL"]="druidcast"
  ac=""
  mtimep=false
  insertqueue=""
  mapnow=false
  mapback={}
  mback=false
  donemap=0
  validdirs={"north","south","east","west","up","down","northeast","northwest","southeast","southwest"}
  adir=0
  maxdir=0
  mvtime=false
  ldir={}
  ldir.north="south"
  ldir.south="north"
  ldir.east="west"
  ldir.west="east"
  ldir.down="up"
  ldir.up="down"
  ldir.northwest="southeast"
  ldir.northeast="southwest"
  ldir.southeast="northwest"
  ldir.southwest="northeast"
  curmap={}
  mtime=false
  failstate=true
  stealnext=false
  toreclay={}
  table.insert(toreclay,"clayman clay")
  table.insert(toreclay,"metal construct ugly animated")
  table.insert(toreclay,"wood woad")
  table.insert(toreclay,"bone guardian")
  table.insert(toreclay,"flesh beastie")
  tomonitor={}
  mpl={}
  debugging=0
  table.insert(tomonitor,"a clay man")
  table.insert(tomonitor,"a metal construct")
  table.insert(tomonitor,"a wood woad")
  table.insert(tomonitor,"a bone guardian")
  table.insert(tomonitor,"a flesh beast")
  table.insert(tomonitor,"a shambling bone man")
  zapped={}
  setmodes={"meticulous","fast","lightning"}
  creatingset=false
  container=""
  truespells={}
  cup={}
  kxwts={}
  elemental=false
  loggedin=0
  resetspells()
  EnableTimer("rctimer",false)
  banned={"filthy","grey","gray","blue","yellow","acid-etched","etched","acid","sentry's","sentry","sturdy","green","leather"}
  pick=""
  uniques={}
  areaxp=0
  prevarea=""
  checkfor=""
  gold=0
  prevgold=0
  battleid=1
  battleplaying=0
  pose="stand"
  hpregen=1
  mnregen=1
  mvregen=1
chnInfo={}
  terrain_lookup_table={}
  terrain_lookup_table[1]="building"
  terrain_lookup_table[2]="town"
  terrain_lookup_table[3]="field"
  terrain_lookup_table[4]="light forest"
  terrain_lookup_table[5]="thick forest"
  terrain_lookup_table[6]="dark forest"
  terrain_lookup_table[7]="swamp"
  terrain_lookup_table[8]="plateau"
  terrain_lookup_table[9]="sandy"
  terrain_lookup_table[10]="mountain"
  terrain_lookup_table[11]="rock"
  terrain_lookup_table[12]="desert"
  terrain_lookup_table[13]="tundra"
  terrain_lookup_table[14]="beach"
  terrain_lookup_table[15]="hill"
  terrain_lookup_table[16]="dunes"
  terrain_lookup_table[17]="jungle"
  terrain_lookup_table[18]="ocean"
  terrain_lookup_table[19]="stream"
  terrain_lookup_table[20]="river"
  terrain_lookup_table[21]="underwater"
  terrain_lookup_table[22]="underground"
  terrain_lookup_table[23]="air"
  terrain_lookup_table[24]="ice"
  terrain_lookup_table[25]="lava"
  terrain_lookup_table[26]="ruins"
  terrain_lookup_table[27]="cave"
  terrain_lookup_table[28]="city"
  terrain_lookup_table[29]="marsh"
  terrain_lookup_table[30]="wasteland"
  terrain_lookup_table[31]="cloud"
  terrain_lookup_table[32]="water"
  terrain_lookup_table[33]="metal"
  terrain_lookup_table[34]="taiga"
  terrain_lookup_table[35]="sewer"

  -- pitch table for starcatcher fury of the heavens trigs
  stscatcherpitch = {
  ["10..."] = "-30",
  ["9..."] = "-10",
  ["8..."] = "10",
  ["7..."] = "30",
  ["6..."] = "50",
  ["5..."] = "70",
  ["4..."] = "90",
  ["3..."] = "110",
  ["2..."] = "130",
  ["1..."] = "150"}
  stscatchers = 0

  voltype=1
  weapon=""
  nobot=false
  ambience_playout_device_id=11
  areamusic_playout_device_id=11
  tfish=0
  cmistr=""
  cmi=0
  noreclay=false
  dteeth=0
  teeth=0
  counter=0
  brewing=0

  ritems=0
  recipe={}
  sdir=GetInfo(67).."sounds/"
  --loading
  minions={}
  idstring=""
  EnableTimer("ambtimer",0)
  DoAfterSpecial(15,'EnableTimer("ambtimer",1)',12)
  mnregen=0
  exptnl=0
  gtype=1
  adjectives={
  "",
  flaming=true,lunging=true,zapping=true,leaping=true,burning=true,clawed=true,fiery=true,freezing=true,icy=true,venomous=true,poisonous=true,corroding=true,acidic=true,shocking=true,electric=true,windy=true,cyclonic=true,airy=true}
  nouns={
  "",
  bite=true,chop=true,snatch=true,crush=true,slash=true,slap=true,kick=true,pierce=true,attack=true,cleave=true,punch=true,slice=true,hack=true,claw=true,blast=true,foot=true,splat=true,thwap=true,sweep=true,spit=true,gore=true,stomp=true,stab=true,pound=true,whip=true,riposte=true,lance=true,thrust=true}
  verbs={
  scratches=true,hits=true,wounds=true,injures=true,mauls=true,decimates=true,devastates=true,maims=true,MUTILATES=true,DISMEMBERS=true,DISEMBOWELS=true,MASSACRES=true, ["*** MASSACRES ***"] =true,DEVASTATES=true, ["*** DEVASTATES ***"] =true, ["*** OBLITERATES ***"] =true,OBLITERATES=true,["*** DEMOLISHES ***"]=true,DEMOLISHES=true, ["*** ANNIHILATES ***"]=true,ANNIHILATES=true,["*** DESTROYS ***"]=true,DESTROYS=true}
  verbs["*** DEVASTATES ***"]=true
  prevpose="stand"
  eventregen=1

  affects={}
  flags={}

  soundfile_init()

  EnableTimer("ambiencetimer", true)
  fc=0
  prevfc=0
  damages={}
  damages={
  scratches=true,hits=true,wounds=true,injures=true,mauls=true,decimates=true,devastates=true,maims=true,MUTILATES=true,DISMEMBERS=true,DISEMBOWELS=true,MASSACRES=true, ["*** MASSACRES ***"] =true, ["*** DEVASTATES ***"] =true, ["*** OBLITERATES ***"] =true,OBLITERATES=true,["*** DEMOLISHES ***"]=true,DEMOLISHES=true, ["*** ANNIHILATES ***"]=true,ANNIHILATES=true,["*** DESTROYS ***"]=true,DESTROYS=true}
  nfight=0
  res=0
  exptnl=0
  praccost=10000000
  classtnl="none"
  levtnl=0
  gmhp={}
  gmmhp={}
  gmmn={}
  gmmmn={}
  gmmv={}
  gmmmv={}
  lastdir="north"
  mg="male"
  warned1={}
  warned2={}
  warned3={}
  casting=""
  f = io.input (GetInfo(56).."\worlds/ctips.txt")
  tipslines={}
  repeat
    s = f:read ("*l") -- read one line
    if s then  -- if not end of file (EOF)
     table.insert(tipslines, s) -- print that line
    end
  until not s  -- until end of file
  fnames={}
  group={}
  truced=0
  spells={}
  cspells=1
  kspells={}
  skills={}
  kskills={}
  ways={}
  ways2={}
  cspells=1
  spose=0
  map=0
  stealth=0
  jli=1
  DoAfterSpecial(3, 'jli=0', 12)
  exp=0
expInfo = {}
expInfo.levelTBL = {}
expInfo.lastDeath = 0
expInfo.exp = 0
expInfo.prevexp = 0
expInfo.practices={}
expInfo.practices.requirement = 0
expInfo.practices.count=nil
expInfo.tnl = {}
  exm = {}
exm.events = {}
exm.events.leveled = {}
exm.events.microleveled = {}

  prevlength=0
  prevexp=0
gTime = {}
gTime.pm=false
gTime.hours=0
gTime.minutes=0
gTime.twelveHours=12

  inv={}
  dt=0
  carrycount=0
  carrysay=0
  getcount=0
  getsay=0
  getitems={}
  mort=0
  knowref=0
  smwarn=0
  Sound("stop=all")
  carryblock=0
  getblock=0
  carrycount=0
  getcount=0
  gender="male"
  tank=0
  recastwarn=0
  prevmon=0
  vbad={}
  bad={}
  poor={}
  fair={}
  moderate={}
  avg={}
  good={}
  vgood={}
  exceptional={}
  perfect={}
  EnableGroup("group", 0)
  EnableGroup("cgroup", 0)
  EnableGroup("frostbite", 0)
  EnableGroup("fishing", 0)
  EnableGroup("combat",0)
  prevmv=2
  terrain="town"
  daynight="day"
  prev_daynight=0
  players = {}
  prevmn =1
  k_mana = 1000
  prevhp = 1
  k_hp = 1000
  grouped=0
  k_move=1000
  randfunc,errfunc=assert(loadfile(GetInfo(57).."alteraeon/randoms.txt"))
  randfunc()

  -- supporting table for runeinfo feature
  rune={
  Khil="hitroll",
  Gesu="armor",
  Hett ="chr",
  Ilnak="mana",
  Kenn="hp or mv regen",
  ["Gesu-Ilnak"]="spellsave",
  ["Gesu-Faru"]="firesave",
  ["Gesu-Fell"]="poisonsave",
  Kama="attackspeed",
  ["Gesu-Char"]="zapsave",
  ["Ilnak-Xix"]="manaregen or absorbmagic",
  Ber="dam",
  Vin="luck",
  Arim="move",
  Tal="str",
  Oshi="dex",
  Ilnak="mana",
  ["Gesu-Ciru"]="coldsave",
  Hett="chr",
  ["Gesu-Nar"]="breathsave",
  Freth="wis",
  Shul="hp or con",
  Ganta="castability",
  Stis="int"
}

end

--------------------------------------------------------------------
-- scm reset/clear
--------------------------------------------------------------------

function scm_reset()
  counters           = {}
  counters.date      = os.date("%B %d %H:%M:%S")
  counters.teeth     = 0
  counters.bteeth    = 0
  counters.hits      = 0
  counters.dodge     = 0
  counters.parry     = 0
  counters.theydodge = 0
  counters.enemyhits = 0
  counters.parryc    = 0
  counters.absorb    = 0
  counters.kills     = 0
  counters.flee      = 0
  counters.cast      = 0
  counters.betterats = 0
  counters.disarm    = 0
  counters.rescue    = 0
  counters.frescue   = 0
  counters.steal     = 0
end

function sanity_check_scm_vars()
  if (counters           == nil) then counters           = {} end
  if (counters.date      == nil) then counters.date      = os.date("%B %d %H:%M:%S") end
  if (counters.teeth     == nil) then counters.teeth     = 0 end
  if (counters.bteeth    == nil) then counters.bteeth    = 0 end
  if (counters.hits      == nil) then counters.hits      = 0 end
  if (counters.dodge     == nil) then counters.dodge     = 0 end
  if (counters.parry     == nil) then counters.parry     = 0 end
  if (counters.theydodge == nil) then counters.theydodge = 0 end
  if (counters.enemyhits == nil) then counters.enemyhits = 0 end
  if (counters.parryc    == nil) then counters.parryc    = 0 end
  if (counters.absorb    == nil) then counters.absorb    = 0 end
  if (counters.kills     == nil) then counters.kills     = 0 end
  if (counters.flee      == nil) then counters.flee      = 0 end
  if (counters.cast      == nil) then counters.cast      = 0 end
  if (counters.betterats == nil) then counters.betterats = 0 end
  if (counters.disarm    == nil) then counters.disarm    = 0 end
  if (counters.rescue    == nil) then counters.rescue    = 0 end
  if (counters.frescue   == nil) then counters.frescue   = 0 end
  if (counters.steal     == nil) then counters.steal     = 0 end
end

--------------------------------------------------------------------
-- plugin miscellaneous
--------------------------------------------------------------------

function OnPluginConnect()
if(initialized==true) then -- run startup/init from the top
context.current.name="login screen" -- just to prevent spam of init commands in login screen.
context.current.id=no_context_id()
OnPluginInstall() -- Begin loading
end
-- Disable the tips timer until after login.
  EnableTimer("tipsTimer",false)
end

function OnPluginDisconnect()
  -- Disable tips and ping timer when disconnected
  EnableTimer("tipsTimer",false)
  EnableTimer("pingtimer",true)

  SaveState()
end

function OnPluginCommandEntered(s) 
  if gs("enterinterrupt") == true then
    Execute("tts_stop")
  end
end


----------------------------------------------------------------------
-- plugin install/startup
----------------------------------------------------------------------

function dentin_dofile(filename)
  local f = loadfile(filename)
  if (f == nil) then
    Note("File '" .. filename .. "' appears to be corrupt.  Ignoring.")
  else
    return f()
  end
end

function fsize (file)
  local file=io.open(file)
  if file then
    file:seek()      -- get current position
    local size = file:seek("end")    -- get file size
    file:close()
    return size
  else
    return nil
  end
end

function OnPluginInstall()
  -- sanity - do early init as soon as possible
  math.randomseed(os.time())
  math.random(); math.random();
  math.random(); math.random();

ppi.unload()
ppi.init()
  startup_do_mandatory_var_init()
  startup_clear_working_vars()
  settingtables()
  initialize_soundfile_aliases()

  -- if they still have the old updater, force a download of the new one
  if (fsize(GetInfo(59).."/update.exe") == 383289) then
    if (fsize(GetInfo(59).."/update_lite.exe") ~= nil) then
      Note("")
      Note("You are using the old version of the automatic updater.")
      Note("Upgrading to new version.")
      -- updater has to be run from the right directory
	      local ret = os.execute("cd ..\.. & update_lite.exe")
    end
  end

  require "serialize"

  -----------------
  if (FileExists(GetInfo(67).."/settings/filters.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/filters.mushz")
  end
  sanity_check_filter_settings()

  -----------------
  clear_eqlist_vars()
  if (FileExists(GetInfo(67).."/settings/eqlists.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/eqlists.mushz")
  end
  sanity_check_eqlist_vars()

  -----------------
  if (FileExists(GetInfo(67).."/settings/charlist.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/charlist.mushz")
  end
  sanity_check_charlist()

  -----------------
  if (FileExists(GetInfo(67).."/settings/counters.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/counters.mushz")
  end
  sanity_check_scm_vars()

  -----------------
  if (FileExists(GetInfo(67).."/settings/recast.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/recast.mushz")
  end
  sanity_check_recast_vars()

  -----------------
  if (FileExists(GetInfo(67).."/settings/storefilter.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/storefilter.mushz")
  end
  if (storefilter == nil) then
    storefilter = {}
  end

  -----------------
  if (FileExists(GetInfo(67).."/settings/settings.mushz")==true) then
    dentin_dofile(GetInfo(67).."/settings/settings.mushz")
    --Note("recovered settings from "..GetInfo(67).."/settings/settings.mushz")
  end
  -- make sure the loaded settings are sane
  sanity_check_config_settings()

  -----------------
  -- now that we're done with file load, reset internal vars to sane values
  startup_clear_working_vars()
  update_config() -- If any config values need to be moved, updated, or delete it, update_config does it
  check_all_visible()

--check to see if the mud is connected and load variables:
if not context then context={} end
if not context.current then context.current={} end
if (GetInfo(227)==8 and context.current.name~="login screen") then
Execute("redo")
end

--Set variable to prevent this from being ran again again when loading for the first time when connecting:
if(not initialized or initialized==false) then
initialized=false -- will get checked again later on and flipped to true.
end
end

----------------------------------------------------------------------
-- accelerator helpers
----------------------------------------------------------------------

function do_hard_abort()
  -- this sends the 'abort' string to the server
  Send("abort")
end

function do_hard_interrupt()
  -- this sends a hard 'interrupt' character to the server
  Send("\003")
end

function do_hard_stop()
  -- this sends a hard 'stop' character to the server
  Send("\026")
end

----------------------------------------------------------------------
-- key bindings
----------------------------------------------------------------------
Accelerator("alt+z","!mapclear")
Accelerator("f1",  "f01")
Accelerator("f2",  "f02")

Accelerator("f3",  "macro-sacc")
Accelerator("f4",  "macro-sacc2")
Accelerator("alt+a",  "avexm")
Accelerator("f5",  "f05")
Accelerator("f6",  "f06")
Accelerator("f7",  "f07")
Accelerator("f8",  "f08")
Accelerator("f9",  "f09")
Accelerator("f10", "voltoggle")
Accelerator("f11", "voldown")
Accelerator("f12", "volup")

Accelerator("ctrl+f1",  "macro-recast")
Accelerator("ctrl+f2",  "cf02")
Accelerator("ctrl+f3",  "cf03")
-- ctrl+f4 -- used by OS for close document
Accelerator("ctrl+f5",  "cf05")
Accelerator("ctrl+f6",  "cf06")
Accelerator("ctrl+f7",  "cf07")
Accelerator("ctrl+f8",  "cf08")
Accelerator("ctrl+f9",  "cf09")
Accelerator("ctrl+f10", "cf10")
Accelerator("ctrl+f11", "cf11")
-- ctrl+f12 -- used by lua audio as sound toggle

Accelerator("shift+f1",  "sf01")
Accelerator("shift+f2",  "sf02")
Accelerator("shift+f3",  "sf03")
Accelerator("shift+f4",  "sf04")
Accelerator("shift+f5",  "sf05")
Accelerator("shift+f6",  "sf06")
Accelerator("shift+f7",  "sf07")
Accelerator("shift+f8",  "sf08")
Accelerator("shift+f9",  "sf09")
Accelerator("shift+f10", "sf10")
Accelerator("shift+f11", "sf11")
Accelerator("shift+f12", "sf12")

Accelerator("alt+f1",  "af01")
Accelerator("alt+f2",  "af02")
Accelerator("alt+f3",  "af03")
-- alt+f4 -- used by system for program close
Accelerator("alt+f5",  "af05")
Accelerator("alt+f6",  "af06")
Accelerator("alt+f7",  "af07")
Accelerator("alt+f8",  "af08")
Accelerator("alt+f9",  "af09")
Accelerator("alt+f10", "voltoggle")
Accelerator("alt+f11", "volup")
Accelerator("alt+f12", "voldown")

-- WARNING NOTE -- LOTS OF ALT ALPHA KEYS USED BY DIRECTION_PLUGIN.XML --
-- WARNING NOTE -- CHECK FOR CLOBBERING BEFORE ADDING --

Accelerator("alt+e", "stand")
Accelerator("alt+d", "_sleep")

Accelerator("ctrl+shift+s", "config speedwalk")
Accelerator("alt+shift+g", "automaticmove")
Accelerator("alt+p", "enter portal")

Accelerator("alt+h", "ttshp")
Accelerator("alt+m", "ttsmana")
Accelerator("alt+v", "ttsmv")
Accelerator("alt+t", "ttsop")
Accelerator("alt+g", "ttsgold")
Accelerator("alt+x", "ttsexp")

-- override the Mushclient auto say keyboard shortcut with nothingness
AcceleratorTo ("Shift+Ctrl+A", "--" , sendto.script)

Accelerator("alt+shift+s", "stealth")
Accelerator("ctrl+l", "redo")
Accelerator("ctrl+shift+l", "reloadaudio")
Accelerator("ctrl+alt+l", "goldlog")

Accelerator("shift+esc", "macro-abort")
Accelerator("ctrl+d", "macro-interrupt")
Accelerator("ctrl+\\", "macro-stop")

-- WARNING -- AA HAS ITS OWN ACCELERATORS AND DOES NOT NEED DIRECTION PLUGIN --
-- WARNING -- DIRECTION PLUGIN HAS ITS OWN ACCELERATOR OVERRIDES --

Accelerator("alt+i", "n")
Accelerator("alt+k", "s")
Accelerator("alt+l", "e")
Accelerator("alt+j", "w")
Accelerator("alt+o", "ne")
Accelerator("alt+u", "nw")
Accelerator("alt+,", "se")
Accelerator("alt+n", "sw")
Accelerator("alt+r", "u")
Accelerator("alt+f", "d")
Accelerator("alt+shift+m", "mapping")

-- ctrl+shift+f12 -- used by MushReader.xml
-- ESC -- used by tts_sapi.xml

function display_accelerator_list()
  for i,j in pairs(AcceleratorList()) do
    Note(j)
  end
end

]]>
</script>
</muclient>
