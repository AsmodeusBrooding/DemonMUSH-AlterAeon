<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, April 26, 2018, 7:21 AM -->
<!-- MuClient version 4.51 -->
<!DOCTYPE muclient [
  <!ENTITY show_vnums "true" >
  <!ENTITY show_timing "false" >
  <!ENTITY show_completed "false" >
  <!ENTITY show_database_mods "true" >
  <!ENTITY show_other_areas "true" >
  <!ENTITY show_area_exits "true" >
  <!ENTITY show_up_down "false" >
  <!ENTITY speedwalk_prefix "" >
]>
<!-- Plugin "AlterAeonMapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="DemonMUSH_Mapper"
   author="Demon, Endymion, Valour"
   id="dd07d6dbe73fe0bd02ddb63d"
   language="Lua"
   purpose="Shows the mapper for Alter Aeon"
   save_state="y"
   date_written="2018-04-26 07:21:01"
   requires="4.51"
   version="1.0"
   >

</plugin>

<aliases>

  <!--  zooming aliases -->

 <alias
   match="mapper zoom out"
   enabled="y"
   sequence="100"
   omit_from_command_history="y"
   omit_from_output="y"
   script="mapper.zoom_out"
  >
  </alias>

<alias
   match="mapper zoom in"
   enabled="y"
   sequence="100"
   omit_from_command_history="y"
   omit_from_output="y"
   script="mapper.zoom_in"
  >
  </alias>
<alias
   match="mapper thisroom"
   enabled="y"
   sequence="100"
   script="show_this_room"
   regexp="n">
</alias>
<alias
   match="^mapper addnote( .*)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   room_edit_note(nil,nil,Trim("%1"))
</send>
</alias>
<alias
   match="^mapper next( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
>
<send>
mapper.gotoNextResult(Trim("%1"))
</send>
</alias>

 <alias
   match="mapper resume"
   enabled="y"
   sequence="100"
   script="map_resume"
  >

  </alias>
 <alias
   match="go"
   enabled="y"
   sequence="100"
   script="map_resume"
  >

  </alias>
 <alias
   match="mapper stop"
   enabled="y"
   sequence="100"
   script="mapper.cancel_speedwalk"
  >
  </alias>

 <!--  show/hide mapper -->

  <alias
   match="mapper hide"
   enabled="y"
   sequence="100"
   script="mapper.hide"
  >
  </alias>

   <alias
   match="mapper show"
   enabled="y"
   sequence="100"
   script="mapper.show"
  >
  </alias>
<alias
   match="^mapper help( (.*))?$"
   enabled="y"
   regexp="y"
   script="OnHelp"
></alias>

<alias
   match="^mapper updown$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   mapper.show_up_down = not mapper.show_up_down
   mapper.draw (current_room)
</send>
</alias>

<alias
   match="^mapper underlines?$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   NoUnderline_hyperlinks = not NoUnderline_hyperlinks
   Note("Mapper hyperlinks will " ..(NoUnderline_hyperlinks and "no longer" or "now").." be underlined.")
   SetVariable("NoUnderline_hyperlinks", NoUnderline_hyperlinks and "1" or "0")
</send>
</alias>
 <alias
   match="mapper goto *"
   enabled="y"
   sequence="100"
   script="map_goto"
  >
  </alias>
<alias
   match="mapper find *"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="n"
></alias>
<alias
   match="mapper findpath * *"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="findpathfast"
></alias>

  <alias
   match="mapper where *"
   enabled="y"
   sequence="100"
   script="map_where"
  >
  </alias>
  <alias
   match="mapper backup"
   enabled="y"
   sequence="100"
   script="backup_db"
  >
  </alias>
  <alias
   match="^mapper delete room (\d+)$"
   enabled="y"
   regexp="y"
   script="delete_room_alias"
>
</alias>
<alias
   match="^mapper delete area (.+)$"
   enabled="y"
   regexp="y"
   script="delete_area_alias"
>
</alias>


<alias
  match="^mapper flag (.*)$"
  enabled="y"
  regexp="y"
  sequence="100"
  script="updateRoomInfo">
</alias>


<alias
match="UpdateTownSpecial"
enabled="n"
sequence="100"
>
<send>
where shops | prefix {Where Shop}
where banks | prefix {Where Bank}
where teachers | prefix {Where Teacher}
where guildmasters | prefix {Where Guildmaster}
where employers | prefix {Where Employer}
where priests | prefix {Where Priest}
where forges | prefix {Where Forge}
</send>
</alias>

  <alias
   match="^mapper print$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="14"
  >
<send>
util.print("{R--------------------------------------------------")
   AnsiNote(ColoursToANSI(" {WRoom UID: {Y"..current_room.."{R"))
   AnsiNote(ColoursToANSI(" {WName: {Y"..name.."{R"))
   AnsiNote(ColoursToANSI(" {WTerrain: {Y"..terrain.."{R"))
   AnsiNote(ColoursToANSI(" {WExits: {Y"..printexits.."{R"))
   AnsiNote(ColoursToANSI(" {WCurrent Area: {Y"..current_area.."{R"))
   local info
   if (rooms[uid] ~= nil and rooms[uid].info ~= nil and rooms[uid].info ~= "") then
      info = rooms[uid].info
   else
      info = " No flags"
   end
   AnsiNote(ColoursToANSI(" {WRoom Flags: {Y"..info.."{R"))
util.print("{R--------------------------------------------------")
</send>
  </alias>

</aliases>


<!--  Triggers  -->

<triggers>
  <trigger
   enabled="n"
   match="^kxwt\_waypoint$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
<send>waypointtoggle()</send>
  </trigger>
  <trigger
  enabled="y"
  match="kxwt_rshort *"
  name="process_room_name"
  sequence="100"
  send_to="14"
  >
  <send>
    name="%1"
    if rooms ~= nil and
       rooms[uid] ~= nil and
       rooms[uid].notes ~= nil and
       rooms[uid].notes ~= ""
    then
      mapper.mapprint("Note:", rooms[uid].notes)
    end
  </send>
  </trigger>
  <trigger
  enabled="y"
  match="kxwt_rvnum * * * * * * *"
  name="process_room_desc"
  sequence="100"
  script="room_number"
  >
  </trigger>
  <trigger
  enabled="y"
  match="kxwt_walkdir *"
  name="moved_direction"
  sequence="100"
  script="moved_direction"
  >
  </trigger>
  <trigger
  enabled="y"
  match="kxwt_terrain *"
  name="process_terrain"
  sequence="100"
  send_to="14"
  >
  <send>terrain="%1"</send>
  </trigger>
  <trigger
  enabled="y"
  match="kxwt_area * *"
  name="process_area"
  sequence="100"
  send_to="14"
  >
  <send>area="%2"</send>
  </trigger>
  <trigger
  enabled="y"
  match="[Exits: *]"
  name="Exits_Line"
  sequence="100"
  send_to="14"
  >
  <send>process_exits("%1")</send>
  </trigger>
  <trigger
  enabled="y"
  match="Alas, you cannot go that way."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="* would be left behind."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You are too exhausted to continue your stealthy movement!"
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You are too exhausted."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You follow * *."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You'll have to climb to go there."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't just walk away from a fight!"
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="The * is closed."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="* blocks your path, preventing you from passing."
  script="mapper.cancel_speedwalk"
  sequence="100"
  ></trigger>
  <trigger
   enabled="y"
   match="^The (door|gate) is closed\.$"
   regexp="y"
   name="Door_Closed"
   script="Door_Closed"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="The wooden door is closed."
   regexp=""
   name="woodendoor_closed"
   script="Door_Closed"
   sequence="100"
  >
  </trigger>
<trigger
   enabled="y"
   match="^{Where (.*)}\w{1,2}(?:.*->)?\s+(.*)$"
   regexp="y"
   name="InfoUpdate"
   script="updateRoomInfo"
   sequence="100"
>
</trigger>
</triggers>

<!--  Timers  -->

<timers>
    <timer
	   name="backup_timer"
	   enabled="y"
	   script="backup_db"
	   hour="1" minute="01" second="59"
	   active_closed="y" >
	</timer>
</timers>

<!--  Script  -->


<script>
local show_other_areas = &show_other_areas;
<![CDATA[

mapper = require "altermapper"
require "serialize"
require "copytable"
require "wait"
require "utility"
require "tprint"
uid = -999
current_room=nil
current_area = -999
expected_exit=-666
from_room=""
last_direction_moved=nil
terrain = 0
area = "<No area>"
last_backup = GetVariable("last_backup") or 0
notes = 0
default_width = 269
default_height = 335
local posx = 100
local posy = 100
local DIFFERENT_AREA_COLOUR = "#ff0000"
areaname = -999
last_direction_moved = nil


count = 0
roomcount = 0
rooms = {}
local user_terrain_colour = {}

local kxwt_dirs = {
	["0"] = "n",
	["2"] = "s",
	["4"] = "ne",
	["6"] = "sw",
	["5"] = "se",
	["7"] = "nw",
	["3"] = "w",
	["1"] = "e",
	["20"] = "u",
	["30"] = "d",
	["99"] = "unk" -- idk what to do here (nothing?) (i'm not sure either, maybe wait till it happens and you can duplicate it)
}

valid_direction = {
n = "n",
s = "s",
e = "e",
w = "w",
u = "u",
d = "d",
ne = "ne",
sw = "sw",
nw = "nw",
no="n",
ea="e",
so="s",
we="w",
se = "se",
north = "n",
south = "s",
east = "e",
west = "w",
up = "u",
down = "d",
northeast = "ne",
northwest = "nw",
southeast = "se",
southwest = "sw",
['in'] = "in",
out = "out",
}  -- end of valid_direction


terrain_color = {}

-----------------------------------------
-- ADDING TRIGGER STUFF
-----------------------------------------

function room_number(name, line, args)
	uid = args[1] -- this was in the <send> previously
	from_room = current_room or ""
	current_room = args[1]
end

function moved_direction(name, line, args)
	last_direction_moved = kxwt_dirs[args[1]] or "unk"
end

------------------------------------------
--Update Town Special Procedure
------------------------------------------

function updateRoomInfo(name, line, wildcards)
    local roomtype, room, roomuid, matchFound = wildcards[1], wildcards[2], current_room or 0, false

    if room then
        for i,v in pairs(rooms) do
            if v.name == Trim(room) then
                roomuid = i
                matchFound = true
                break
            end
        end
    else
        matchFound = true
    end

    if matchFound == true then
        if not rooms[roomuid].info then
            rooms[roomuid].info = roomtype
        else
            if not string.find(rooms[roomuid].info, roomtype) then
              rooms[roomuid].info = rooms[roomuid].info .. roomtype
              add_update_room(roomuid, rooms[roomuid])
            end
        end
        mapper.draw(roomuid)
    else
        print("Room not mapped!")
    end
end

-----------------------------------------
-- DONE ADDING TRIGGER STUFF
-----------------------------------------

function room_edit_note(room, vuid, newnotes)
  if vuid == nil and current_room ~= nil then
    vuid = current_room
    room = rooms[vuid]
  end

  if vuid == nil then -- still nothing?
    print("No room received from the mud yet. Try using the 'LOOK' command first.")
    return
  end

  if newnotes == nil or newnotes == "" then
    if room.notes ~= nil and room.notes ~= "" then
      newnotes = utils.inputbox("Modify room comment (clear it to delete from database)", room.name, room.notes)
    else
      newnotes = utils.inputbox("Enter room comment (creates a note for this room)", room.name, room.notes)
    end -- if
  end

  if not newnotes then
    return
  end -- if cancelled

  if newnotes == "" then
    if room.notes == nil or room.notes == "" then
      mapper.mapprint("No comment entered, note not saved.")
      return
    else
      mapper.mapprint("Note from room " .. current_room .. " deleted. Was previously: " .. room.notes)
      rooms[current_room].notes = ""
      add_update_room(current_room, rooms[current_room])
      mapper.draw(current_room)
    end
  end

  if rooms[current_room].notes == newnotes then
    return -- no change made
  end

  local oldNote = room.note

  rooms[current_room].notes = newnotes
  add_update_room(current_room, rooms[current_room])
  mapper.draw(current_room)

  if oldNote ~= nil and #oldNote > 0 then
    mapper.mapprint("Note for room", current_room, "changed to:", newnotes)
  else
    mapper.mapprint("Note added to room", current_room, ":", newnotes)
  end
end


-- -----------------------------------------------------------------
-- Here on "Exits:" line ----- we have changed rooms
-- -----------------------------------------------------------------

function process_exits (exits_str)
	--Note("process exits")
  if current_room == from_room then
	--Note(current_room, ", ", from_room)
	--Note("same room")
    --return
  end
  

  -- genereate a "room ID" by hashing the room name, description and exits
  -- break up exits into individual directions
  exits = {}

  for exit in string.gmatch (exits_str, "%w+") do
    local ex = valid_direction [exit]
    if ex then
      exits [ex] = "-666"  -- don't know where it goes yet
    end -- if
  end -- for
    printexits = exits_str

  -- add to table if not known
  --Note("add room to table")
  if not rooms [uid] then
   rooms [uid] = { name = name, desc = uid, exits = exits, area=area, fillcolour=terrain_color[terrain], fillbrush=0, bordercolour=0xffffff }
   add_update_room(uid, rooms[uid])
  end -- if

  -- save so we know current room later on
  current_room = uid

  -- add exit into mapper
  --Note("add exit")
  if from_room ~= "" and last_direction_moved then -- we were in a room # that we got from kxwt, and then moved to another room
	--Note("rooms[", from_room, "].exits[", last_direction_moved, "] = ", current_room)
	rooms[from_room].exits[last_direction_moved] = current_room
	add_update_room(from_room, rooms[from_room])
	last_direction_moved = nil -- remove last direction so updating a room only happens when we walk somewhere
  end

  -- call mapper to draw this room
  mapper.draw (uid)

end -- process_exits

-- -----------------------------------------------------------------
-- Here on white coloured line - this is a room name or room exits
-- -----------------------------------------------------------------

function Name_Or_Exits (name, line, wildcards)

  exits = string.match (line, "^Exits: (.*)")

  if exits then
    process_exits (exits)
  end -- if

  roomname = line
  roomdesc = nil
  areaname = 0

end -- Name_Or_Exits

-- -----------------------------------------------------------------
-- Here on yellow line - part of room description
-- -----------------------------------------------------------------

function Name_Line (name, line, wildcards)
  roomdesc = (roomdesc or "" ) .. line .. "\n"
end -- Name_Or_Exits
-- -----------------------------------------------------------------
-- for converting things like ^ $ * etc. into "escaped" sequences
-- -----------------------------------------------------------------
function fix_regexp_magic_characters (r)
    return string.gsub (r, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1")
end -- fix_regexp_magic_characters

-- -----------------------------------------------------------------
-- mapper 'get_room' callback - it wants to know about room uid
-- -----------------------------------------------------------------

function get_room (uid)


  if not rooms [uid] then
   return nil
  end -- if

  local room = copytable.deep (rooms [uid])
   local notes = ""
   if room.notes and room.notes ~= "" then
      notes = "\nNote: " .. room.notes
   end -- if notes

  local texits = {}
  for dir in pairs (room.exits) do
    table.insert (texits, dir)
  end -- for
  table.sort (texits)

  if uid == current_room then
    current_area = room.area
  end -- if

  room.hovermessage = string.format (
"%s\tExits: %s\nRoom: %s\nArea: %s \nTerrain: %s%s",
      room.name,
      table.concat (texits, ", "),
      uid,
      area,
      terrain,
      notes
      -- depth,
      -- table.concat (path, ",")
      )


	    -- SPECIAL ROOM COLOUR FILLS
special_room = false
                         if room.info and room.info ~= "" then
                         if string.match (room.info, "waypoint") then
                                         special_room = true
                         elseif string.match (room.info, "bank") then
                                         special_room = true
                         elseif string.match (room.info, "alchemyguild") then
                                         special_room = true
                         elseif string.match (room.info, "teacher") then
                                         special_room = true
                         elseif string.match (room.info, "employer") then
                                         special_room = true
                         elseif string.match (room.info, "priest") then
                                         special_room = true
                         elseif string.match (room.info, "forge") then
                                         special_room = true
		                 elseif string.match (room.info, "warriortrainer") then
                                         special_room = true
				         elseif string.match (room.info, "thieftrainer") then
                                         special_room = true
				         elseif string.match (room.info, "druidtrainer") then
                                         special_room = true
		                 elseif string.match (room.info, "clerictrainer") then
                                         special_room = true
				         elseif string.match (room.info, "magetrainer") then
                                         special_room = true
				         elseif string.match (room.info, "necromancertrainer") then
                                         special_room = true
				         elseif string.match (room.info, "rangertrainer") then
                                         special_room = true

										end
end -- if
					     if uid == current_room and special_room then
                                         room.bordercolour = mapper.OUR_ROOM_COLOUR.colour
                                         room.borderpenwidth = 3

   elseif room.area ~= current_area then
    room.bordercolour = ColourNameToRGB "red"
  end -- not in this area
  return room


end -- get_room

function show_this_room (name, line, wildcards)
   local room = rooms[current_room]
   if room ~= nil then
      Note("Details about this room:")
      Note("+---------------------------+")
      Note("Name: "..(name or ""))
      Note("ID: "..(uid or ""))
      Note("Area: "..(area or ""))
      Note("Terrain: "..(terrain or ""))
      Note("Info: "..(room.info or ""))
      Note("Notes: "..(room.notes or ""))
      Note("Exits: "..(room.exits or ""))
else
      Note("THISROOM ERROR: You need to type 'LOOK' first to initialize the mapper before trying to get room information.")
   end
end -- show_this_room

function room_click (uid, flags)

   -- check we got room at all
   if not uid then
      return nil
   end -- if

   -- look it up
   local room = rooms [uid]

   -- not cached - see if in database
   if not room then
return
   end -- not in cache

   if not room then
      return
   end -- if still not there

  local function checkmark (which)
    if rooms [uid] [which] then
      return "+"
    else
      return ""
    end -- if
  end -- checkmark


  local handlers = {
      { name = "Edit bookmark", func = room_edit_bookmark} ,
      { name = "-", } ,
      { name = "Add Exit",    func = room_add_exit} ,
      { name = "Change Exit", func = room_change_exit} ,
      { name = "Delete Exit", func = room_delete_exit} ,
      { name = "-", } ,
      { name = checkmark ("shop")  .. "Shop",         func = room_toggle_shop } ,
      { name = checkmark ("train") .. "Trainer",      func = room_toggle_train } ,
      { name = checkmark ("inn")   .. "Inn",          func = room_toggle_inn } ,
      { name = checkmark ("guild") .. "Guildmaster",  func = room_toggle_guild } ,
     } -- handlers

  local t, tf = {}, {}
  for _, v in pairs (handlers) do
    table.insert (t, v.name)
    tf [v.name] = v.func
  end -- for

  local choice = WindowMenu (mapper.win,
                            WindowInfo (mapper.win, 14),
                            WindowInfo (mapper.win, 15),
                            table.concat (t, "|"))

  local f = tf [choice]

  if f then
    f (room, uid)
  end -- if handler found

end -- room_click


-- -----------------------------------------------------------------
-- map_find: mapper find xxx
-- -----------------------------------------------------------------
function map_find (name, line, wildcards)

--  mapper.mapprint (string.rep ("-", 25) .. " Mapper search " .. string.rep ("-", 25))
  local reset = ANSI (0)
  local bold = ANSI (1)
  local unbold = ANSI (22)

  local matches = { }
  local count = 0
  local target = Trim (wildcards [1]:lower ())
  util.print("{R-------------------------------------------------------")
  util.print("            ~F~W[~W~HSearching rooms for {F~W'Y~H".. target .. "~F~W']")
  util.print("{R-------------------------------------------------------")
  if target == "" then
    mapper.maperror ("No search string specified")
    return
  end -- if

  if not mapper.check_we_can_find () then
    return
  end -- if find not OK

  -- fix up any regular expression "magic" letters to be escaped by a %
  local fixed_target = fix_regexp_magic_characters (target)

  -- fix up for caseless searches in the room description (eg. "a" becomes "[aA]")
  local caseless_target = string.gsub (fixed_target, "(%a)", function (a)
      return "[" .. a:lower () .. a:upper () .. "]"
      end -- function
      )

  -- do a simple string search to find matching rooms
  for k, v in pairs (rooms) do

    -- don't want nil descriptions
    if not v.description then
      v.description = ""
    end -- if no description

    if string.find (v.name:lower (), fixed_target) or
       string.find (v.description:lower (), fixed_target) then
      matches [k] = true
      count = count + 1
    end -- if match
  end -- for each room

  local function show_snippet (uid)
    local room = rooms [uid]
     if not room then
       return
     end -- if

    -- don't bother if the wanted words was in the room name
    if string.find (room.name:lower (), fixed_target) then
      return
    end -- if

    -- otherwise show the wanted word in the description, in bold
    AnsiNote (reset .. string.gsub (room.desc, caseless_target, bold .. "%1" .. unbold))

  end -- show_snippet

  -- see if nearby
  mapper.find (
    function (uid)
      local room = matches [uid]
      if room then
        matches [uid] = nil
      end -- if
      return room, next (matches) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false,      -- don't auto-walk
    show_snippet  -- show find snippet
    )
end -- map_find

-- -----------------------------------------------------------------
-- note_find: note find xxx
-- -----------------------------------------------------------------
function note_find (name, line, wildcards)

  --mapper.mapprint (string.rep ("-", 25) .. " Mapper search " .. string.rep ("-", 25))
  local reset = ANSI (0)
  local bold = ANSI (1)
  local unbold = ANSI (22)

  local matches = { }
  local count = 0
  local target = Trim (wildcards [1]:lower ())
    util.print("{R-------------------------------------------------------")
  util.print("            {D[{WSearching notes for {D'{Y".. target .. "{D']")
    util.print("{R-------------------------------------------------------")
  if target == "" then
    mapper.maperror ("No search string specified")
    return
  end -- if

  if not mapper.check_we_can_find () then
    return
  end -- if find not OK

  -- fix up any regular expression "magic" letters to be escaped by a %
  local fixed_target = fix_regexp_magic_characters (target)

  -- fix up for caseless searches in the room description (eg. "a" becomes "[aA]")
  local caseless_target = string.gsub (fixed_target, "(%a)", function (a)
      return "[" .. a:lower () .. a:upper () .. "]"
      end -- function
      )
  -- do a simple string search to find matching rooms
  for k, v in pairs (rooms) do

    -- don't want nil descriptions
    if not v.description then
      v.description = ""
    end -- if no description

    if ((v.notes ~= nil) and (string.find (v.notes:lower (), fixed_target) or string.find (v.description:lower (), fixed_target))) then
      matches [k] = true
      count = count + 1
    end -- if match
  end -- for each room

  local function show_snippet (uid)
    local room = rooms [uid]
     if not room then
       return
     end -- if

    -- don't bother if the wanted words was in the room name
    if string.find (room.name:lower (), fixed_target) then
      return
    end -- if

    -- otherwise show the wanted word in the description, in bold
    AnsiNote (reset .. string.gsub (room.notes, caseless_target, bold .. "%1" .. unbold))

  end -- show_snippet

  -- see if nearby
  mapper.find (
    function (uid)
      local room = matches [uid]
      if room then
        matches [uid] = nil
      end -- if
      return room, next (matches) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false,      -- don't auto-walk
    show_snippet  -- show find snippet
    )
end -- note_find


-- -----------------------------------------------------------------
-- map_goto for: mapper goto xxx
-- -----------------------------------------------------------------
function map_goto (name, line, wildcards)
  local wanted = wildcards [1]
  -- check valid string
  if string.match (wanted, "%D") then
    mapper.maperror ("Room number must be numeric, you entered: " .. wanted)
    return
  end -- if

  -- see if already there
  if current_room and string.match (current_room, "^" .. wanted) then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  -- find desired room
  mapper.find (
    function (uid)
      local found = string.match (uid, "^" .. wanted)
      return found, found
    end,  -- function
    show_vnums,  -- show vnum?
    1,          -- how many to expect
    true        -- just walk there
    )
end -- map_goto

function map_resume (name, line, wildcards)

  local wanted = mapper.last_hyperlink_uid or mapper.last_speedwalk_uid

  if not wanted then
    mapper.print "No outstanding speedwalks or hyperlinks."
    return
  end -- if nothing to do

  -- find desired room
  mapper.find (
    function (uid)
      return uid == wanted, uid == wanted
    end,  -- function
    show_vnums,  -- show vnum?
    1,      -- how many to expect
    true    -- just walk there
    )

end -- map_resume

-- -----------------------------------------------------------------
-- map_where: Show where a room is
-- -----------------------------------------------------------------
function map_where (name, line, wildcards)
  if not mapper.check_we_can_find () then
    return
  end -- if
  local wanted = wildcards [1]
  if current_room and wanted == current_room then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  local paths = mapper.find_paths (current_room,
           function (uid)
             return uid == wanted,  -- wanted room?
                    uid == wanted   -- stop searching?
            end)
  local uid, item = next (paths, nil) -- extract first (only) path
  -- nothing? room not found
  if not item then
    mapper.mapprint (string.format ("Room %s not found", wanted))
    return
  end -- if
  -- turn into speedwalk
  local path = mapper.build_speedwalk (item.path)
  -- display it
  mapper.mapprint (string.format ("Path to %s is: %s", wanted, path))
end -- map_where

-- -----------------------------------------------------------------
-- cannot_walk - we tried to walk but failed
-- -----------------------------------------------------------------
function cannot_walk (name, line, wildcards)
  mapper.cancel_speedwalk ()
  room_description = nil
  current_exits = nil
  room_name = nil
  last_direction_moved = nil
--  mapper.mapprint ("Attempt to walk cancelled.")

end -- cannot_walk

function confirm_delete_area(a)
	response = utils.umsgbox("Delete area: "..a.."?", "Delete Area", "okcancel", "?", 2)
	if response == "ok" then
		delete_area(a)
	end
end

function Door_Closed (name, line, wildcards)

local dirs =  {
  n = "north",
  s = "south",
  e = "east",
  w = "west",
  u = "up",
  d = "down",
  ne = "northeast",
  sw = "southwest",
  nw = "northwest",
  se = "southeast",
  ['in'] = "in",
  out = "out",
  }  -- end of available

  if last_direction_moved then
    Send ("open " .. dirs [last_direction_moved])
    Send (dirs [last_direction_moved])
  end -- if

end -- Door_Closed


-- -----------------------------------------------------------------
-- check_for_cannot_go - look up the line in a table of failure messages
-- see table: cannot_move_messages
-- -----------------------------------------------------------------
function check_for_cannot_go (name, line, wildcards)

  for _, v in ipairs (cannot_move_messages) do
    if string.find (line, v) then
      cannot_walk ()
      break
    end -- if match
  end -- for each message
end -- check_for_cannot_go

function findpathfast(name, line, wildcards)
   local src = wildcards[1]
   local dest = wildcards[2]
   rooms[src] = load_room_from_database(src)
   rooms[dest] = load_room_from_database(dest)

   if rooms[src] == nil then
      mapper.mapprint (string.format ("Room %s not known.", src))
   end
   if rooms[dest] == nil then
      mapper.mapprint (string.format ("Room %s not known.", dest))
   end
   if rooms[src] == nil or rooms[dest] == nil then
      return
   end

   local foundpath = findpath(src, dest)
   if foundpath == nil then
      mapper.mapprint (string.format ("Path from %s to %s not found.", wildcards[1], wildcards[2]))
      return
   end

   -- turn into speedwalk
   local speedwalk = mapper.build_speedwalk (foundpath, speedwalk_prefix)

   -- display it
   if speedwalk ~= nil then
      mapper.mapprint (string.format ("Path from %s to %s is: %s", wildcards[1], wildcards[2], speedwalk))
   else
      mapper.mapprint ("Pick different start and end rooms.")
   end
end

function blackindigoPrint(msg)
	ColourNote("blueviolet","black",msg)
end
function blackredPrint(msg)
	ColourNote("black","red",msg)
end
function whiteindigoPrint(msg)
	ColourNote("white","indigo",msg)
end


function setup_terrain_colors()
terrain_color["0"]=tonumber("0x000000")--NOTSET
terrain_color["1"]=tonumber("0x606060")--Building
terrain_color["2"]=tonumber("0x805a22")--Town
terrain_color["3"]=tonumber("0x00ff00")--FIELD
terrain_color["4"]=tonumber("0x00c000")--LFOREST
terrain_color["5"]=tonumber("0x008000")--TFOREST
terrain_color["6"]=tonumber("0x004000")--DFOREST
terrain_color["7"]=tonumber("0x406080")--SWAMP
terrain_color["8"]=tonumber("0x60a060")--PLATEAU
terrain_color["9"]=ColourNameToRGB("khaki")--SANDY
terrain_color["10"]=tonumber("0xc0c0c0")--MOUNTAIN
terrain_color["11"]=tonumber("0x808080")--ROCK
terrain_color["12"]=ColourNameToRGB("burlywood")--DESERT
terrain_color["13"]=tonumber("0x805080")--TUNDRA
terrain_color["14"]=ColourNameToRGB("lightyellow")--BEACH
terrain_color["15"]=tonumber("0x409040")--HILL
terrain_color["16"]=ColourNameToRGB("navajowhite")--DUNES
terrain_color["17"]=tonumber("0x20c040")--JUNGLE
terrain_color["18"]=ColourNameToRGB("darkblue")--OCEAN
terrain_color["19"]=tonumber("0x00f0f0")--STREAM
terrain_color["20"]=ColourNameToRGB("blue")--RIVER
terrain_color["21"]=tonumber("0x021e6c")--UNDERWATER
terrain_color["22"]=tonumber("0x303030")--UNDERGROUND
terrain_color["23"]=ColourNameToRGB("lightskyblue")--AIR
terrain_color["24"]=tonumber("0x82f8e6")--ICE
terrain_color["25"]=ColourNameToRGB("red")--LAVA
terrain_color["26"]=tonumber("0x806060")--RUINS
terrain_color["27"]=tonumber("0x404040")--CAVE
terrain_color["28"]=tonumber("0x907040")--CITY
terrain_color["29"]=tonumber("0x20a060")--MARSH
terrain_color["30"]=tonumber("0xf0f0a0")--WASTELAND
terrain_color["31"]=tonumber("0xffffff")--CLOUD
terrain_color["32"]=ColourNameToRGB("blue")--WATER
terrain_color["33"]=tonumber("0x808080")--METAL
terrain_color["34"]=tonumber("0x006000")--TAIGA
terrain_color["35"]=tonumber("0x404040")--SEWER
terrain_color["36"]=ColourNameToRGB("indigo")--SHADOW
terrain_color["37"]=ColourNameToRGB("indigo")--CATACOMB
terrain_color["38"]=ColourNameToRGB("olivedrab")--MIRE
terrain_color["39"]=ColourNameToRGB("indigo")--CRYSTAL
 -- end of terrain_color
end

-- -----------------------------------------------------------------
-- Plugin Install
-- -----------------------------------------------------------------

function OnPluginInstall ()

  config = {}  -- in case not found
  setup_terrain_colors()

  -- get saved configuration
  assert (loadstring (GetVariable ("config") or "")) ()

  -- and rooms
  --assert (loadstring (GetVariable ("rooms") or "")) ()

  -- new stuff for sql data
  check_create_db()
  load_rooms()

  -- initialize mapper

  mapper.init { config = config,
                get_room = get_room, findpath = findpath,
                room_click = room_click,    -- called on RH click on room square,
                show_help = OnHelp,         -- to show help,
                show_other_areas = show_other_areas,  -- want to see areas other than the current one?
}
  mapper.mapprint (string.format ("MUSHclient mapper installed, version %0.1f", mapper.VERSION))


end -- OnPluginInstall

function OnHelp (name, line, wildcards)
   local help_header = "                              [Demon Mush Mapper Help]                              "

   local help_index = [[
                           Mapper Help Index
=============================================================================
 mapper help               --> Show this list
-----------------------------------------------------------------------------
 mapper help config        --> Commands for configuring the mapper
 mapper help moving        --> Commands for moving between rooms
 mapper help utils         --> Other utilitarian commands
 mapper help searching     --> Used for finding notes, shops, guildmasters, etc
=============================================================================
]]
   local help_table = {
   ['config'] = {
['header'] = [[===== CONFIGURATION =============>]],
[[mapper help                    --> This help
                                 > (or click the "?" button on the top right)]],
[[mapper zoom out                --> Zoom out]],
[[mapper zoom in                 --> Zoom in]],
[[mapper hide                    --> Hide map]],
[[mapper show                    --> Show map]],
[[mapper updown                  --> Toggle up/down exit drawing]],
[[mapper underlines              --> Toggle underlining of clickable links]]
},

   ['utils'] = {
['header'] = [[===== UTILITIES =================>]],
[[mapper backup                  --> Creates a backup of the mapper database]],
[[mapper addnote                 --> Add a new note to the current room]],
[[mapper addnote <note>          --> Ditto, but skips the dialog]]
},
   ['searching'] = {
['header'] = [[===== SEARCHING =================>]],
[[mapper find <text>             --> Full-text search the whole database]],
[[]],
[[mapper notes                   --> Show nearby rooms that you marked with notes]],
[[mapper notes <here/area>       --> Ditto]],
[[mapper shops                   --> Show all shops/banks]],
[[mapper shops <here/area>       --> Ditto]],
[[mapper train                   --> Show all trainers]],
[[mapper train <here/area>       --> Ditto]],
[[mapper quest                   --> Show all quest-givers]],
[[mapper quest <here/area>       --> Ditto]],
[[]],
[[mapper next                    --> Visit the next room in the most recent
                                 > list of results.]],
[[mapper next <index>            --> Ditto, but skip to the given result index.]],
[[mapper where <room id>         --> Show directions to a room number]]
},


   ['moving'] = {
['header'] = [[===== MOVING ====================>]],
[[mapper goto <room id>          --> Run to a room by its room number]]
}
}

   local function show_help(helps)
      blackindigoPrint("")
      blackindigoPrint(helps['header'])
      blackindigoPrint("")
      for i,v in ipairs(helps) do
         blackindigoPrint(v)
      end
   end

   blackindigoPrint("")
   whiteindigoPrint(help_header)
   blackindigoPrint("+---------------------------------------------------------------------------+")
   badnews = true
   if wildcards and wildcards[2] ~= "" then
      badnews = false
      if wildcards[2] == "all" then
         show_help(help_table['config'])
         show_help(help_table['exits'])
         show_help(help_table['searching'])
         show_help(help_table['moving'])
         show_help(help_table['utils'])
      elseif wildcards[2] == "config" then
         show_help(help_table['config'])
      elseif wildcards[2] == "searching" then
         show_help(help_table['searching'])
      elseif wildcards[2] == "moving" then
         show_help(help_table['moving'])
      elseif wildcards[2] == "utils" then
         show_help(help_table['utils'])
      elseif wildcards[2]:find("search ") == 1 then
         local st, en = wildcards[2]:find("search ")
         local pattern = Trim(wildcards[2]:sub(en+1))
         ColourTell("cornflower","black","Searching help for: ")
         ColourNote("red","black",pattern)
         if pattern ~= "" then
            for k,v in pairs(help_table) do
               local done_header = false
               for j,w in ipairs(v) do
                  if (w ~= "") and (w:find("--------",nil,true) == nil) and (w:find(pattern) ~= nil) then
                     if not done_header then
                        blackindigoPrint("")
                        blackindigoPrint(v['header'])
                        done_header = true
                     end
                     blackindigoPrint("")
                     local wtable = w:split(pattern)
                     for i,v in ipairs(wtable) do
                        ColourTell("cornflower","black",v)
                        if (i < #wtable) then
                           ColourTell("red", "black", pattern)
                        end
                     end
                     Note("")
                  end
               end
            end
         else
            badnews = true
         end
      else
         badnews = true
      end
   end
   if badnews then
      blackindigoPrint("")
      mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
      blackindigoPrint("")
      blackindigoPrint(help_index)
   end
   blackindigoPrint("")
   blackindigoPrint("+---------------------------------------------------------------------------+")
   blackindigoPrint("")
end


-- -----------------------------------------------------------------
-- Plugin Save State
-- -----------------------------------------------------------------

function OnPluginSaveState ()
  mapper.save_state ()
  SetVariable ("config", "config = " .. serialize.save_simple (config))
  SetVariable("last_backup", last_backup)
end -- OnPluginSaveState

------------------------------------------
-- start of sql additions
------------------------------------------
function delete_room_alias(name, line, wildcards)
	local num = wildcards[1]
	if num then
		delete_room(num)
	end
end

function delete_area_alias(name, line, wildcards)
	local a = wildcards[1]
	if a then
		delete_area(a)
	end
end

function delete_room(num) -- delete room from rooms
	for r, tbl in pairs(rooms) do -- for each room in table
		if tostring(r) == tostring(num) then
			rooms[r] = nil -- setting table item to nil deletes it
		end
	end
	run_sql([[DELETE FROM rooms WHERE uid = ']]..num..[[']])
	Note("Deleted ", num, ".")
	SendNoEcho("look")
end

function delete_area(a)
	local cnt = 0
	for r, tbl in pairs(rooms) do -- for each room in table
		if tostring(tbl.area) == tostring(a) then
			rooms[r] = nil -- setting table item to nil deletes it
			cnt = cnt + 1
		end
	end
	run_sql([[DELETE FROM rooms WHERE area = ']]..fix_sql(a)..[[']])
	Note("Deleted ", cnt, " rooms in '", a, "' area.")
end

function clean_file_name(f)
	f = string.gsub(f, "[^%w]", "")
	return f
end

function fix_sql(s)
	if not s then -- nil value
		return ""
	end
	return string.gsub(s, "'", "''")
end

function run_sql(sql)
	local db = assert(sqlite3.open(GetInfo(66)..clean_file_name(WorldName())..".db"))
	--Note(sql)
	rslt = db:exec(sql)
	--Note(rslt)
	db:close()
end

function load_rooms()
	rooms = {}
sql = [[
		UPDATE rooms SET fillcolour = 0 WHERE fillcolour = ''
	]]
run_sql(sql)
	sql = [[
		SELECT * FROM rooms ORDER BY uid ASC;
	]]
	local db = assert(sqlite3.open(GetInfo(66)..clean_file_name(WorldName())..".db"))
	local cnt = 0
	for row in db:nrows(sql) do
		cnt = cnt + 1
		rooms[row.uid] = {
			name = row.name,
			desc = row.desc,
			area = row.area,
			fillcolour = row.fillcolour,
			fillbrush = row.fillbrush,
			bordercolour = row.bordercolour,
			info = row.info,
			notes = row.notes,
			exits = loadstring("return "..row.exits)()
		}
	end
	Note("Loaded ", cnt, " rooms from database.")
	db:close()

	if tonumber(last_backup) == 0 then
		backup_db()
	end
end

function check_update_room(uid, room)
	if not rooms[uid] or (serialize.save_simple(room) ~= serialize.save_simple(rooms[uid])) then
		add_update_room(uid, room)
	end
end

function add_update_room(uid, room)
	sql = [[
		INSERT OR REPLACE INTO rooms (uid, name, desc, area, fillcolour, fillbrush, bordercolour, info, notes, exits)
		VALUES
		(']]..uid..[[',
		']]..fix_sql(room.name)..[[',
		']]..room.desc..[[',
		']]..fix_sql(room.area)..[[',
		']]..fix_sql(room.fillcolour)..[[',
		']]..fix_sql(room.fillbrush)..[[',
		']]..fix_sql(room.bordercolour)..[[',
		']]..fix_sql(room.info)..[[',
		']]..fix_sql(room.notes)..[[',
		']]..fix_sql(serialize.save_simple(room.exits))..[[')
	]]
	run_sql(sql)
end

function check_create_db()
	sql = [[
		CREATE TABLE IF NOT EXISTS rooms (
			uid TEXT PRIMARY KEY,
			name TEXT,
			desc TEXT,
			area TEXT,
			fillcolour INTEGER,
			fillbrush INTEGER,
			bordercolour INTEGER,
			info TEXT,
			notes TEXT,
			exits TEXT
		)
	]]
	run_sql(sql)
end

------------------------------------------
-- end of sql additions
------------------------------------------

------------------------------------------
-- backup stuff
------------------------------------------
-- If you want to do manual backups, make an alias with: script="backup_db"
------------------------------------------

function backup_db()
	Note("Creating database backup.")
	local bk_nm = GetInfo(66).."db_backups\\"..clean_file_name(WorldName())..".db."..os.date("%A")
	ffi = require("ffi")
	ffi.cdef[[
		bool CreateDirectoryA(const char *lpPathName, void *lpSecurityAttributes);
		bool CopyFileA(const char* lpExistingFileName, const char * lpNewFileName, bool bFailIfExists);
		unsigned long GetLastError(void);
	]]

	succ = ffi.C.CreateDirectoryA(GetInfo(66).."db_backups\\", nil)
	err_no = ffi.C.GetLastError()
	if err_no and err_no ~= 183 and err_no ~= 127 then
		Note("Error creating directory: ", err_no)
	end

	succ = ffi.C.CopyFileA(GetInfo(66)..clean_file_name(WorldName())..".db", bk_nm, false)

	Note("Backup created: ", bk_nm)
	last_backup = os.time()
end

------------------------------------------
-- end backup stuff
------------------------------------------

-- Special thanks to Fiendish, Endymion, Valour, and Nick Gammon for all of their assistance with the mapper, and the original basis from which its built.

]]>
</script>


</muclient>
