<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Salý, Þubat 05, 2019, 2:47 ÖS -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "DemonEQWIN" generated by Plugin Wizard -->

<muclient>
<plugin
  name="DemonMUSH_Utility_Window"
  author="Demon and Valour"
  id="e2dc05642ff5f4fec6cf039e"
  language="Lua"
  purpose="Equipment and Affects Miniwindow"
  save_state="y"
  date_written="2019-02-05 14:46:24"
  requires="5.06"
  version="1.0"
  >
</plugin>

<aliases>
  <alias
    match  = "^tab *(?<tab>eq|aff) *$"
    script = "CmdSwitchTab"
    enabled="y" regexp="y" sequence="100"></alias>
  <alias
    match  = "^(?<tab>eq|aff)$"
    script = "CmdSwitchTab"
    name   = "aEqAffRequest"
    enabled="y" regexp="y" sequence="100"></alias>
  <alias
    match  = "xeq"
    script = "CmdRequestEq"
    enabled="y" regexp="n" sequence="100"></alias>
  <alias
    match  = "utility show"
    script = "CmdUtilityShow"
    enabled="y" sequence="100" ignore_case="y"></alias>
  <alias
     match  = "utility hide"
     script = "CmdUtilityHide"
     enabled="y" sequence="100" ignore_case="y"></alias>
  <alias
   match="eqset wear *"
   enabled="y"
   send_to="12"
   sequence="100"
   ignore_case="y"
  >
  <send>
EnableTriggerGroup("eqcheck", false)
Execute ("eqset wea %1")
DoAfter (5, "eq")
</send>
  </alias>
  <alias
   match="rem all"
   enabled="y"
   send_to="14"
   sequence="100"
   ignore_case="y"
  >
  <send>
EnableTriggerGroup("eqcheck", false)
Execute ("remov all")
DoAfterSpecial (1, 'EnableTriggerGroup ("eqcheck", true)', sendto.script)
DoAfter (1.1, "eq")
</send>
  </alias>
  <alias
   match="remove all"
   enabled="y"
   send_to="14"
   sequence="100"
   ignore_case="y"
  >
  <send>
EnableTriggerGroup("eqcheck", false)
Execute ("remov all")
DoAfterSpecial (1, 'EnableTriggerGroup ("eqcheck", true)', sendto.script)
DoAfter (1.1, "eq")
</send>
  </alias>
  <alias
   match="wear all"
   enabled="y"
   send_to="14"
   sequence="100"
   ignore_case="y"
  >
  <send>
EnableTriggerGroup("eqcheck", false)
Execute ("wea all")
DoAfterSpecial (1, 'EnableTriggerGroup ("eqcheck", true)', sendto.script)
DoAfter (1.1, "eq")
</send>
  </alias>
</aliases>

<triggers>
  <!-- Catch Equipment -->
    <trigger
      match="{eq_start}"
      name ="eqStart"
      enabled="y" regexp="n" omit_from_output="y" sequence="100" send_to="12">
      <send>
        eqList = {}
        EnableTriggerGroup("catchEq", true)
      </send>
    </trigger>
    <trigger
      match="{eq_end}"
      group="catchEq"
      enabled="n" regexp="n" omit_from_output="y" sequence="90" send_to="12">
      <send>
        EnableTriggerGroup("catchEq", false)
        DrawTabs()
      </send>
    </trigger>
    <trigger
      match ="You are using:"
      group ="catchEq"
      enabled="n" regexp="n" omit_from_output="y" sequence="90">
    </trigger>
    <trigger
      match ="^[\w ]+\s+-.+$"
      group ="catchEq"
      script="TrgCatchEq"
      enabled="n" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
  <!-- Catch Affects -->
    <trigger
      match  = "^kxwt_spst (?<spell>.*?)(?:, (?<hour>\d+|one|two) hours?)?(?:, (?<minute>\d+) minutes?)?$"
      script = "TrgSpellUpdate"
      enabled="y" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
    <trigger
      match  = "^Spell '(?<spell>.*?)'(?:, maintained, level \d+)?$"
      script = "TrgSpellUpdate"
      enabled="y" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
    <trigger
      match  = "^Spell '(?<spell>.*?)'(?:, (?<hour>\d+|one|two) hours?)?(?:, (?<minute>\d+) minutes?)?(?: remaining)?(?:, level \d+)?$"
      script = "TrgSpellUpdate"
      enabled="y" regexp="y" omit_from_output="n" sequence="100">
    </trigger>
    <trigger
      match  = "^kxwt_spellup (?<spell>.*?)$"
      script = "TrgSpellUp"
      enabled="y" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
    <trigger
      match  = "^kxwt_spelldown (?<spell>.*?)$"
      script = "TrgSpellDown"
      enabled="y" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
    <trigger
      match  = "^\{aff_(start|end)\}$"
      enabled="y" regexp="y" omit_from_output="y" sequence="100">
    </trigger>
    <trigger
      match = "kxwt_myname *"
      enabled="y" regexp="n" send_to="12" sequence="100">
        <send>
          Execute("aff")
        </send>
    </trigger>
  <!-- Equipment Changes -->
    <trigger
      match = "You stop using *"
   group="eqcheck"
      enabled="y" regexp="n" send_to="12" sequence="100">
        <send>
          Execute("xeq")
        </send>
    </trigger>
    <trigger
      match = "You wield *."
     group="eqcheck"
      enabled="y" regexp="n" send_to="12" sequence="100">
        <send>
          Sound("sounds/Equip.wav")
          Execute("xeq")
        </send>
    </trigger>
    <trigger
      match = "You wear *."
   group="eqcheck"
      enabled="y" regexp="n" send_to="12" sequence="100">
        <send>
          Sound("sounds/Equip.wav")
          Execute("xeq")
        </send>
    </trigger>
<trigger
   enabled="y"
   match="You are now wearing set '*'."
   regexp="n"
   omit_from_output="n"
   name="eqsetcomplete"
   send_to="12"
   sequence="100">
<send>
EnableTriggerGroup("eqcheck", true)
Sound ("sounds/Equip.wav") 
</send>
></trigger>
</triggers>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<script>
<![CDATA[
-------------------------------------------------------------------------------
-- Miniwindow Includes & Variables
-------------------------------------------------------------------------------
  require "mw_theme_base"
  require "movewindow"
  require "tprint"

  dofile(GetPluginInfo(GetPluginID(), 20) .. "aardwolf_colors.lua")

  -- Variables
  defaultWidth    = 657
  defaultHeight   = 331
  defaultX        = 0
  defaultY        = 0
  defaultFontName = "Dina"
  defaultFontSize = "8"

  width  = tonumber(GetVariable("WINDOW_WIDTH")) or defaultWidth
  height = tonumber(GetVariable("WINDOW_HEIGHT")) or defaultHeight

  currentTab = "tabAff"
local ShowWindow = GetVariable("win_shown")


-------------------------------------------------------------------------------
-- Variables
-------------------------------------------------------------------------------
  eqList     = {}
  affList    = {}
  permSpells = {
    -- "darken",
    -- "still air",
    -- "feather fall"
    -- "infravision"
    -- "extended sight"
    -- "detect invisibility"
    -- "invisibility"

  }
  spellList  = {
    -- "armor",
    -- "clear thinking",
    -- "conceal alignment",
    -- "crystal coat",
    -- "darken",
    -- "displacement",
    -- "feather fall",
    -- "fire shield",
    -- "fly",
    -- "ground",
    -- "ice shield",
    -- "protection from evil",
    -- "sanctuary",
    -- "shield",
    -- "slow poison",
    -- "still air",
    -- "water breathing"
    -- "mana shield"
    -- "strength"
    -- "dexterity"
    -- "sanctuary"
    -- "prayer for the dying"
    -- "curse ward"
    
  }


-------------------------------------------------------------------------------
-- Commands
-------------------------------------------------------------------------------
  function CmdSwitchTab(name, line, w, s)
    if w.tab == "eq" then
      currentTab = "tabEq"
    else
      currentTab = "tabAff"
    end

    if name == "aEqAffRequest" then
      Send(line)
    end

    DrawTabs()
  end

  function CmdRequestEq(name, line, w, s)
    Send("eq")
  end

  function CmdUtilityShow(name, line, w, s)
    ColourNote("yellow", "", "Utility window now shown. Type 'utility hide' to hide it.")
ShowWindow = true
SetVariable("win_shown", "true")
WindowShow( win, ShowWindow )
  end

  function CmdUtilityHide(name, line, w, s)
   ColourNote ("yellow", "", "Utility window now hidden. Type 'utility show' to see it again.")
ShowWindow = false
SetVariable("win_shown", "false")
   WindowShow( win, ShowWindow )
  end


-------------------------------------------------------------------------------
-- Tabs
-------------------------------------------------------------------------------
  function DrawEquipment()
    WindowRectOp(win, 2, drawLeft, drawTop + tabFontHeight + 6, drawRight, drawBottom, Theme.PRIMARY_BODY) -- clear

    for i, line in ipairs(eqList) do
      DrawLine(i, line)
    end
  end

  function DrawAffects()
    WindowRectOp(win, 2, drawLeft, drawTop + tabFontHeight + 6, drawRight, drawBottom, Theme.PRIMARY_BODY) -- clear

    local lineIndex = 0
    for i = 1, #spellList, 2 do
      lineIndex = lineIndex + 1
      local line = SpellColumn(spellList[i], affList[i])
      line = line .. SpellColumn(spellList[i + 1], affList[i + 1])
      DrawLine(lineIndex, ColoursToStyles(line))
    end
  end

  function SpellColumn(spell, affect)
    if not spell then return "" end

    local color = "@G"

    if not affect then
      color = "@x238"
    elseif affect.off then
      color = "@x238"
    elseif isPerm(spell) then
      color = "@w"
    elseif affect.hour == 0 and affect.minute < 10 then
      color = "@R"
    elseif affect.hour == 0 and affect.minute < 30 then
      color = "@Y"
    end

      if not affect then
      if isPerm(spell) then
        affect = { hour = 99, minute = 99 }
      else
        affect = { hour = 0, minute = 0 }
      end
    end

    if isPerm(spell) then
      return string.format(
        "@w[%s@RPERMA@w] %s%-25s",
        color,
        color,
        spell
      )
    end

    return string.format(
      "@w[%s%02d@W:%s%02d@w] %s%-25s",
      color,
      affect.hour,
      color,
      affect.minute,
      color,
      spell
    )
  end


-------------------------------------------------------------------------------
-- Triggers
-------------------------------------------------------------------------------
  function TrgCatchEq(name, line, w, s)
    if line:sub(1, 4) == "kxwt" then
      return
    end
    table.insert(eqList, s)
  end

  function TrgSpellUpdate(name, line, w, s)
    local spellId = GetSpellId(w.spell)

    if spellId == 0 then
      table.insert(spellList, w.spell)
      spellId = #spellList
    end

    if w.hour == "" and w.minute == "" then
      table.insert(permSpells, w.spell)
    end

    local affect = { hour = 0, minute = 0, off = false }

    if w.hour and w.hour ~= "" then
      if w.hour == "one" then
        affect.hour = 1
      elseif w.hour == "two" then
        affect.hour = 2
      else
        affect.hour = tonumber(w.hour)
      end
    end

    if w.minute and w.minute ~= "" then
      affect.minute = tonumber(w.minute)
    end

    if isPerm(w.spell) then
      affect = { hour = 99, minute = 99, off = false }
    end

    affList[spellId] = affect

    DrawTabs()
  end

  function TrgSpellUp(name, line, w, s)
    local spellId = GetSpellId(w.spell)

    --if isPerm(w.spell) then
      affList[spellId] = { hour = 99, minute = 99, off = false }
    --end

    DrawTabs()
  end

  function TrgSpellDown(name, line, w, s)
    local spellId = GetSpellId(w.spell)

    if affList[spellId] then
      affList[spellId] = { hour = 0, minute = 0, off = true }
    end

    if isPerm(w.spell) then
      affList[spellId] = { hour = 99, minute = 99, off = true }
    end

    DrawTabs()
  end

  function GetSpellId(spellName)
    for i, spell in ipairs(spellList) do
      if spellName == spell then
        return i
      end
    end

    return 0
  end

  function isPerm(spellName)
    for i, spell in ipairs(permSpells) do
      if spellName == spell then
        return true
      end
    end

    return false
  end


-------------------------------------------------------------------------------
-- Mush Client Callbacks
-------------------------------------------------------------------------------
  function OnPluginBroadcast(msg, id, name, text)
    -- Look for GMCP handler.
    if (id == "462b665ecb569efbf261422f" and msg == 996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)
    end
  end

  function OnPluginInstall()
    Init()
    SetupDisplay()
end
ShowWindow = true 
if GetVariable("win_shown") == "false" then ShowWindow = false 
  end

  function OnPluginEnable ()
    WindowShow(win, ShowWindow)
  end

  function OnPluginDisable()
    WindowShow(win, ShowWindow)
  end

  function OnPluginClose()
    WindowDelete(win)
  end

  function OnPluginSaveState()
    -- save window current location for next time
    movewindow.save_state(win)

    if WindowInfo(win, 3) and WindowInfo(win, 4) then
      width  = WindowInfo(win, 3)
      height = WindowInfo(win, 4)
    end

    SetVariable("fontName",      fontName)
    SetVariable("fontSize",      fontSize)
    SetVariable("WINDOW_WIDTH",  width)
    SetVariable("WINDOW_HEIGHT", height)
  end


-------------------------------------------------------------------------------
-- Miniwindow Drawing
-------------------------------------------------------------------------------
  function Init()
    win = GetPluginID()

    local fonts = utils.getfontfamilies()

    if not fonts.Dina then
      AddFont(GetInfo (66) .. "\\Dina.fon")
    end

    windowinfo = movewindow.install(
      win,
      miniwin.pos_top_right,
      miniwin.create_absolute_location,
      false,
      nil,
      {
        mouseup     = MouseUp,
        mousedown   = LeftClickOnly,
        dragmove    = LeftClickOnly,
        dragrelease = LeftClickOnly
      },{
        x = defaultX,
        y = defaultY
      }
    )

    WindowCreate(
      win,
      windowinfo.window_left,
      windowinfo.window_top,
      width,
      height,
      windowinfo.window_mode,
      windowinfo.window_flags,
      Theme.SECONDARY_BODY
    )

    -- Add handler for resizing
    WindowAddHotspot(win, "resize", width-Theme.RESIZER_SIZE, height-Theme.RESIZER_SIZE, width, height, nil, nil, "MouseDown", nil, nil, "", 6, 0)
    WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)

    WindowShow(win, ShowWindow)

    -- register with the z-order monitor
    CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)

    fontName =          GetVariable("fontName")  or defaultFontName
    fontSize = tonumber(GetVariable("fontSize")) or defaultFontSize

    WindowFont(win, "windowFont", fontName, fontSize, false, false, false, false, 0)
    tabFontHeight = Theme.TextHeight(win, "windowFont")
  end

  function SetupDisplay()
    WindowResize(win, width, height, 0x000000)

    -- Draw Background
    drawLeft, drawTop, drawRight, drawBottom = Theme.DressWindow(win, "windowFont", "Equipment Window", nil)

    trLeft   = drawLeft
    tabTop   = drawTop + 2
    trTop    = tabTop + tabFontHeight + 4
    trRight  = drawRight
    trBottom = drawBottom

    DrawTabs()
  end

  function DrawTabs(mouseover)
    tab = {
      left        = drawLeft + 5,
      padding     = Theme.DYNAMIC_BUTTON_PADDING,
      activeLeft  = nil,
      activeWidth = nil
    }

    WindowRectOp(win, miniwin.rect_fill, drawLeft, drawTop, drawRight + 1, drawTop + tabFontHeight + 5, Theme.SECONDARY_BODY)

    -- Equipment Tab
    DrawTab("Equipment", "tabEq", mouseover)

    -- Affects Tab
    DrawTab("Affects", "tabAff", mouseover)

    WindowLine(win, drawLeft, tabTop + tabFontHeight + 3, drawRight + 1, tabTop + tabFontHeight + 3, Theme.THREE_D_HIGHLIGHT, 0 + 0x0200, 1)
    WindowCircleOp(
      win, miniwin.circle_round_rectangle,
      tab.activeLeft, tabTop, tab.activeLeft + tab.activeWidth, tabTop + (2 * tabFontHeight) + 4, -- coords
      Theme.THREE_D_HIGHLIGHT, miniwin.pen_solid, 1,          -- pen
      Theme.PRIMARY_BODY, miniwin.brush_solid,  -- brush
      16,   -- width of the ellipse used to draw the rounded corner
      (2 * tabFontHeight) + 4   -- height of the ellipse used to draw the rounded corner
    )
    WindowText(
      win,
      "windowFont",
      ((currentTab == "tabEq" and "Equipment") or "Affects"),
      tab.activeLeft + tab.padding, tabTop + 2, drawRight, drawTop + tabFontHeight + 3,
      Theme.BODY_TEXT,
      false
    )

    if currentTab == "tabEq" then
      DrawEquipment()
    elseif currentTab == "tabAff" then
      DrawAffects()
    end

    Theme.AddResizeTag(win, 1, nil, nil, "MouseDown", "ResizeMoveCallback", "ResizeReleaseCallback")
    CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
  end

  function DrawTab(name, slug, mouseover)
    local tabWidth = WindowTextWidth(win, "windowFont", name) + (tab.padding * 2)

    if not WindowHotspotInfo(win, slug, 1) then
       WindowAddHotspot(win, slug, tab.left, tabTop, tab.left + tabWidth, tabTop + tabFontHeight + 3, "tabMouseOver", "tabCancelMouseOver", "tabMouseDown", nil, "tabMouseUp", "", 1, 0)
    else
       WindowMoveHotspot(win, slug, tab.left, tabTop, tab.left + tabWidth, tabTop + tabFontHeight + 3)
    end

    local textColor = Theme.BODY_TEXT
    local bgColor

    if currentTab == slug then
      tab.activeLeft  = tab.left
      tab.activeWidth = tabWidth
    else
      if mouseover ~= slug then
        bgColor   = Theme.CLICKABLE
        textColor = Theme.CLICKABLE_TEXT
      else
        bgColor   = Theme.CLICKABLE_HOVER
        textColor = Theme.CLICKABLE_HOVER_TEXT
      end

      WindowCircleOp(
        win,
        miniwin.circle_round_rectangle,
        tab.left,
        tabTop,
        tab.left + tabWidth,
        tabTop + (2 * tabFontHeight) + 4,
        Theme.THREE_D_HIGHLIGHT, miniwin.pen_solid, 1,
        bgColor, miniwin.brush_solid,
        16,
        (2 * tabFontHeight) + 4  -- height of the ellipse used to draw the rounded corner
      )
    end

    tab.left = tab.left + tab.padding
    tab.left = tab.left + WindowText(win, "windowFont", name, tab.left, tabTop + 2, drawRight, drawTop + tabFontHeight + 3, textColor, false)
    tab.left = tab.left + tab.padding
  end

  function SetTab(slug)
    currentTab = slug
    SetupDisplay()
    Repaint()
  end

  function DrawLine(line, styles)
    local left = drawLeft + 5
    local top  = drawTop + 10 + (line * tabFontHeight)

    if not styles then
      return
    end

    for _, v in ipairs(styles) do
      local t = v.text
      left = left + WindowText(win, "windowFont", t, left, top, drawRight, drawBottom, v.textcolour)
    end
  end


-------------------------------------------------------------------------------
-- Resize Window
-------------------------------------------------------------------------------
  function ResizeMoveCallback()
    if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
      return
    end

    posx, posy = WindowInfo(win, 17), WindowInfo(win, 18)
    width  = width + posx - startx
    startx = posx

    if (WindowTextWidth(win, "windowFont", "Equipment Window")+2*Theme.RESIZER_SIZE > width) then
      width  = WindowTextWidth(win, "windowFont", "Equipment Window") + 2 * Theme.RESIZER_SIZE
      startx = windowinfo.window_left + width
    elseif (windowinfo.window_left + width > GetInfo(281)) then
      width  = GetInfo(281) - windowinfo.window_left
      startx = GetInfo(281)
    end
    height = height + posy - starty
    starty = posy
    if (3 * Theme.RESIZER_SIZE + 70 > height) then
      height = 3 * Theme.RESIZER_SIZE + 70
      starty = windowinfo.window_top + height
    elseif (windowinfo.window_top + height > GetInfo(280)) then
      height = GetInfo(280) - windowinfo.window_top
      starty = GetInfo(280)
    end
    if (utils.timer() - lastRefresh > 0.0333) then
      SetupDisplay()
      lastRefresh = utils.timer()
    end
  end

  lastRefresh = 0

  function ResizeReleaseCallback ()
    SetupDisplay()

    WindowMoveHotspot(win, "resize", drawRight - Theme.RESIZER_SIZE, drawBottom - Theme.RESIZER_SIZE, 0, 0)
  end


-------------------------------------------------------------------------------
-- Mouse Events
-------------------------------------------------------------------------------
  function MouseDown(flags, hotspotId)
    if (hotspotId == "resize") then
      startx, starty = WindowInfo(win, 17), WindowInfo(win, 18)
    end
  end

  function tabMouseOver(flags, hotspotId)
    DrawTabs(hotspotId)
  end

  function tabCancelMouseOver(flags, hotspotId)
    DrawTabs()
  end

  function tabMouseDown(flags, hotspotId)
    SetTab(hotspotId)
  end

  function tabMouseUp(flags, hotspotId)
    if hotspotId == "titlebar" then
      hotspotId = currentTab
    end
  end

]]>
</script>
</muclient>
